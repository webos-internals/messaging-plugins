diff -rupN pidgin-2.7.7/libpurple/blist.c pidgin-2.7.7-new//libpurple/blist.c
--- pidgin-2.7.7/libpurple/blist.c	2011-03-27 09:05:47.872553000 -0600
+++ pidgin-2.7.7-new//libpurple/blist.c	2011-03-27 09:15:30.072552999 -0600
@@ -1059,7 +1059,7 @@ void purple_blist_alias_contact(PurpleCo
 
 	purple_signal_emit(purple_blist_get_handle(), "blist-node-aliased",
 					 contact, old_alias);
-	g_free(old_alias);
+//	g_free(old_alias);
 }
 
 void purple_blist_alias_chat(PurpleChat *chat, const char *alias)
@@ -1137,7 +1137,7 @@ void purple_blist_alias_buddy(PurpleBudd
 
 	purple_signal_emit(purple_blist_get_handle(), "blist-node-aliased",
 					 buddy, old_alias);
-	g_free(old_alias);
+//	g_free(old_alias);
 }
 
 void purple_blist_server_alias_buddy(PurpleBuddy *buddy, const char *alias)
@@ -1179,7 +1179,7 @@ void purple_blist_server_alias_buddy(Pur
 
 	purple_signal_emit(purple_blist_get_handle(), "blist-node-aliased",
 					 buddy, old_alias);
-	g_free(old_alias);
+//	g_free(old_alias);
 }
 
 /*
diff -rupN pidgin-2.7.7/libpurple/blist.c~ pidgin-2.7.7-new//libpurple/blist.c~
--- pidgin-2.7.7/libpurple/blist.c~	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/blist.c~	2011-03-27 09:15:30.064552999 -0600
@@ -0,0 +1,3266 @@
+/*
+ * purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+#define _PURPLE_BLIST_C_
+
+#include "internal.h"
+#include "blist.h"
+#include "conversation.h"
+#include "dbus-maybe.h"
+#include "debug.h"
+#include "notify.h"
+#include "prefs.h"
+#include "privacy.h"
+#include "prpl.h"
+#include "server.h"
+#include "signals.h"
+#include "util.h"
+#include "value.h"
+#include "xmlnode.h"
+
+static PurpleBlistUiOps *blist_ui_ops = NULL;
+
+static PurpleBuddyList *purplebuddylist = NULL;
+
+/**
+ * A hash table used for efficient lookups of buddies by name.
+ * PurpleAccount* => GHashTable*, with the inner hash table being
+ * struct _purple_hbuddy => PurpleBuddy*
+ */
+static GHashTable *buddies_cache = NULL;
+
+/**
+ * A hash table used for efficient lookups of groups by name.
+ * UTF-8 collate-key => PurpleGroup*.
+ */
+static GHashTable *groups_cache = NULL;
+
+static guint          save_timer = 0;
+static gboolean       blist_loaded = FALSE;
+
+/*********************************************************************
+ * Private utility functions                                         *
+ *********************************************************************/
+
+static PurpleBlistNode *purple_blist_get_last_sibling(PurpleBlistNode *node)
+{
+	PurpleBlistNode *n = node;
+	if (!n)
+		return NULL;
+	while (n->next)
+		n = n->next;
+	return n;
+}
+
+static PurpleBlistNode *purple_blist_get_last_child(PurpleBlistNode *node)
+{
+	if (!node)
+		return NULL;
+	return purple_blist_get_last_sibling(node->child);
+}
+
+struct _list_account_buddies {
+	GSList *list;
+	PurpleAccount *account;
+};
+
+struct _purple_hbuddy {
+	char *name;
+	PurpleAccount *account;
+	PurpleBlistNode *group;
+};
+
+/* This function must not use purple_normalize */
+static guint _purple_blist_hbuddy_hash(struct _purple_hbuddy *hb)
+{
+	return g_str_hash(hb->name) ^ g_direct_hash(hb->group) ^ g_direct_hash(hb->account);
+}
+
+/* This function must not use purple_normalize */
+static guint _purple_blist_hbuddy_equal(struct _purple_hbuddy *hb1, struct _purple_hbuddy *hb2)
+{
+	return (hb1->group == hb2->group &&
+	        hb1->account == hb2->account &&
+	        g_str_equal(hb1->name, hb2->name));
+}
+
+static void _purple_blist_hbuddy_free_key(struct _purple_hbuddy *hb)
+{
+	g_free(hb->name);
+	g_free(hb);
+}
+
+static void
+purple_blist_buddies_cache_add_account(PurpleAccount *account)
+{
+	GHashTable *account_buddies = g_hash_table_new_full((GHashFunc)_purple_blist_hbuddy_hash,
+						(GEqualFunc)_purple_blist_hbuddy_equal,
+						(GDestroyNotify)_purple_blist_hbuddy_free_key, NULL);
+	g_hash_table_insert(buddies_cache, account, account_buddies);
+}
+
+static void
+purple_blist_buddies_cache_remove_account(const PurpleAccount *account)
+{
+	g_hash_table_remove(buddies_cache, account);
+}
+
+
+/*********************************************************************
+ * Writing to disk                                                   *
+ *********************************************************************/
+
+static void
+value_to_xmlnode(gpointer key, gpointer hvalue, gpointer user_data)
+{
+	const char *name;
+	PurpleValue *value;
+	xmlnode *node, *child;
+	char buf[21];
+
+	name    = (const char *)key;
+	value   = (PurpleValue *)hvalue;
+	node    = (xmlnode *)user_data;
+
+	g_return_if_fail(value != NULL);
+
+	child = xmlnode_new_child(node, "setting");
+	xmlnode_set_attrib(child, "name", name);
+
+	if (purple_value_get_type(value) == PURPLE_TYPE_INT) {
+		xmlnode_set_attrib(child, "type", "int");
+		g_snprintf(buf, sizeof(buf), "%d", purple_value_get_int(value));
+		xmlnode_insert_data(child, buf, -1);
+	}
+	else if (purple_value_get_type(value) == PURPLE_TYPE_STRING) {
+		xmlnode_set_attrib(child, "type", "string");
+		xmlnode_insert_data(child, purple_value_get_string(value), -1);
+	}
+	else if (purple_value_get_type(value) == PURPLE_TYPE_BOOLEAN) {
+		xmlnode_set_attrib(child, "type", "bool");
+		g_snprintf(buf, sizeof(buf), "%d", purple_value_get_boolean(value));
+		xmlnode_insert_data(child, buf, -1);
+	}
+}
+
+static void
+chat_component_to_xmlnode(gpointer key, gpointer value, gpointer user_data)
+{
+	const char *name;
+	const char *data;
+	xmlnode *node, *child;
+
+	name = (const char *)key;
+	data = (const char *)value;
+	node = (xmlnode *)user_data;
+
+	g_return_if_fail(data != NULL);
+
+	child = xmlnode_new_child(node, "component");
+	xmlnode_set_attrib(child, "name", name);
+	xmlnode_insert_data(child, data, -1);
+}
+
+static xmlnode *
+buddy_to_xmlnode(PurpleBlistNode *bnode)
+{
+	xmlnode *node, *child;
+	PurpleBuddy *buddy;
+
+	buddy = (PurpleBuddy *)bnode;
+
+	node = xmlnode_new("buddy");
+	xmlnode_set_attrib(node, "account", purple_account_get_username(buddy->account));
+	xmlnode_set_attrib(node, "proto", purple_account_get_protocol_id(buddy->account));
+
+	child = xmlnode_new_child(node, "name");
+	xmlnode_insert_data(child, buddy->name, -1);
+
+	if (buddy->alias != NULL)
+	{
+		child = xmlnode_new_child(node, "alias");
+		xmlnode_insert_data(child, buddy->alias, -1);
+	}
+
+	/* Write buddy settings */
+	g_hash_table_foreach(buddy->node.settings, value_to_xmlnode, node);
+
+	return node;
+}
+
+static xmlnode *
+contact_to_xmlnode(PurpleBlistNode *cnode)
+{
+	xmlnode *node, *child;
+	PurpleContact *contact;
+	PurpleBlistNode *bnode;
+
+	contact = (PurpleContact *)cnode;
+
+	node = xmlnode_new("contact");
+
+	if (contact->alias != NULL)
+	{
+		xmlnode_set_attrib(node, "alias", contact->alias);
+	}
+
+	/* Write buddies */
+	for (bnode = cnode->child; bnode != NULL; bnode = bnode->next)
+	{
+		if (!PURPLE_BLIST_NODE_SHOULD_SAVE(bnode))
+			continue;
+		if (PURPLE_BLIST_NODE_IS_BUDDY(bnode))
+		{
+			child = buddy_to_xmlnode(bnode);
+			xmlnode_insert_child(node, child);
+		}
+	}
+
+	/* Write contact settings */
+	g_hash_table_foreach(cnode->settings, value_to_xmlnode, node);
+
+	return node;
+}
+
+static xmlnode *
+chat_to_xmlnode(PurpleBlistNode *cnode)
+{
+	xmlnode *node, *child;
+	PurpleChat *chat;
+
+	chat = (PurpleChat *)cnode;
+
+	node = xmlnode_new("chat");
+	xmlnode_set_attrib(node, "proto", purple_account_get_protocol_id(chat->account));
+	xmlnode_set_attrib(node, "account", purple_account_get_username(chat->account));
+
+	if (chat->alias != NULL)
+	{
+		child = xmlnode_new_child(node, "alias");
+		xmlnode_insert_data(child, chat->alias, -1);
+	}
+
+	/* Write chat components */
+	g_hash_table_foreach(chat->components, chat_component_to_xmlnode, node);
+
+	/* Write chat settings */
+	g_hash_table_foreach(chat->node.settings, value_to_xmlnode, node);
+
+	return node;
+}
+
+static xmlnode *
+group_to_xmlnode(PurpleBlistNode *gnode)
+{
+	xmlnode *node, *child;
+	PurpleGroup *group;
+	PurpleBlistNode *cnode;
+
+	group = (PurpleGroup *)gnode;
+
+	node = xmlnode_new("group");
+	xmlnode_set_attrib(node, "name", group->name);
+
+	/* Write settings */
+	g_hash_table_foreach(group->node.settings, value_to_xmlnode, node);
+
+	/* Write contacts and chats */
+	for (cnode = gnode->child; cnode != NULL; cnode = cnode->next)
+	{
+		if (!PURPLE_BLIST_NODE_SHOULD_SAVE(cnode))
+			continue;
+		if (PURPLE_BLIST_NODE_IS_CONTACT(cnode))
+		{
+			child = contact_to_xmlnode(cnode);
+			xmlnode_insert_child(node, child);
+		}
+		else if (PURPLE_BLIST_NODE_IS_CHAT(cnode))
+		{
+			child = chat_to_xmlnode(cnode);
+			xmlnode_insert_child(node, child);
+		}
+	}
+
+	return node;
+}
+
+static xmlnode *
+accountprivacy_to_xmlnode(PurpleAccount *account)
+{
+	xmlnode *node, *child;
+	GSList *cur;
+	char buf[10];
+
+	node = xmlnode_new("account");
+	xmlnode_set_attrib(node, "proto", purple_account_get_protocol_id(account));
+	xmlnode_set_attrib(node, "name", purple_account_get_username(account));
+	g_snprintf(buf, sizeof(buf), "%d", account->perm_deny);
+	xmlnode_set_attrib(node, "mode", buf);
+
+	for (cur = account->permit; cur; cur = cur->next)
+	{
+		child = xmlnode_new_child(node, "permit");
+		xmlnode_insert_data(child, cur->data, -1);
+	}
+
+	for (cur = account->deny; cur; cur = cur->next)
+	{
+		child = xmlnode_new_child(node, "block");
+		xmlnode_insert_data(child, cur->data, -1);
+	}
+
+	return node;
+}
+
+static xmlnode *
+blist_to_xmlnode(void)
+{
+	xmlnode *node, *child, *grandchild;
+	PurpleBlistNode *gnode;
+	GList *cur;
+
+	node = xmlnode_new("purple");
+	xmlnode_set_attrib(node, "version", "1.0");
+
+	/* Write groups */
+	child = xmlnode_new_child(node, "blist");
+	for (gnode = purplebuddylist->root; gnode != NULL; gnode = gnode->next)
+	{
+		if (!PURPLE_BLIST_NODE_SHOULD_SAVE(gnode))
+			continue;
+		if (PURPLE_BLIST_NODE_IS_GROUP(gnode))
+		{
+			grandchild = group_to_xmlnode(gnode);
+			xmlnode_insert_child(child, grandchild);
+		}
+	}
+
+	/* Write privacy settings */
+	child = xmlnode_new_child(node, "privacy");
+	for (cur = purple_accounts_get_all(); cur != NULL; cur = cur->next)
+	{
+		grandchild = accountprivacy_to_xmlnode(cur->data);
+		xmlnode_insert_child(child, grandchild);
+	}
+
+	return node;
+}
+
+static void
+purple_blist_sync(void)
+{
+	xmlnode *node;
+	char *data;
+
+	if (!blist_loaded)
+	{
+		purple_debug_error("blist", "Attempted to save buddy list before it "
+						 "was read!\n");
+		return;
+	}
+
+	node = blist_to_xmlnode();
+	data = xmlnode_to_formatted_str(node, NULL);
+	purple_util_write_data_to_file("blist.xml", data, -1);
+	g_free(data);
+	xmlnode_free(node);
+}
+
+static gboolean
+save_cb(gpointer data)
+{
+	purple_blist_sync();
+	save_timer = 0;
+	return FALSE;
+}
+
+static void
+_purple_blist_schedule_save()
+{
+	if (save_timer == 0)
+		save_timer = purple_timeout_add_seconds(5, save_cb, NULL);
+}
+
+static void
+purple_blist_save_account(PurpleAccount *account)
+{
+#if 1
+	_purple_blist_schedule_save();
+#else
+	if (account != NULL) {
+		/* Save the buddies and privacy data for this account */
+	} else {
+		/* Save all buddies and privacy data */
+	}
+#endif
+}
+
+static void
+purple_blist_save_node(PurpleBlistNode *node)
+{
+	_purple_blist_schedule_save();
+}
+
+void purple_blist_schedule_save()
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+
+	/* Save everything */
+	if (ops && ops->save_account)
+		ops->save_account(NULL);
+}
+
+
+/*********************************************************************
+ * Reading from disk                                                 *
+ *********************************************************************/
+
+static void
+parse_setting(PurpleBlistNode *node, xmlnode *setting)
+{
+	const char *name = xmlnode_get_attrib(setting, "name");
+	const char *type = xmlnode_get_attrib(setting, "type");
+	char *value = xmlnode_get_data(setting);
+
+	if (!value)
+		return;
+
+	if (!type || purple_strequal(type, "string"))
+		purple_blist_node_set_string(node, name, value);
+	else if (purple_strequal(type, "bool"))
+		purple_blist_node_set_bool(node, name, atoi(value));
+	else if (purple_strequal(type, "int"))
+		purple_blist_node_set_int(node, name, atoi(value));
+
+	g_free(value);
+}
+
+static void
+parse_buddy(PurpleGroup *group, PurpleContact *contact, xmlnode *bnode)
+{
+	PurpleAccount *account;
+	PurpleBuddy *buddy;
+	char *name = NULL, *alias = NULL;
+	const char *acct_name, *proto, *protocol;
+	xmlnode *x;
+
+	acct_name = xmlnode_get_attrib(bnode, "account");
+	protocol = xmlnode_get_attrib(bnode, "protocol");
+	protocol = _purple_oscar_convert(acct_name, protocol); /* XXX: Remove */
+	proto = xmlnode_get_attrib(bnode, "proto");
+	proto = _purple_oscar_convert(acct_name, proto); /* XXX: Remove */
+
+	if (!acct_name || (!proto && !protocol))
+		return;
+
+	account = purple_accounts_find(acct_name, proto ? proto : protocol);
+
+	if (!account)
+		return;
+
+	if ((x = xmlnode_get_child(bnode, "name")))
+		name = xmlnode_get_data(x);
+
+	if (!name)
+		return;
+
+	if ((x = xmlnode_get_child(bnode, "alias")))
+		alias = xmlnode_get_data(x);
+
+	buddy = purple_buddy_new(account, name, alias);
+	purple_blist_add_buddy(buddy, contact, group,
+			purple_blist_get_last_child((PurpleBlistNode*)contact));
+
+	for (x = xmlnode_get_child(bnode, "setting"); x; x = xmlnode_get_next_twin(x)) {
+		parse_setting((PurpleBlistNode*)buddy, x);
+	}
+
+	g_free(name);
+	g_free(alias);
+}
+
+static void
+parse_contact(PurpleGroup *group, xmlnode *cnode)
+{
+	PurpleContact *contact = purple_contact_new();
+	xmlnode *x;
+	const char *alias;
+
+	purple_blist_add_contact(contact, group,
+			purple_blist_get_last_child((PurpleBlistNode*)group));
+
+	if ((alias = xmlnode_get_attrib(cnode, "alias"))) {
+		purple_blist_alias_contact(contact, alias);
+	}
+
+	for (x = cnode->child; x; x = x->next) {
+		if (x->type != XMLNODE_TYPE_TAG)
+			continue;
+		if (purple_strequal(x->name, "buddy"))
+			parse_buddy(group, contact, x);
+		else if (purple_strequal(x->name, "setting"))
+			parse_setting((PurpleBlistNode*)contact, x);
+	}
+
+	/* if the contact is empty, don't keep it around.  it causes problems */
+	if (!((PurpleBlistNode*)contact)->child)
+		purple_blist_remove_contact(contact);
+}
+
+static void
+parse_chat(PurpleGroup *group, xmlnode *cnode)
+{
+	PurpleChat *chat;
+	PurpleAccount *account;
+	const char *acct_name, *proto, *protocol;
+	xmlnode *x;
+	char *alias = NULL;
+	GHashTable *components;
+
+	acct_name = xmlnode_get_attrib(cnode, "account");
+	protocol = xmlnode_get_attrib(cnode, "protocol");
+	proto = xmlnode_get_attrib(cnode, "proto");
+
+	if (!acct_name || (!proto && !protocol))
+		return;
+
+	account = purple_accounts_find(acct_name, proto ? proto : protocol);
+
+	if (!account)
+		return;
+
+	if ((x = xmlnode_get_child(cnode, "alias")))
+		alias = xmlnode_get_data(x);
+
+	components = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+
+	for (x = xmlnode_get_child(cnode, "component"); x; x = xmlnode_get_next_twin(x)) {
+		const char *name;
+		char *value;
+
+		name = xmlnode_get_attrib(x, "name");
+		value = xmlnode_get_data(x);
+		g_hash_table_replace(components, g_strdup(name), value);
+	}
+
+	chat = purple_chat_new(account, alias, components);
+	purple_blist_add_chat(chat, group,
+			purple_blist_get_last_child((PurpleBlistNode*)group));
+
+	for (x = xmlnode_get_child(cnode, "setting"); x; x = xmlnode_get_next_twin(x)) {
+		parse_setting((PurpleBlistNode*)chat, x);
+	}
+
+	g_free(alias);
+}
+
+static void
+parse_group(xmlnode *groupnode)
+{
+	const char *name = xmlnode_get_attrib(groupnode, "name");
+	PurpleGroup *group;
+	xmlnode *cnode;
+
+	if (!name)
+		name = _("Buddies");
+
+	group = purple_group_new(name);
+	purple_blist_add_group(group,
+			purple_blist_get_last_sibling(purplebuddylist->root));
+
+	for (cnode = groupnode->child; cnode; cnode = cnode->next) {
+		if (cnode->type != XMLNODE_TYPE_TAG)
+			continue;
+		if (purple_strequal(cnode->name, "setting"))
+			parse_setting((PurpleBlistNode*)group, cnode);
+		else if (purple_strequal(cnode->name, "contact") ||
+				purple_strequal(cnode->name, "person"))
+			parse_contact(group, cnode);
+		else if (purple_strequal(cnode->name, "chat"))
+			parse_chat(group, cnode);
+	}
+}
+
+/* TODO: Make static and rename to load_blist */
+void
+purple_blist_load()
+{
+	xmlnode *purple, *blist, *privacy;
+
+	blist_loaded = TRUE;
+
+	purple = purple_util_read_xml_from_file("blist.xml", _("buddy list"));
+
+	if (purple == NULL)
+		return;
+
+	blist = xmlnode_get_child(purple, "blist");
+	if (blist) {
+		xmlnode *groupnode;
+		for (groupnode = xmlnode_get_child(blist, "group"); groupnode != NULL;
+				groupnode = xmlnode_get_next_twin(groupnode)) {
+			parse_group(groupnode);
+		}
+	}
+
+	privacy = xmlnode_get_child(purple, "privacy");
+	if (privacy) {
+		xmlnode *anode;
+		for (anode = privacy->child; anode; anode = anode->next) {
+			xmlnode *x;
+			PurpleAccount *account;
+			int imode;
+			const char *acct_name, *proto, *mode, *protocol;
+
+			acct_name = xmlnode_get_attrib(anode, "name");
+			protocol = xmlnode_get_attrib(anode, "protocol");
+			proto = xmlnode_get_attrib(anode, "proto");
+			mode = xmlnode_get_attrib(anode, "mode");
+
+			if (!acct_name || (!proto && !protocol) || !mode)
+				continue;
+
+			account = purple_accounts_find(acct_name, proto ? proto : protocol);
+
+			if (!account)
+				continue;
+
+			imode = atoi(mode);
+			account->perm_deny = (imode != 0 ? imode : PURPLE_PRIVACY_ALLOW_ALL);
+
+			for (x = anode->child; x; x = x->next) {
+				char *name;
+				if (x->type != XMLNODE_TYPE_TAG)
+					continue;
+
+				if (purple_strequal(x->name, "permit")) {
+					name = xmlnode_get_data(x);
+					purple_privacy_permit_add(account, name, TRUE);
+					g_free(name);
+				} else if (purple_strequal(x->name, "block")) {
+					name = xmlnode_get_data(x);
+					purple_privacy_deny_add(account, name, TRUE);
+					g_free(name);
+				}
+			}
+		}
+	}
+
+	xmlnode_free(purple);
+
+	/* This tells the buddy icon code to do its thing. */
+	_purple_buddy_icons_blist_loaded_cb();
+}
+
+
+/*********************************************************************
+ * Stuff                                                             *
+ *********************************************************************/
+
+static void
+purple_contact_compute_priority_buddy(PurpleContact *contact)
+{
+	PurpleBlistNode *bnode;
+	PurpleBuddy *new_priority = NULL;
+
+	g_return_if_fail(contact != NULL);
+
+	contact->priority = NULL;
+	for (bnode = ((PurpleBlistNode*)contact)->child;
+			bnode != NULL;
+			bnode = bnode->next)
+	{
+		PurpleBuddy *buddy;
+
+		if (!PURPLE_BLIST_NODE_IS_BUDDY(bnode))
+			continue;
+
+		buddy = (PurpleBuddy*)bnode;
+		if (new_priority == NULL)
+		{
+			new_priority = buddy;
+			continue;
+		}
+
+		if (purple_account_is_connected(buddy->account))
+		{
+			int cmp = 1;
+			if (purple_account_is_connected(new_priority->account))
+				cmp = purple_presence_compare(purple_buddy_get_presence(new_priority),
+						purple_buddy_get_presence(buddy));
+
+			if (cmp > 0 || (cmp == 0 &&
+			                purple_prefs_get_bool("/purple/contact/last_match")))
+			{
+				new_priority = buddy;
+			}
+		}
+	}
+
+	contact->priority = new_priority;
+	contact->priority_valid = TRUE;
+}
+
+
+/*****************************************************************************
+ * Public API functions                                                      *
+ *****************************************************************************/
+
+PurpleBuddyList *purple_blist_new()
+{
+	PurpleBlistUiOps *ui_ops;
+	GList *account;
+	PurpleBuddyList *gbl = g_new0(PurpleBuddyList, 1);
+	PURPLE_DBUS_REGISTER_POINTER(gbl, PurpleBuddyList);
+
+	ui_ops = purple_blist_get_ui_ops();
+
+	gbl->buddies = g_hash_table_new_full((GHashFunc)_purple_blist_hbuddy_hash,
+					 (GEqualFunc)_purple_blist_hbuddy_equal,
+					 (GDestroyNotify)_purple_blist_hbuddy_free_key, NULL);
+
+	buddies_cache = g_hash_table_new_full(g_direct_hash, g_direct_equal,
+					 NULL, (GDestroyNotify)g_hash_table_destroy);
+
+	groups_cache = g_hash_table_new_full((GHashFunc)g_str_hash,
+					 (GEqualFunc)g_str_equal,
+					 (GDestroyNotify)g_free, NULL);
+
+	for (account = purple_accounts_get_all(); account != NULL; account = account->next)
+	{
+		purple_blist_buddies_cache_add_account(account->data);
+	}
+
+	if (ui_ops != NULL && ui_ops->new_list != NULL)
+		ui_ops->new_list(gbl);
+
+	return gbl;
+}
+
+void
+purple_set_blist(PurpleBuddyList *list)
+{
+	purplebuddylist = list;
+}
+
+PurpleBuddyList *
+purple_get_blist()
+{
+	return purplebuddylist;
+}
+
+PurpleBlistNode *
+purple_blist_get_root()
+{
+	return purplebuddylist ? purplebuddylist->root : NULL;
+}
+
+static void
+append_buddy(gpointer key, gpointer value, gpointer user_data)
+{
+	GSList **list = user_data;
+	*list = g_slist_prepend(*list, value);
+}
+
+GSList *
+purple_blist_get_buddies()
+{
+	GSList *buddies = NULL;
+
+	if (!purplebuddylist)
+		return NULL;
+
+	g_hash_table_foreach(purplebuddylist->buddies, append_buddy, &buddies);
+	return buddies;
+}
+
+void *
+purple_blist_get_ui_data()
+{
+	return purplebuddylist->ui_data;
+}
+
+void
+purple_blist_set_ui_data(void *ui_data)
+{
+	purplebuddylist->ui_data = ui_data;
+}
+
+void purple_blist_show()
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+
+	if (ops && ops->show)
+		ops->show(purplebuddylist);
+}
+
+void purple_blist_destroy()
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+
+	purple_debug(PURPLE_DEBUG_INFO, "blist", "Destroying\n");
+
+	if (ops && ops->destroy)
+		ops->destroy(purplebuddylist);
+}
+
+void purple_blist_set_visible(gboolean show)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+
+	if (ops && ops->set_visible)
+		ops->set_visible(purplebuddylist, show);
+}
+
+static PurpleBlistNode *get_next_node(PurpleBlistNode *node, gboolean godeep)
+{
+	if (node == NULL)
+		return NULL;
+
+	if (godeep && node->child)
+		return node->child;
+
+	if (node->next)
+		return node->next;
+
+	return get_next_node(node->parent, FALSE);
+}
+
+PurpleBlistNode *purple_blist_node_next(PurpleBlistNode *node, gboolean offline)
+{
+	PurpleBlistNode *ret = node;
+
+	if (offline)
+		return get_next_node(ret, TRUE);
+	do
+	{
+		ret = get_next_node(ret, TRUE);
+	} while (ret && PURPLE_BLIST_NODE_IS_BUDDY(ret) &&
+			!purple_account_is_connected(purple_buddy_get_account((PurpleBuddy *)ret)));
+
+	return ret;
+}
+
+PurpleBlistNode *purple_blist_node_get_parent(PurpleBlistNode *node)
+{
+	return node ? node->parent : NULL;
+}
+
+PurpleBlistNode *purple_blist_node_get_first_child(PurpleBlistNode *node)
+{
+	return node ? node->child : NULL;
+}
+
+PurpleBlistNode *purple_blist_node_get_sibling_next(PurpleBlistNode *node)
+{
+	return node? node->next : NULL;
+}
+
+PurpleBlistNode *purple_blist_node_get_sibling_prev(PurpleBlistNode *node)
+{
+	return node? node->prev : NULL;
+}
+
+void *
+purple_blist_node_get_ui_data(const PurpleBlistNode *node)
+{
+	g_return_val_if_fail(node, NULL);
+
+	return node->ui_data;
+}
+
+void
+purple_blist_node_set_ui_data(PurpleBlistNode *node, void *ui_data) {
+	g_return_if_fail(node);
+
+	node->ui_data = ui_data;
+}
+
+void
+purple_blist_update_buddy_status(PurpleBuddy *buddy, PurpleStatus *old_status)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurplePresence *presence;
+	PurpleStatus *status;
+	PurpleBlistNode *cnode;
+
+	g_return_if_fail(buddy != NULL);
+
+	presence = purple_buddy_get_presence(buddy);
+	status = purple_presence_get_active_status(presence);
+
+	purple_debug_info("blist", "Updating buddy status for %s (%s)\n",
+			buddy->name, purple_account_get_protocol_name(buddy->account));
+
+	if (purple_status_is_online(status) &&
+		!purple_status_is_online(old_status)) {
+
+		purple_signal_emit(purple_blist_get_handle(), "buddy-signed-on", buddy);
+
+		cnode = buddy->node.parent;
+		if (++(PURPLE_CONTACT(cnode)->online) == 1)
+			PURPLE_GROUP(cnode->parent)->online++;
+	} else if (!purple_status_is_online(status) &&
+				purple_status_is_online(old_status)) {
+
+		purple_blist_node_set_int(&buddy->node, "last_seen", time(NULL));
+		purple_signal_emit(purple_blist_get_handle(), "buddy-signed-off", buddy);
+
+		cnode = buddy->node.parent;
+		if (--(PURPLE_CONTACT(cnode)->online) == 0)
+			PURPLE_GROUP(cnode->parent)->online--;
+	} else {
+		purple_signal_emit(purple_blist_get_handle(),
+		                 "buddy-status-changed", buddy, old_status,
+		                 status);
+	}
+
+	/*
+	 * This function used to only call the following two functions if one of
+	 * the above signals had been triggered, but that's not good, because
+	 * if someone's away message changes and they don't go from away to back
+	 * to away then no signal is triggered.
+	 *
+	 * It's a safe assumption that SOMETHING called this function.  PROBABLY
+	 * because something, somewhere changed.  Calling the stuff below
+	 * certainly won't hurt anything.  Unless you're on a K6-2 300.
+	 */
+	purple_contact_invalidate_priority_buddy(purple_buddy_get_contact(buddy));
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode *)buddy);
+}
+
+void
+purple_blist_update_node_icon(PurpleBlistNode *node)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+
+	g_return_if_fail(node != NULL);
+
+	if (ops && ops->update)
+		ops->update(purplebuddylist, node);
+}
+
+void
+purple_blist_update_buddy_icon(PurpleBuddy *buddy)
+{
+	purple_blist_update_node_icon((PurpleBlistNode *)buddy);
+}
+
+/*
+ * TODO: Maybe remove the call to this from server.c and call it
+ * from oscar.c and toc.c instead?
+ */
+void purple_blist_rename_buddy(PurpleBuddy *buddy, const char *name)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	struct _purple_hbuddy *hb, *hb2;
+	GHashTable *account_buddies;
+
+	g_return_if_fail(buddy != NULL);
+
+	hb = g_new(struct _purple_hbuddy, 1);
+	hb->name = (gchar *)purple_normalize(buddy->account, buddy->name);
+	hb->account = buddy->account;
+	hb->group = ((PurpleBlistNode *)buddy)->parent->parent;
+	g_hash_table_remove(purplebuddylist->buddies, hb);
+
+	account_buddies = g_hash_table_lookup(buddies_cache, buddy->account);
+	g_hash_table_remove(account_buddies, hb);
+
+	hb->name = g_strdup(purple_normalize(buddy->account, name));
+	g_hash_table_replace(purplebuddylist->buddies, hb, buddy);
+
+	hb2 = g_new(struct _purple_hbuddy, 1);
+	hb2->name = g_strdup(hb->name);
+	hb2->account = buddy->account;
+	hb2->group = ((PurpleBlistNode *)buddy)->parent->parent;
+
+	g_hash_table_replace(account_buddies, hb2, buddy);
+
+	g_free(buddy->name);
+	buddy->name = g_strdup(name);
+
+	if (ops && ops->save_node)
+		ops->save_node((PurpleBlistNode *) buddy);
+
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode *)buddy);
+}
+
+static gboolean
+purple_strings_are_different(const char *one, const char *two)
+{
+	return !((one && two && g_utf8_collate(one, two) == 0) ||
+			((one == NULL || *one == '\0') && (two == NULL || *two == '\0')));
+}
+
+void purple_blist_alias_contact(PurpleContact *contact, const char *alias)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleConversation *conv;
+	PurpleBlistNode *bnode;
+	char *old_alias;
+	char *new_alias = NULL;
+
+	g_return_if_fail(contact != NULL);
+
+	if ((alias != NULL) && (*alias != '\0'))
+		new_alias = purple_utf8_strip_unprintables(alias);
+
+	if (!purple_strings_are_different(contact->alias, new_alias)) {
+		g_free(new_alias);
+		return;
+	}
+
+	old_alias = contact->alias;
+
+	if ((new_alias != NULL) && (*new_alias != '\0'))
+		contact->alias = new_alias;
+	else {
+		contact->alias = NULL;
+		g_free(new_alias); /* could be "\0" */
+	}
+
+	if (ops && ops->save_node)
+		ops->save_node((PurpleBlistNode*) contact);
+
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode *)contact);
+
+	for(bnode = ((PurpleBlistNode *)contact)->child; bnode != NULL; bnode = bnode->next)
+	{
+		PurpleBuddy *buddy = (PurpleBuddy *)bnode;
+
+		conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name,
+												   buddy->account);
+		if (conv)
+			purple_conversation_autoset_title(conv);
+	}
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-aliased",
+					 contact, old_alias);
+//	g_free(old_alias);
+}
+
+void purple_blist_alias_chat(PurpleChat *chat, const char *alias)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	char *old_alias;
+	char *new_alias = NULL;
+
+	g_return_if_fail(chat != NULL);
+
+	if ((alias != NULL) && (*alias != '\0'))
+		new_alias = purple_utf8_strip_unprintables(alias);
+
+	if (!purple_strings_are_different(chat->alias, new_alias)) {
+		g_free(new_alias);
+		return;
+	}
+
+	old_alias = chat->alias;
+
+	if ((new_alias != NULL) && (*new_alias != '\0'))
+		chat->alias = new_alias;
+	else {
+		chat->alias = NULL;
+		g_free(new_alias); /* could be "\0" */
+	}
+
+	if (ops && ops->save_node)
+		ops->save_node((PurpleBlistNode*) chat);
+
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode *)chat);
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-aliased",
+					 chat, old_alias);
+	g_free(old_alias);
+}
+
+void purple_blist_alias_buddy(PurpleBuddy *buddy, const char *alias)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleConversation *conv;
+	char *old_alias;
+	char *new_alias = NULL;
+
+	g_return_if_fail(buddy != NULL);
+
+	if ((alias != NULL) && (*alias != '\0'))
+		new_alias = purple_utf8_strip_unprintables(alias);
+
+	if (!purple_strings_are_different(buddy->alias, new_alias)) {
+		g_free(new_alias);
+		return;
+	}
+
+	old_alias = buddy->alias;
+
+	if ((new_alias != NULL) && (*new_alias != '\0'))
+		buddy->alias = new_alias;
+	else {
+		buddy->alias = NULL;
+		g_free(new_alias); /* could be "\0" */
+	}
+
+	if (ops && ops->save_node)
+		ops->save_node((PurpleBlistNode*) buddy);
+
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode *)buddy);
+
+	conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name,
+											   buddy->account);
+	if (conv)
+		purple_conversation_autoset_title(conv);
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-aliased",
+					 buddy, old_alias);
+//	g_free(old_alias);
+}
+
+void purple_blist_server_alias_buddy(PurpleBuddy *buddy, const char *alias)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleConversation *conv;
+	char *old_alias;
+	char *new_alias = NULL;
+
+	g_return_if_fail(buddy != NULL);
+
+	if ((alias != NULL) && (*alias != '\0') && g_utf8_validate(alias, -1, NULL))
+		new_alias = purple_utf8_strip_unprintables(alias);
+
+	if (!purple_strings_are_different(buddy->server_alias, new_alias)) {
+		g_free(new_alias);
+		return;
+	}
+
+	old_alias = buddy->server_alias;
+
+	if ((new_alias != NULL) && (*new_alias != '\0'))
+		buddy->server_alias = new_alias;
+	else {
+		buddy->server_alias = NULL;
+		g_free(new_alias); /* could be "\0"; */
+	}
+
+	if (ops && ops->save_node)
+		ops->save_node((PurpleBlistNode*) buddy);
+
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode *)buddy);
+
+	conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_IM, buddy->name,
+											   buddy->account);
+	if (conv)
+		purple_conversation_autoset_title(conv);
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-aliased",
+					 buddy, old_alias);
+//	g_free(old_alias);
+}
+
+/*
+ * TODO: If merging, prompt the user if they want to merge.
+ */
+void purple_blist_rename_group(PurpleGroup *source, const char *name)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleGroup *dest;
+	gchar *old_name;
+	gchar *new_name;
+	GList *moved_buddies = NULL;
+	GSList *accts;
+
+	g_return_if_fail(source != NULL);
+	g_return_if_fail(name != NULL);
+
+	new_name = purple_utf8_strip_unprintables(name);
+
+	if (*new_name == '\0' || purple_strequal(new_name, source->name)) {
+		g_free(new_name);
+		return;
+	}
+
+	dest = purple_find_group(new_name);
+	if (dest != NULL && purple_utf8_strcasecmp(source->name, dest->name) != 0) {
+		/* We're merging two groups */
+		PurpleBlistNode *prev, *child, *next;
+
+		prev = purple_blist_get_last_child((PurpleBlistNode*)dest);
+		child = ((PurpleBlistNode*)source)->child;
+
+		/*
+		 * TODO: This seems like a dumb way to do this... why not just
+		 * append all children from the old group to the end of the new
+		 * one?  PRPLs might be expecting to receive an add_buddy() for
+		 * each moved buddy...
+		 */
+		while (child)
+		{
+			next = child->next;
+			if (PURPLE_BLIST_NODE_IS_CONTACT(child)) {
+				PurpleBlistNode *bnode;
+				purple_blist_add_contact((PurpleContact *)child, dest, prev);
+				for (bnode = child->child; bnode != NULL; bnode = bnode->next) {
+					purple_blist_add_buddy((PurpleBuddy *)bnode, (PurpleContact *)child,
+							NULL, bnode->prev);
+					moved_buddies = g_list_append(moved_buddies, bnode);
+				}
+				prev = child;
+			} else if (PURPLE_BLIST_NODE_IS_CHAT(child)) {
+				purple_blist_add_chat((PurpleChat *)child, dest, prev);
+				prev = child;
+			} else {
+				purple_debug(PURPLE_DEBUG_ERROR, "blist",
+						"Unknown child type in group %s\n", source->name);
+			}
+			child = next;
+		}
+
+		/* Make a copy of the old group name and then delete the old group */
+		old_name = g_strdup(source->name);
+		purple_blist_remove_group(source);
+		source = dest;
+		g_free(new_name);
+	} else {
+		/* A simple rename */
+		PurpleBlistNode *cnode, *bnode;
+		gchar* key;
+
+		/* Build a GList of all buddies in this group */
+		for (cnode = ((PurpleBlistNode *)source)->child; cnode != NULL; cnode = cnode->next) {
+			if (PURPLE_BLIST_NODE_IS_CONTACT(cnode))
+				for (bnode = cnode->child; bnode != NULL; bnode = bnode->next)
+					moved_buddies = g_list_append(moved_buddies, bnode);
+		}
+
+		old_name = source->name;
+		source->name = new_name;
+
+		key = g_utf8_collate_key(old_name, -1);
+		g_hash_table_remove(groups_cache, key);
+		g_free(key);
+
+		key = g_utf8_collate_key(new_name, -1);
+		g_hash_table_insert(groups_cache, key, source);
+	}
+
+	/* Save our changes */
+	if (ops && ops->save_node)
+		ops->save_node((PurpleBlistNode*) source);
+
+	/* Update the UI */
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode*)source);
+
+	/* Notify all PRPLs */
+	/* TODO: Is this condition needed?  Seems like it would always be TRUE */
+	if(old_name && !purple_strequal(source->name, old_name)) {
+		for (accts = purple_group_get_accounts(source); accts; accts = g_slist_remove(accts, accts->data)) {
+			PurpleAccount *account = accts->data;
+			PurpleConnection *gc = NULL;
+			PurplePlugin *prpl = NULL;
+			PurplePluginProtocolInfo *prpl_info = NULL;
+			GList *l = NULL, *buddies = NULL;
+
+			gc = purple_account_get_connection(account);
+
+			if(gc)
+				prpl = purple_connection_get_prpl(gc);
+
+			if(gc && prpl)
+				prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+			if(!prpl_info)
+				continue;
+
+			for(l = moved_buddies; l; l = l->next) {
+				PurpleBuddy *buddy = (PurpleBuddy *)l->data;
+
+				if(buddy && buddy->account == account)
+					buddies = g_list_append(buddies, (PurpleBlistNode *)buddy);
+			}
+
+			if(prpl_info->rename_group) {
+				prpl_info->rename_group(gc, old_name, source, buddies);
+			} else {
+				GList *cur, *groups = NULL;
+
+				/* Make a list of what the groups each buddy is in */
+				for(cur = buddies; cur; cur = cur->next) {
+					PurpleBlistNode *node = (PurpleBlistNode *)cur->data;
+					groups = g_list_prepend(groups, node->parent->parent);
+				}
+
+				purple_account_remove_buddies(account, buddies, groups);
+				g_list_free(groups);
+				purple_account_add_buddies(account, buddies);
+			}
+
+			g_list_free(buddies);
+		}
+	}
+	g_list_free(moved_buddies);
+	g_free(old_name);
+}
+
+static void purple_blist_node_initialize_settings(PurpleBlistNode *node);
+
+PurpleChat *purple_chat_new(PurpleAccount *account, const char *alias, GHashTable *components)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleChat *chat;
+
+	g_return_val_if_fail(account != NULL, NULL);
+	g_return_val_if_fail(components != NULL, NULL);
+
+	chat = g_new0(PurpleChat, 1);
+	chat->account = account;
+	if ((alias != NULL) && (*alias != '\0'))
+		chat->alias = purple_utf8_strip_unprintables(alias);
+	chat->components = components;
+	purple_blist_node_initialize_settings((PurpleBlistNode *)chat);
+	((PurpleBlistNode *)chat)->type = PURPLE_BLIST_CHAT_NODE;
+
+	if (ops != NULL && ops->new_node != NULL)
+		ops->new_node((PurpleBlistNode *)chat);
+
+	PURPLE_DBUS_REGISTER_POINTER(chat, PurpleChat);
+	return chat;
+}
+
+void
+purple_chat_destroy(PurpleChat *chat)
+{
+	g_hash_table_destroy(chat->components);
+	g_hash_table_destroy(chat->node.settings);
+	g_free(chat->alias);
+	PURPLE_DBUS_UNREGISTER_POINTER(chat);
+	g_free(chat);
+}
+
+PurpleBuddy *purple_buddy_new(PurpleAccount *account, const char *name, const char *alias)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleBuddy *buddy;
+
+	g_return_val_if_fail(account != NULL, NULL);
+	g_return_val_if_fail(name != NULL, NULL);
+
+	buddy = g_new0(PurpleBuddy, 1);
+	buddy->account  = account;
+	buddy->name     = purple_utf8_strip_unprintables(name);
+	buddy->alias    = purple_utf8_strip_unprintables(alias);
+	buddy->presence = purple_presence_new_for_buddy(buddy);
+	((PurpleBlistNode *)buddy)->type = PURPLE_BLIST_BUDDY_NODE;
+
+	purple_presence_set_status_active(buddy->presence, "offline", TRUE);
+
+	purple_blist_node_initialize_settings((PurpleBlistNode *)buddy);
+
+	if (ops && ops->new_node)
+		ops->new_node((PurpleBlistNode *)buddy);
+
+	PURPLE_DBUS_REGISTER_POINTER(buddy, PurpleBuddy);
+	return buddy;
+}
+
+void
+purple_buddy_destroy(PurpleBuddy *buddy)
+{
+	PurplePlugin *prpl;
+	PurplePluginProtocolInfo *prpl_info;
+
+	/*
+	 * Tell the owner PRPL that we're about to free the buddy so it
+	 * can free proto_data
+	 */
+	prpl = purple_find_prpl(purple_account_get_protocol_id(buddy->account));
+	if (prpl) {
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+		if (prpl_info && prpl_info->buddy_free)
+			prpl_info->buddy_free(buddy);
+	}
+
+	/* Delete the node */
+	purple_buddy_icon_unref(buddy->icon);
+	g_hash_table_destroy(buddy->node.settings);
+	purple_presence_destroy(buddy->presence);
+	g_free(buddy->name);
+	g_free(buddy->alias);
+	g_free(buddy->server_alias);
+
+	PURPLE_DBUS_UNREGISTER_POINTER(buddy);
+	g_free(buddy);
+
+	/* FIXME: Once PurpleBuddy is a GObject, timeout callbacks can
+	 * g_object_ref() it when connecting the callback and
+	 * g_object_unref() it in the handler.  That way, it won't
+	 * get freed while the timeout is pending and this line can
+	 * be removed. */
+	while (g_source_remove_by_user_data((gpointer *)buddy));
+}
+
+void
+purple_buddy_set_icon(PurpleBuddy *buddy, PurpleBuddyIcon *icon)
+{
+	g_return_if_fail(buddy != NULL);
+
+	if (buddy->icon != icon)
+	{
+		purple_buddy_icon_unref(buddy->icon);
+		buddy->icon = (icon != NULL ? purple_buddy_icon_ref(icon) : NULL);
+	}
+
+	purple_signal_emit(purple_blist_get_handle(), "buddy-icon-changed", buddy);
+
+	purple_blist_update_node_icon((PurpleBlistNode*)buddy);
+}
+
+PurpleAccount *
+purple_buddy_get_account(const PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	return buddy->account;
+}
+
+const char *
+purple_buddy_get_name(const PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	return buddy->name;
+}
+
+PurpleBuddyIcon *
+purple_buddy_get_icon(const PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	return buddy->icon;
+}
+
+gpointer
+purple_buddy_get_protocol_data(const PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	return buddy->proto_data;
+}
+
+void
+purple_buddy_set_protocol_data(PurpleBuddy *buddy, gpointer data)
+{
+	g_return_if_fail(buddy != NULL);
+
+	buddy->proto_data = data;
+}
+
+
+void purple_blist_add_chat(PurpleChat *chat, PurpleGroup *group, PurpleBlistNode *node)
+{
+	PurpleBlistNode *cnode = (PurpleBlistNode*)chat;
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+
+	g_return_if_fail(chat != NULL);
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_CHAT((PurpleBlistNode *)chat));
+
+	if (node == NULL) {
+		if (group == NULL)
+			group = purple_group_new(_("Chats"));
+
+		/* Add group to blist if isn't already on it. Fixes #2752. */
+		if (!purple_find_group(group->name)) {
+			purple_blist_add_group(group,
+					purple_blist_get_last_sibling(purplebuddylist->root));
+		}
+	} else {
+		group = (PurpleGroup*)node->parent;
+	}
+
+	/* if we're moving to overtop of ourselves, do nothing */
+	if (cnode == node)
+		return;
+
+	if (cnode->parent) {
+		/* This chat was already in the list and is
+		 * being moved.
+		 */
+		((PurpleGroup *)cnode->parent)->totalsize--;
+		if (purple_account_is_connected(chat->account)) {
+			((PurpleGroup *)cnode->parent)->online--;
+			((PurpleGroup *)cnode->parent)->currentsize--;
+		}
+		if (cnode->next)
+			cnode->next->prev = cnode->prev;
+		if (cnode->prev)
+			cnode->prev->next = cnode->next;
+		if (cnode->parent->child == cnode)
+			cnode->parent->child = cnode->next;
+
+		if (ops && ops->remove)
+			ops->remove(purplebuddylist, cnode);
+		/* ops->remove() cleaned up the cnode's ui_data, so we need to
+		 * reinitialize it */
+		if (ops && ops->new_node)
+			ops->new_node(cnode);
+	}
+
+	if (node != NULL) {
+		if (node->next)
+			node->next->prev = cnode;
+		cnode->next = node->next;
+		cnode->prev = node;
+		cnode->parent = node->parent;
+		node->next = cnode;
+		((PurpleGroup *)node->parent)->totalsize++;
+		if (purple_account_is_connected(chat->account)) {
+			((PurpleGroup *)node->parent)->online++;
+			((PurpleGroup *)node->parent)->currentsize++;
+		}
+	} else {
+		if (((PurpleBlistNode *)group)->child)
+			((PurpleBlistNode *)group)->child->prev = cnode;
+		cnode->next = ((PurpleBlistNode *)group)->child;
+		cnode->prev = NULL;
+		((PurpleBlistNode *)group)->child = cnode;
+		cnode->parent = (PurpleBlistNode *)group;
+		group->totalsize++;
+		if (purple_account_is_connected(chat->account)) {
+			group->online++;
+			group->currentsize++;
+		}
+	}
+
+	if (ops && ops->save_node)
+		ops->save_node(cnode);
+
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode *)cnode);
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-added",
+			cnode);
+}
+
+void purple_blist_add_buddy(PurpleBuddy *buddy, PurpleContact *contact, PurpleGroup *group, PurpleBlistNode *node)
+{
+	PurpleBlistNode *cnode, *bnode;
+	PurpleGroup *g;
+	PurpleContact *c;
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	struct _purple_hbuddy *hb, *hb2;
+	GHashTable *account_buddies;
+
+	g_return_if_fail(buddy != NULL);
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_BUDDY((PurpleBlistNode*)buddy));
+
+	bnode = (PurpleBlistNode *)buddy;
+
+	/* if we're moving to overtop of ourselves, do nothing */
+	if (bnode == node || (!node && bnode->parent &&
+				contact && bnode->parent == (PurpleBlistNode*)contact
+				&& bnode == bnode->parent->child))
+		return;
+
+	if (node && PURPLE_BLIST_NODE_IS_BUDDY(node)) {
+		c = (PurpleContact*)node->parent;
+		g = (PurpleGroup*)node->parent->parent;
+	} else if (contact) {
+		c = contact;
+		g = PURPLE_GROUP(PURPLE_BLIST_NODE(c)->parent);
+	} else {
+		g = group;
+		if (g == NULL)
+			g = purple_group_new(_("Buddies"));
+		/* Add group to blist if isn't already on it. Fixes #2752. */
+		if (!purple_find_group(g->name)) {
+			purple_blist_add_group(g,
+					purple_blist_get_last_sibling(purplebuddylist->root));
+		}
+		c = purple_contact_new();
+		purple_blist_add_contact(c, g,
+				purple_blist_get_last_child((PurpleBlistNode*)g));
+	}
+
+	cnode = (PurpleBlistNode *)c;
+
+	if (bnode->parent) {
+		if (PURPLE_BUDDY_IS_ONLINE(buddy)) {
+			((PurpleContact*)bnode->parent)->online--;
+			if (((PurpleContact*)bnode->parent)->online == 0)
+				((PurpleGroup*)bnode->parent->parent)->online--;
+		}
+		if (purple_account_is_connected(buddy->account)) {
+			((PurpleContact*)bnode->parent)->currentsize--;
+			if (((PurpleContact*)bnode->parent)->currentsize == 0)
+				((PurpleGroup*)bnode->parent->parent)->currentsize--;
+		}
+		((PurpleContact*)bnode->parent)->totalsize--;
+		/* the group totalsize will be taken care of by remove_contact below */
+
+		if (bnode->parent->parent != (PurpleBlistNode*)g)
+			serv_move_buddy(buddy, (PurpleGroup *)bnode->parent->parent, g);
+
+		if (bnode->next)
+			bnode->next->prev = bnode->prev;
+		if (bnode->prev)
+			bnode->prev->next = bnode->next;
+		if (bnode->parent->child == bnode)
+			bnode->parent->child = bnode->next;
+
+		if (ops && ops->remove)
+			ops->remove(purplebuddylist, bnode);
+
+		if (bnode->parent->parent != (PurpleBlistNode*)g) {
+			struct _purple_hbuddy hb;
+			hb.name = (gchar *)purple_normalize(buddy->account, buddy->name);
+			hb.account = buddy->account;
+			hb.group = bnode->parent->parent;
+			g_hash_table_remove(purplebuddylist->buddies, &hb);
+
+			account_buddies = g_hash_table_lookup(buddies_cache, buddy->account);
+			g_hash_table_remove(account_buddies, &hb);
+		}
+
+		if (!bnode->parent->child) {
+			purple_blist_remove_contact((PurpleContact*)bnode->parent);
+		} else {
+			purple_contact_invalidate_priority_buddy((PurpleContact*)bnode->parent);
+			if (ops && ops->update)
+				ops->update(purplebuddylist, bnode->parent);
+		}
+	}
+
+	if (node && PURPLE_BLIST_NODE_IS_BUDDY(node)) {
+		if (node->next)
+			node->next->prev = bnode;
+		bnode->next = node->next;
+		bnode->prev = node;
+		bnode->parent = node->parent;
+		node->next = bnode;
+	} else {
+		if (cnode->child)
+			cnode->child->prev = bnode;
+		bnode->prev = NULL;
+		bnode->next = cnode->child;
+		cnode->child = bnode;
+		bnode->parent = cnode;
+	}
+
+	if (PURPLE_BUDDY_IS_ONLINE(buddy)) {
+		if (++(PURPLE_CONTACT(bnode->parent)->online) == 1)
+			PURPLE_GROUP(bnode->parent->parent)->online++;
+	}
+	if (purple_account_is_connected(buddy->account)) {
+		if (++(PURPLE_CONTACT(bnode->parent)->currentsize) == 1)
+			PURPLE_GROUP(bnode->parent->parent)->currentsize++;
+	}
+	PURPLE_CONTACT(bnode->parent)->totalsize++;
+
+	hb = g_new(struct _purple_hbuddy, 1);
+	hb->name = g_strdup(purple_normalize(buddy->account, buddy->name));
+	hb->account = buddy->account;
+	hb->group = ((PurpleBlistNode*)buddy)->parent->parent;
+
+	g_hash_table_replace(purplebuddylist->buddies, hb, buddy);
+
+	account_buddies = g_hash_table_lookup(buddies_cache, buddy->account);
+
+	hb2 = g_new(struct _purple_hbuddy, 1);
+	hb2->name = g_strdup(hb->name);
+	hb2->account = buddy->account;
+	hb2->group = ((PurpleBlistNode*)buddy)->parent->parent;
+
+	g_hash_table_replace(account_buddies, hb2, buddy);
+
+	purple_contact_invalidate_priority_buddy(purple_buddy_get_contact(buddy));
+
+	if (ops && ops->save_node)
+		ops->save_node((PurpleBlistNode*) buddy);
+
+	if (ops && ops->update)
+		ops->update(purplebuddylist, (PurpleBlistNode*)buddy);
+
+	/* Signal that the buddy has been added */
+	purple_signal_emit(purple_blist_get_handle(), "buddy-added", buddy);
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-added",
+			PURPLE_BLIST_NODE(buddy));
+}
+
+PurpleContact *purple_contact_new()
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+
+	PurpleContact *contact = g_new0(PurpleContact, 1);
+	contact->totalsize = 0;
+	contact->currentsize = 0;
+	contact->online = 0;
+	purple_blist_node_initialize_settings((PurpleBlistNode *)contact);
+	((PurpleBlistNode *)contact)->type = PURPLE_BLIST_CONTACT_NODE;
+
+	if (ops && ops->new_node)
+		ops->new_node((PurpleBlistNode *)contact);
+
+	PURPLE_DBUS_REGISTER_POINTER(contact, PurpleContact);
+	return contact;
+}
+
+void
+purple_contact_destroy(PurpleContact *contact)
+{
+	g_hash_table_destroy(contact->node.settings);
+	g_free(contact->alias);
+	PURPLE_DBUS_UNREGISTER_POINTER(contact);
+	g_free(contact);
+}
+
+PurpleGroup *
+purple_contact_get_group(const PurpleContact *contact)
+{
+	g_return_val_if_fail(contact, NULL);
+
+	return (PurpleGroup *)(((PurpleBlistNode *)contact)->parent);
+}
+
+void purple_contact_set_alias(PurpleContact *contact, const char *alias)
+{
+	purple_blist_alias_contact(contact,alias);
+}
+
+const char *purple_contact_get_alias(PurpleContact* contact)
+{
+	g_return_val_if_fail(contact != NULL, NULL);
+
+	if (contact->alias)
+		return contact->alias;
+
+	return purple_buddy_get_alias(purple_contact_get_priority_buddy(contact));
+}
+
+gboolean purple_contact_on_account(PurpleContact *c, PurpleAccount *account)
+{
+	PurpleBlistNode *bnode, *cnode = (PurpleBlistNode *) c;
+
+	g_return_val_if_fail(c != NULL, FALSE);
+	g_return_val_if_fail(account != NULL, FALSE);
+
+	for (bnode = cnode->child; bnode; bnode = bnode->next) {
+		PurpleBuddy *buddy;
+
+		if (! PURPLE_BLIST_NODE_IS_BUDDY(bnode))
+			continue;
+
+		buddy = (PurpleBuddy *)bnode;
+		if (buddy->account == account)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+void purple_contact_invalidate_priority_buddy(PurpleContact *contact)
+{
+	g_return_if_fail(contact != NULL);
+
+	contact->priority_valid = FALSE;
+}
+
+PurpleGroup *purple_group_new(const char *name)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleGroup *group;
+
+	g_return_val_if_fail(name  != NULL, NULL);
+	g_return_val_if_fail(*name != '\0', NULL);
+
+	group = purple_find_group(name);
+	if (group != NULL)
+		return group;
+
+	group = g_new0(PurpleGroup, 1);
+	group->name = purple_utf8_strip_unprintables(name);
+	group->totalsize = 0;
+	group->currentsize = 0;
+	group->online = 0;
+	purple_blist_node_initialize_settings((PurpleBlistNode *)group);
+	((PurpleBlistNode *)group)->type = PURPLE_BLIST_GROUP_NODE;
+
+	if (ops && ops->new_node)
+		ops->new_node((PurpleBlistNode *)group);
+
+	PURPLE_DBUS_REGISTER_POINTER(group, PurpleGroup);
+	return group;
+}
+
+void
+purple_group_destroy(PurpleGroup *group)
+{
+	g_hash_table_destroy(group->node.settings);
+	g_free(group->name);
+	PURPLE_DBUS_UNREGISTER_POINTER(group);
+	g_free(group);
+}
+
+void purple_blist_add_contact(PurpleContact *contact, PurpleGroup *group, PurpleBlistNode *node)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleGroup *g;
+	PurpleBlistNode *gnode, *cnode, *bnode;
+
+	g_return_if_fail(contact != NULL);
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_CONTACT((PurpleBlistNode*)contact));
+
+	if (PURPLE_BLIST_NODE(contact) == node)
+		return;
+
+	if (node && (PURPLE_BLIST_NODE_IS_CONTACT(node) ||
+				PURPLE_BLIST_NODE_IS_CHAT(node)))
+		g = (PurpleGroup*)node->parent;
+	else if (group)
+		g = group;
+	else {
+		g = purple_find_group(_("Buddies"));
+		if (g == NULL) {
+			g = purple_group_new(_("Buddies"));
+			purple_blist_add_group(g,
+					purple_blist_get_last_sibling(purplebuddylist->root));
+		}
+	}
+
+	gnode = (PurpleBlistNode*)g;
+	cnode = (PurpleBlistNode*)contact;
+
+	if (cnode->parent) {
+		if (cnode->parent->child == cnode)
+			cnode->parent->child = cnode->next;
+		if (cnode->prev)
+			cnode->prev->next = cnode->next;
+		if (cnode->next)
+			cnode->next->prev = cnode->prev;
+
+		if (cnode->parent != gnode) {
+			bnode = cnode->child;
+			while (bnode) {
+				PurpleBlistNode *next_bnode = bnode->next;
+				PurpleBuddy *b = (PurpleBuddy*)bnode;
+				GHashTable *account_buddies;
+
+				struct _purple_hbuddy *hb, *hb2;
+
+				hb = g_new(struct _purple_hbuddy, 1);
+				hb->name = g_strdup(purple_normalize(b->account, b->name));
+				hb->account = b->account;
+				hb->group = cnode->parent;
+
+				g_hash_table_remove(purplebuddylist->buddies, hb);
+
+				account_buddies = g_hash_table_lookup(buddies_cache, b->account);
+				g_hash_table_remove(account_buddies, hb);
+
+				if (!purple_find_buddy_in_group(b->account, b->name, g)) {
+					hb->group = gnode;
+					g_hash_table_replace(purplebuddylist->buddies, hb, b);
+
+					hb2 = g_new(struct _purple_hbuddy, 1);
+					hb2->name = g_strdup(hb->name);
+					hb2->account = b->account;
+					hb2->group = gnode;
+
+					g_hash_table_replace(account_buddies, hb2, b);
+
+					if (purple_account_get_connection(b->account))
+						serv_move_buddy(b, (PurpleGroup *)cnode->parent, g);
+				} else {
+					gboolean empty_contact = FALSE;
+
+					/* this buddy already exists in the group, so we're
+					 * gonna delete it instead */
+					g_free(hb->name);
+					g_free(hb);
+					if (purple_account_get_connection(b->account))
+						purple_account_remove_buddy(b->account, b, (PurpleGroup *)cnode->parent);
+
+					if (!cnode->child->next)
+						empty_contact = TRUE;
+					purple_blist_remove_buddy(b);
+
+					/** in purple_blist_remove_buddy(), if the last buddy in a
+					 * contact is removed, the contact is cleaned up and
+					 * g_free'd, so we mustn't try to reference bnode->next */
+					if (empty_contact)
+						return;
+				}
+				bnode = next_bnode;
+			}
+		}
+
+		if (contact->online > 0)
+			((PurpleGroup*)cnode->parent)->online--;
+		if (contact->currentsize > 0)
+			((PurpleGroup*)cnode->parent)->currentsize--;
+		((PurpleGroup*)cnode->parent)->totalsize--;
+
+		if (ops && ops->remove)
+			ops->remove(purplebuddylist, cnode);
+
+		if (ops && ops->remove_node)
+			ops->remove_node(cnode);
+	}
+
+	if (node && (PURPLE_BLIST_NODE_IS_CONTACT(node) ||
+				PURPLE_BLIST_NODE_IS_CHAT(node))) {
+		if (node->next)
+			node->next->prev = cnode;
+		cnode->next = node->next;
+		cnode->prev = node;
+		cnode->parent = node->parent;
+		node->next = cnode;
+	} else {
+		if (gnode->child)
+			gnode->child->prev = cnode;
+		cnode->prev = NULL;
+		cnode->next = gnode->child;
+		gnode->child = cnode;
+		cnode->parent = gnode;
+	}
+
+	if (contact->online > 0)
+		g->online++;
+	if (contact->currentsize > 0)
+		g->currentsize++;
+	g->totalsize++;
+
+	if (ops && ops->save_node)
+	{
+		if (cnode->child)
+			ops->save_node(cnode);
+		for (bnode = cnode->child; bnode; bnode = bnode->next)
+			ops->save_node(bnode);
+	}
+
+	if (ops && ops->update)
+	{
+		if (cnode->child)
+			ops->update(purplebuddylist, cnode);
+
+		for (bnode = cnode->child; bnode; bnode = bnode->next)
+			ops->update(purplebuddylist, bnode);
+	}
+}
+
+void purple_blist_merge_contact(PurpleContact *source, PurpleBlistNode *node)
+{
+	PurpleBlistNode *sourcenode = (PurpleBlistNode*)source;
+	PurpleBlistNode *prev, *cur, *next;
+	PurpleContact *target;
+
+	g_return_if_fail(source != NULL);
+	g_return_if_fail(node != NULL);
+
+	if (PURPLE_BLIST_NODE_IS_CONTACT(node)) {
+		target = (PurpleContact *)node;
+		prev = purple_blist_get_last_child(node);
+	} else if (PURPLE_BLIST_NODE_IS_BUDDY(node)) {
+		target = (PurpleContact *)node->parent;
+		prev = node;
+	} else {
+		return;
+	}
+
+	if (source == target || !target)
+		return;
+
+	next = sourcenode->child;
+
+	while (next) {
+		cur = next;
+		next = cur->next;
+		if (PURPLE_BLIST_NODE_IS_BUDDY(cur)) {
+			purple_blist_add_buddy((PurpleBuddy *)cur, target, NULL, prev);
+			prev = cur;
+		}
+	}
+}
+
+void purple_blist_add_group(PurpleGroup *group, PurpleBlistNode *node)
+{
+	PurpleBlistUiOps *ops;
+	PurpleBlistNode *gnode = (PurpleBlistNode*)group;
+	gchar* key;
+
+	g_return_if_fail(group != NULL);
+	g_return_if_fail(PURPLE_BLIST_NODE_IS_GROUP((PurpleBlistNode *)group));
+
+	ops = purple_blist_get_ui_ops();
+
+	/* if we're moving to overtop of ourselves, do nothing */
+	if (gnode == node) {
+		if (!purplebuddylist->root)
+			node = NULL;
+		else
+			return;
+	}
+
+	if (purple_find_group(group->name)) {
+		/* This is just being moved */
+
+		if (ops && ops->remove)
+			ops->remove(purplebuddylist, (PurpleBlistNode *)group);
+
+		if (gnode == purplebuddylist->root)
+			purplebuddylist->root = gnode->next;
+		if (gnode->prev)
+			gnode->prev->next = gnode->next;
+		if (gnode->next)
+			gnode->next->prev = gnode->prev;
+	} else {
+		key = g_utf8_collate_key(group->name, -1);
+		g_hash_table_insert(groups_cache, key, group);
+	}
+
+	if (node && PURPLE_BLIST_NODE_IS_GROUP(node)) {
+		gnode->next = node->next;
+		gnode->prev = node;
+		if (node->next)
+			node->next->prev = gnode;
+		node->next = gnode;
+	} else {
+		if (purplebuddylist->root)
+			purplebuddylist->root->prev = gnode;
+		gnode->next = purplebuddylist->root;
+		gnode->prev = NULL;
+		purplebuddylist->root = gnode;
+	}
+
+	if (ops && ops->save_node) {
+		ops->save_node(gnode);
+		for (node = gnode->child; node; node = node->next)
+			ops->save_node(node);
+	}
+
+	if (ops && ops->update) {
+		ops->update(purplebuddylist, gnode);
+		for (node = gnode->child; node; node = node->next)
+			ops->update(purplebuddylist, node);
+	}
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-added",
+			gnode);
+}
+
+void purple_blist_remove_contact(PurpleContact *contact)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleBlistNode *node, *gnode;
+
+	g_return_if_fail(contact != NULL);
+
+	node = (PurpleBlistNode *)contact;
+	gnode = node->parent;
+
+	if (node->child) {
+		/*
+		 * If this contact has children then remove them.  When the last
+		 * buddy is removed from the contact, the contact is automatically
+		 * deleted.
+		 */
+		while (node->child->next) {
+			purple_blist_remove_buddy((PurpleBuddy*)node->child);
+		}
+		/*
+		 * Remove the last buddy and trigger the deletion of the contact.
+		 * It would probably be cleaner if contact-deletion was done after
+		 * a timeout?  Or if it had to be done manually, like below?
+		 */
+		purple_blist_remove_buddy((PurpleBuddy*)node->child);
+	} else {
+		/* Remove the node from its parent */
+		if (gnode->child == node)
+			gnode->child = node->next;
+		if (node->prev)
+			node->prev->next = node->next;
+		if (node->next)
+			node->next->prev = node->prev;
+
+		/* Update the UI */
+		if (ops && ops->remove)
+			ops->remove(purplebuddylist, node);
+
+		if (ops && ops->remove_node)
+			ops->remove_node(node);
+
+		purple_signal_emit(purple_blist_get_handle(), "blist-node-removed",
+				PURPLE_BLIST_NODE(contact));
+
+		/* Delete the node */
+		purple_contact_destroy(contact);
+	}
+}
+
+void purple_blist_remove_buddy(PurpleBuddy *buddy)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleBlistNode *node, *cnode, *gnode;
+	PurpleContact *contact;
+	PurpleGroup *group;
+	struct _purple_hbuddy hb;
+	GHashTable *account_buddies;
+
+	g_return_if_fail(buddy != NULL);
+
+	node = (PurpleBlistNode *)buddy;
+	cnode = node->parent;
+	gnode = (cnode != NULL) ? cnode->parent : NULL;
+	contact = (PurpleContact *)cnode;
+	group = (PurpleGroup *)gnode;
+
+	/* Remove the node from its parent */
+	if (node->prev)
+		node->prev->next = node->next;
+	if (node->next)
+		node->next->prev = node->prev;
+	if ((cnode != NULL) && (cnode->child == node))
+		cnode->child = node->next;
+
+	/* Adjust size counts */
+	if (contact != NULL) {
+		if (PURPLE_BUDDY_IS_ONLINE(buddy)) {
+			contact->online--;
+			if (contact->online == 0)
+				group->online--;
+		}
+		if (purple_account_is_connected(buddy->account)) {
+			contact->currentsize--;
+			if (contact->currentsize == 0)
+				group->currentsize--;
+		}
+		contact->totalsize--;
+
+		/* Re-sort the contact */
+		if (cnode->child && contact->priority == buddy) {
+			purple_contact_invalidate_priority_buddy(contact);
+			if (ops && ops->update)
+				ops->update(purplebuddylist, cnode);
+		}
+	}
+
+	/* Remove this buddy from the buddies hash table */
+	hb.name = (gchar *)purple_normalize(buddy->account, buddy->name);
+	hb.account = buddy->account;
+	hb.group = gnode;
+	g_hash_table_remove(purplebuddylist->buddies, &hb);
+
+	account_buddies = g_hash_table_lookup(buddies_cache, buddy->account);
+	g_hash_table_remove(account_buddies, &hb);
+
+	/* Update the UI */
+	if (ops && ops->remove)
+		ops->remove(purplebuddylist, node);
+
+	if (ops && ops->remove_node)
+		ops->remove_node(node);
+
+	/* Signal that the buddy has been removed before freeing the memory for it */
+	purple_signal_emit(purple_blist_get_handle(), "buddy-removed", buddy);
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-removed",
+			PURPLE_BLIST_NODE(buddy));
+
+	purple_buddy_destroy(buddy);
+
+	/* If the contact is empty then remove it */
+	if ((contact != NULL) && !cnode->child)
+		purple_blist_remove_contact(contact);
+}
+
+void purple_blist_remove_chat(PurpleChat *chat)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleBlistNode *node, *gnode;
+	PurpleGroup *group;
+
+	g_return_if_fail(chat != NULL);
+
+	node = (PurpleBlistNode *)chat;
+	gnode = node->parent;
+	group = (PurpleGroup *)gnode;
+
+	if (gnode != NULL)
+	{
+		/* Remove the node from its parent */
+		if (gnode->child == node)
+			gnode->child = node->next;
+		if (node->prev)
+			node->prev->next = node->next;
+		if (node->next)
+			node->next->prev = node->prev;
+
+		/* Adjust size counts */
+		if (purple_account_is_connected(chat->account)) {
+			group->online--;
+			group->currentsize--;
+		}
+		group->totalsize--;
+
+	}
+
+	/* Update the UI */
+	if (ops && ops->remove)
+		ops->remove(purplebuddylist, node);
+
+	if (ops && ops->remove_node)
+		ops->remove_node(node);
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-removed",
+			PURPLE_BLIST_NODE(chat));
+
+	/* Delete the node */
+	purple_chat_destroy(chat);
+}
+
+void purple_blist_remove_group(PurpleGroup *group)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleBlistNode *node;
+	GList *l;
+	gchar* key;
+
+	g_return_if_fail(group != NULL);
+
+	node = (PurpleBlistNode *)group;
+
+	/* Make sure the group is empty */
+	if (node->child)
+		return;
+
+	/* Remove the node from its parent */
+	if (purplebuddylist->root == node)
+		purplebuddylist->root = node->next;
+	if (node->prev)
+		node->prev->next = node->next;
+	if (node->next)
+		node->next->prev = node->prev;
+
+	key = g_utf8_collate_key(group->name, -1);
+	g_hash_table_remove(groups_cache, key);
+	g_free(key);
+
+	/* Update the UI */
+	if (ops && ops->remove)
+		ops->remove(purplebuddylist, node);
+
+	if (ops && ops->remove_node)
+		ops->remove_node(node);
+
+	purple_signal_emit(purple_blist_get_handle(), "blist-node-removed",
+			PURPLE_BLIST_NODE(group));
+
+	/* Remove the group from all accounts that are online */
+	for (l = purple_connections_get_all(); l != NULL; l = l->next)
+	{
+		PurpleConnection *gc = (PurpleConnection *)l->data;
+
+		if (purple_connection_get_state(gc) == PURPLE_CONNECTED)
+			purple_account_remove_group(purple_connection_get_account(gc), group);
+	}
+
+	/* Delete the node */
+	purple_group_destroy(group);
+}
+
+PurpleBuddy *purple_contact_get_priority_buddy(PurpleContact *contact)
+{
+	g_return_val_if_fail(contact != NULL, NULL);
+
+	if (!contact->priority_valid)
+		purple_contact_compute_priority_buddy(contact);
+
+	return contact->priority;
+}
+
+const char *purple_buddy_get_alias_only(PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	if ((buddy->alias != NULL) && (*buddy->alias != '\0')) {
+		return buddy->alias;
+	} else if ((buddy->server_alias != NULL) &&
+		   (*buddy->server_alias != '\0')) {
+
+		return buddy->server_alias;
+	}
+
+	return NULL;
+}
+
+
+const char *purple_buddy_get_contact_alias(PurpleBuddy *buddy)
+{
+	PurpleContact *c;
+
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	/* Search for an alias for the buddy. In order of precedence: */
+	/* The buddy alias */
+	if (buddy->alias != NULL)
+		return buddy->alias;
+
+	/* The contact alias */
+	c = purple_buddy_get_contact(buddy);
+	if ((c != NULL) && (c->alias != NULL))
+		return c->alias;
+
+	/* The server alias */
+	if ((buddy->server_alias) && (*buddy->server_alias))
+		return buddy->server_alias;
+
+	/* The buddy's user name (i.e. no alias) */
+	return buddy->name;
+}
+
+
+const char *purple_buddy_get_alias(PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	/* Search for an alias for the buddy. In order of precedence: */
+	/* The buddy alias */
+	if (buddy->alias != NULL)
+		return buddy->alias;
+
+	/* The server alias */
+	if ((buddy->server_alias) && (*buddy->server_alias))
+		return buddy->server_alias;
+
+	/* The buddy's user name (i.e. no alias) */
+	return buddy->name;
+}
+
+const char *purple_buddy_get_local_buddy_alias(PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy, NULL);
+	return buddy->alias;
+}
+
+const char *purple_buddy_get_server_alias(PurpleBuddy *buddy)
+{
+        g_return_val_if_fail(buddy != NULL, NULL);
+
+	if ((buddy->server_alias) && (*buddy->server_alias))
+	    return buddy->server_alias;
+
+	return NULL;
+}
+
+const char *purple_buddy_get_local_alias(PurpleBuddy *buddy)
+{
+	PurpleContact *c;
+
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	/* Search for an alias for the buddy. In order of precedence: */
+	/* The buddy alias */
+	if (buddy->alias != NULL)
+		return buddy->alias;
+
+	/* The contact alias */
+	c = purple_buddy_get_contact(buddy);
+	if ((c != NULL) && (c->alias != NULL))
+		return c->alias;
+
+	/* The buddy's user name (i.e. no alias) */
+	return buddy->name;
+}
+
+const char *purple_chat_get_name(PurpleChat *chat)
+{
+	char *ret = NULL;
+	PurplePlugin *prpl;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+
+	g_return_val_if_fail(chat != NULL, NULL);
+
+	if ((chat->alias != NULL) && (*chat->alias != '\0'))
+		return chat->alias;
+
+	prpl = purple_find_prpl(purple_account_get_protocol_id(chat->account));
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+	if (prpl_info->chat_info) {
+		struct proto_chat_entry *pce;
+		GList *parts = prpl_info->chat_info(purple_account_get_connection(chat->account));
+		pce = parts->data;
+		ret = g_hash_table_lookup(chat->components, pce->identifier);
+		g_list_foreach(parts, (GFunc)g_free, NULL);
+		g_list_free(parts);
+	}
+
+	return ret;
+}
+
+PurpleBuddy *purple_find_buddy(PurpleAccount *account, const char *name)
+{
+	PurpleBuddy *buddy;
+	struct _purple_hbuddy hb;
+	PurpleBlistNode *group;
+
+	g_return_val_if_fail(purplebuddylist != NULL, NULL);
+	g_return_val_if_fail(account != NULL, NULL);
+	g_return_val_if_fail((name != NULL) && (*name != '\0'), NULL);
+
+	hb.account = account;
+	hb.name = (gchar *)purple_normalize(account, name);
+
+	for (group = purplebuddylist->root; group; group = group->next) {
+		if (!group->child)
+			continue;
+
+		hb.group = group;
+		if ((buddy = g_hash_table_lookup(purplebuddylist->buddies, &hb))) {
+			return buddy;
+		}
+	}
+
+	return NULL;
+}
+
+PurpleBuddy *purple_find_buddy_in_group(PurpleAccount *account, const char *name,
+		PurpleGroup *group)
+{
+	struct _purple_hbuddy hb;
+
+	g_return_val_if_fail(purplebuddylist != NULL, NULL);
+	g_return_val_if_fail(account != NULL, NULL);
+	g_return_val_if_fail((name != NULL) && (*name != '\0'), NULL);
+
+	hb.name = (gchar *)purple_normalize(account, name);
+	hb.account = account;
+	hb.group = (PurpleBlistNode*)group;
+
+	return g_hash_table_lookup(purplebuddylist->buddies, &hb);
+}
+
+static void find_acct_buddies(gpointer key, gpointer value, gpointer data)
+{
+	PurpleBuddy *buddy = value;
+	GSList **list = data;
+
+	*list = g_slist_prepend(*list, buddy);
+}
+
+GSList *purple_find_buddies(PurpleAccount *account, const char *name)
+{
+	PurpleBuddy *buddy;
+	PurpleBlistNode *node;
+	GSList *ret = NULL;
+
+	g_return_val_if_fail(purplebuddylist != NULL, NULL);
+	g_return_val_if_fail(account != NULL, NULL);
+
+	if ((name != NULL) && (*name != '\0')) {
+		struct _purple_hbuddy hb;
+
+		hb.name = (gchar *)purple_normalize(account, name);
+		hb.account = account;
+
+		for (node = purplebuddylist->root; node != NULL; node = node->next) {
+			if (!node->child)
+				continue;
+
+			hb.group = node;
+			if ((buddy = g_hash_table_lookup(purplebuddylist->buddies, &hb)) != NULL)
+				ret = g_slist_prepend(ret, buddy);
+		}
+	} else {
+		GSList *list = NULL;
+		GHashTable *buddies = g_hash_table_lookup(buddies_cache, account);
+		g_hash_table_foreach(buddies, find_acct_buddies, &list);
+		ret = list;
+	}
+
+	return ret;
+}
+
+PurpleGroup *purple_find_group(const char *name)
+{
+	gchar* key;
+	PurpleGroup *group;
+
+	g_return_val_if_fail(purplebuddylist != NULL, NULL);
+	g_return_val_if_fail((name != NULL) && (*name != '\0'), NULL);
+
+	key = g_utf8_collate_key(name, -1);
+	group = g_hash_table_lookup(groups_cache, key);
+	g_free(key);
+
+	return group;
+}
+
+PurpleChat *
+purple_blist_find_chat(PurpleAccount *account, const char *name)
+{
+	char *chat_name;
+	PurpleChat *chat;
+	PurplePlugin *prpl;
+	PurplePluginProtocolInfo *prpl_info = NULL;
+	struct proto_chat_entry *pce;
+	PurpleBlistNode *node, *group;
+	GList *parts;
+	char *normname;
+
+	g_return_val_if_fail(purplebuddylist != NULL, NULL);
+	g_return_val_if_fail((name != NULL) && (*name != '\0'), NULL);
+
+	if (!purple_account_is_connected(account))
+		return NULL;
+
+	prpl = purple_find_prpl(purple_account_get_protocol_id(account));
+	prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+
+	if (prpl_info->find_blist_chat != NULL)
+		return prpl_info->find_blist_chat(account, name);
+
+	normname = g_strdup(purple_normalize(account, name));
+	for (group = purplebuddylist->root; group != NULL; group = group->next) {
+		for (node = group->child; node != NULL; node = node->next) {
+			if (PURPLE_BLIST_NODE_IS_CHAT(node)) {
+
+				chat = (PurpleChat*)node;
+
+				if (account != chat->account)
+					continue;
+
+				parts = prpl_info->chat_info(
+					purple_account_get_connection(chat->account));
+
+				pce = parts->data;
+				chat_name = g_hash_table_lookup(chat->components,
+												pce->identifier);
+				g_list_foreach(parts, (GFunc)g_free, NULL);
+				g_list_free(parts);
+
+				if (chat->account == account && chat_name != NULL &&
+					normname != NULL && !strcmp(purple_normalize(account, chat_name), normname)) {
+					g_free(normname);
+					return chat;
+				}
+			}
+		}
+	}
+
+	g_free(normname);
+	return NULL;
+}
+
+PurpleGroup *
+purple_chat_get_group(PurpleChat *chat)
+{
+	g_return_val_if_fail(chat != NULL, NULL);
+
+	return (PurpleGroup *)(((PurpleBlistNode *)chat)->parent);
+}
+
+PurpleAccount *
+purple_chat_get_account(PurpleChat *chat)
+{
+	g_return_val_if_fail(chat != NULL, NULL);
+
+	return chat->account;
+}
+
+GHashTable *
+purple_chat_get_components(PurpleChat *chat)
+{
+	g_return_val_if_fail(chat != NULL, NULL);
+
+	return chat->components;
+}
+
+PurpleContact *purple_buddy_get_contact(PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	return PURPLE_CONTACT(PURPLE_BLIST_NODE(buddy)->parent);
+}
+
+PurplePresence *purple_buddy_get_presence(const PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+	return buddy->presence;
+}
+
+PurpleMediaCaps purple_buddy_get_media_caps(const PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, 0);
+	return buddy->media_caps;
+}
+
+void purple_buddy_set_media_caps(PurpleBuddy *buddy, PurpleMediaCaps media_caps)
+{
+	g_return_if_fail(buddy != NULL);
+	buddy->media_caps = media_caps;
+}
+
+PurpleGroup *purple_buddy_get_group(PurpleBuddy *buddy)
+{
+	g_return_val_if_fail(buddy != NULL, NULL);
+
+	if (((PurpleBlistNode *)buddy)->parent == NULL)
+		return NULL;
+
+	return (PurpleGroup *)(((PurpleBlistNode*)buddy)->parent->parent);
+}
+
+GSList *purple_group_get_accounts(PurpleGroup *group)
+{
+	GSList *l = NULL;
+	PurpleBlistNode *gnode, *cnode, *bnode;
+
+	gnode = (PurpleBlistNode *)group;
+
+	for (cnode = gnode->child;  cnode; cnode = cnode->next) {
+		if (PURPLE_BLIST_NODE_IS_CHAT(cnode)) {
+			if (!g_slist_find(l, ((PurpleChat *)cnode)->account))
+				l = g_slist_append(l, ((PurpleChat *)cnode)->account);
+		} else if (PURPLE_BLIST_NODE_IS_CONTACT(cnode)) {
+			for (bnode = cnode->child; bnode; bnode = bnode->next) {
+				if (PURPLE_BLIST_NODE_IS_BUDDY(bnode)) {
+					if (!g_slist_find(l, ((PurpleBuddy *)bnode)->account))
+						l = g_slist_append(l, ((PurpleBuddy *)bnode)->account);
+				}
+			}
+		}
+	}
+
+	return l;
+}
+
+void purple_blist_add_account(PurpleAccount *account)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleBlistNode *gnode, *cnode, *bnode;
+
+	g_return_if_fail(purplebuddylist != NULL);
+
+	if (!ops || !ops->update)
+		return;
+
+	for (gnode = purplebuddylist->root; gnode; gnode = gnode->next) {
+		if (!PURPLE_BLIST_NODE_IS_GROUP(gnode))
+			continue;
+		for (cnode = gnode->child; cnode; cnode = cnode->next) {
+			if (PURPLE_BLIST_NODE_IS_CONTACT(cnode)) {
+				gboolean recompute = FALSE;
+					for (bnode = cnode->child; bnode; bnode = bnode->next) {
+						if (PURPLE_BLIST_NODE_IS_BUDDY(bnode) &&
+								((PurpleBuddy*)bnode)->account == account) {
+							recompute = TRUE;
+							((PurpleContact*)cnode)->currentsize++;
+							if (((PurpleContact*)cnode)->currentsize == 1)
+								((PurpleGroup*)gnode)->currentsize++;
+							ops->update(purplebuddylist, bnode);
+						}
+					}
+					if (recompute ||
+							purple_blist_node_get_bool(cnode, "show_offline")) {
+						purple_contact_invalidate_priority_buddy((PurpleContact*)cnode);
+						ops->update(purplebuddylist, cnode);
+					}
+			} else if (PURPLE_BLIST_NODE_IS_CHAT(cnode) &&
+					((PurpleChat*)cnode)->account == account) {
+				((PurpleGroup *)gnode)->online++;
+				((PurpleGroup *)gnode)->currentsize++;
+				ops->update(purplebuddylist, cnode);
+			}
+		}
+		ops->update(purplebuddylist, gnode);
+	}
+}
+
+void purple_blist_remove_account(PurpleAccount *account)
+{
+	PurpleBlistUiOps *ops = purple_blist_get_ui_ops();
+	PurpleBlistNode *gnode, *cnode, *bnode;
+	PurpleBuddy *buddy;
+	PurpleChat *chat;
+	PurpleContact *contact;
+	PurpleGroup *group;
+	GList *list = NULL, *iter = NULL;
+
+	g_return_if_fail(purplebuddylist != NULL);
+
+	for (gnode = purplebuddylist->root; gnode; gnode = gnode->next) {
+		if (!PURPLE_BLIST_NODE_IS_GROUP(gnode))
+			continue;
+
+		group = (PurpleGroup *)gnode;
+
+		for (cnode = gnode->child; cnode; cnode = cnode->next) {
+			if (PURPLE_BLIST_NODE_IS_CONTACT(cnode)) {
+				gboolean recompute = FALSE;
+				contact = (PurpleContact *)cnode;
+
+				for (bnode = cnode->child; bnode; bnode = bnode->next) {
+					if (!PURPLE_BLIST_NODE_IS_BUDDY(bnode))
+						continue;
+
+					buddy = (PurpleBuddy *)bnode;
+					if (account == buddy->account) {
+						PurplePresence *presence;
+
+						presence = purple_buddy_get_presence(buddy);
+
+						if(purple_presence_is_online(presence)) {
+							contact->online--;
+							if (contact->online == 0)
+								group->online--;
+
+							purple_blist_node_set_int(&buddy->node,
+													"last_seen", time(NULL));
+						}
+
+						contact->currentsize--;
+						if (contact->currentsize == 0)
+							group->currentsize--;
+
+						if (!g_list_find(list, presence))
+							list = g_list_prepend(list, presence);
+
+						if (contact->priority == buddy)
+							purple_contact_invalidate_priority_buddy(contact);
+						else
+							recompute = TRUE;
+
+						if (ops && ops->remove) {
+							ops->remove(purplebuddylist, bnode);
+						}
+					}
+				}
+				if (recompute) {
+					purple_contact_invalidate_priority_buddy(contact);
+					if (ops && ops->update)
+						ops->update(purplebuddylist, cnode);
+				}
+			} else if (PURPLE_BLIST_NODE_IS_CHAT(cnode)) {
+				chat = (PurpleChat *)cnode;
+
+				if(chat->account == account) {
+					group->currentsize--;
+					group->online--;
+
+					if (ops && ops->remove)
+						ops->remove(purplebuddylist, cnode);
+				}
+			}
+		}
+	}
+
+	for (iter = list; iter; iter = iter->next)
+	{
+		purple_presence_set_status_active(iter->data, "offline", TRUE);
+	}
+	g_list_free(list);
+}
+
+gboolean purple_group_on_account(PurpleGroup *g, PurpleAccount *account)
+{
+	PurpleBlistNode *cnode;
+	for (cnode = ((PurpleBlistNode *)g)->child; cnode; cnode = cnode->next) {
+		if (PURPLE_BLIST_NODE_IS_CONTACT(cnode)) {
+			if(purple_contact_on_account((PurpleContact *) cnode, account))
+				return TRUE;
+		} else if (PURPLE_BLIST_NODE_IS_CHAT(cnode)) {
+			PurpleChat *chat = (PurpleChat *)cnode;
+			if ((!account && purple_account_is_connected(chat->account))
+					|| chat->account == account)
+				return TRUE;
+		}
+	}
+	return FALSE;
+}
+
+const char *purple_group_get_name(PurpleGroup *group)
+{
+	g_return_val_if_fail(group != NULL, NULL);
+
+	return group->name;
+}
+
+void
+purple_blist_request_add_buddy(PurpleAccount *account, const char *username,
+							 const char *group, const char *alias)
+{
+	PurpleBlistUiOps *ui_ops;
+
+	ui_ops = purple_blist_get_ui_ops();
+
+	if (ui_ops != NULL && ui_ops->request_add_buddy != NULL)
+		ui_ops->request_add_buddy(account, username, group, alias);
+}
+
+void
+purple_blist_request_add_chat(PurpleAccount *account, PurpleGroup *group,
+							const char *alias, const char *name)
+{
+	PurpleBlistUiOps *ui_ops;
+
+	ui_ops = purple_blist_get_ui_ops();
+
+	if (ui_ops != NULL && ui_ops->request_add_chat != NULL)
+		ui_ops->request_add_chat(account, group, alias, name);
+}
+
+void
+purple_blist_request_add_group(void)
+{
+	PurpleBlistUiOps *ui_ops;
+
+	ui_ops = purple_blist_get_ui_ops();
+
+	if (ui_ops != NULL && ui_ops->request_add_group != NULL)
+		ui_ops->request_add_group();
+}
+
+static void
+purple_blist_node_destroy(PurpleBlistNode *node)
+{
+	PurpleBlistUiOps *ui_ops;
+	PurpleBlistNode *child, *next_child;
+
+	ui_ops = purple_blist_get_ui_ops();
+	child = node->child;
+	while (child) {
+		next_child = child->next;
+		purple_blist_node_destroy(child);
+		child = next_child;
+	}
+
+	/* Allow the UI to free data */
+	node->parent = NULL;
+	node->child  = NULL;
+	node->next   = NULL;
+	node->prev   = NULL;
+	if (ui_ops && ui_ops->remove)
+		ui_ops->remove(purplebuddylist, node);
+
+	if (PURPLE_BLIST_NODE_IS_BUDDY(node))
+		purple_buddy_destroy((PurpleBuddy*)node);
+	else if (PURPLE_BLIST_NODE_IS_CHAT(node))
+		purple_chat_destroy((PurpleChat*)node);
+	else if (PURPLE_BLIST_NODE_IS_CONTACT(node))
+		purple_contact_destroy((PurpleContact*)node);
+	else if (PURPLE_BLIST_NODE_IS_GROUP(node))
+		purple_group_destroy((PurpleGroup*)node);
+}
+
+static void
+purple_blist_node_setting_free(gpointer data)
+{
+	PurpleValue *value;
+
+	value = (PurpleValue *)data;
+
+	purple_value_destroy(value);
+}
+
+static void purple_blist_node_initialize_settings(PurpleBlistNode *node)
+{
+	if (node->settings)
+		return;
+
+	node->settings = g_hash_table_new_full(g_str_hash, g_str_equal, g_free,
+			(GDestroyNotify)purple_blist_node_setting_free);
+}
+
+void purple_blist_node_remove_setting(PurpleBlistNode *node, const char *key)
+{
+	PurpleBlistUiOps *ops;
+	g_return_if_fail(node != NULL);
+	g_return_if_fail(node->settings != NULL);
+	g_return_if_fail(key != NULL);
+
+	g_hash_table_remove(node->settings, key);
+
+	ops = purple_blist_get_ui_ops();
+	if (ops && ops->save_node)
+		ops->save_node(node);
+}
+
+void
+purple_blist_node_set_flags(PurpleBlistNode *node, PurpleBlistNodeFlags flags)
+{
+	g_return_if_fail(node != NULL);
+
+	node->flags = flags;
+}
+
+PurpleBlistNodeFlags
+purple_blist_node_get_flags(PurpleBlistNode *node)
+{
+	g_return_val_if_fail(node != NULL, 0);
+
+	return node->flags;
+}
+
+PurpleBlistNodeType
+purple_blist_node_get_type(PurpleBlistNode *node)
+{
+	g_return_val_if_fail(node != NULL, PURPLE_BLIST_OTHER_NODE);
+	return node->type;
+}
+
+void
+purple_blist_node_set_bool(PurpleBlistNode* node, const char *key, gboolean data)
+{
+	PurpleValue *value;
+	PurpleBlistUiOps *ops;
+
+	g_return_if_fail(node != NULL);
+	g_return_if_fail(node->settings != NULL);
+	g_return_if_fail(key != NULL);
+
+	value = purple_value_new(PURPLE_TYPE_BOOLEAN);
+	purple_value_set_boolean(value, data);
+
+	g_hash_table_replace(node->settings, g_strdup(key), value);
+
+	ops = purple_blist_get_ui_ops();
+	if (ops && ops->save_node)
+		ops->save_node(node);
+}
+
+gboolean
+purple_blist_node_get_bool(PurpleBlistNode* node, const char *key)
+{
+	PurpleValue *value;
+
+	g_return_val_if_fail(node != NULL, FALSE);
+	g_return_val_if_fail(node->settings != NULL, FALSE);
+	g_return_val_if_fail(key != NULL, FALSE);
+
+	value = g_hash_table_lookup(node->settings, key);
+
+	if (value == NULL)
+		return FALSE;
+
+	g_return_val_if_fail(purple_value_get_type(value) == PURPLE_TYPE_BOOLEAN, FALSE);
+
+	return purple_value_get_boolean(value);
+}
+
+void
+purple_blist_node_set_int(PurpleBlistNode* node, const char *key, int data)
+{
+	PurpleValue *value;
+	PurpleBlistUiOps *ops;
+
+	g_return_if_fail(node != NULL);
+	g_return_if_fail(node->settings != NULL);
+	g_return_if_fail(key != NULL);
+
+	value = purple_value_new(PURPLE_TYPE_INT);
+	purple_value_set_int(value, data);
+
+	g_hash_table_replace(node->settings, g_strdup(key), value);
+
+	ops = purple_blist_get_ui_ops();
+	if (ops && ops->save_node)
+		ops->save_node(node);
+}
+
+int
+purple_blist_node_get_int(PurpleBlistNode* node, const char *key)
+{
+	PurpleValue *value;
+
+	g_return_val_if_fail(node != NULL, 0);
+	g_return_val_if_fail(node->settings != NULL, 0);
+	g_return_val_if_fail(key != NULL, 0);
+
+	value = g_hash_table_lookup(node->settings, key);
+
+	if (value == NULL)
+		return 0;
+
+	g_return_val_if_fail(purple_value_get_type(value) == PURPLE_TYPE_INT, 0);
+
+	return purple_value_get_int(value);
+}
+
+void
+purple_blist_node_set_string(PurpleBlistNode* node, const char *key, const char *data)
+{
+	PurpleValue *value;
+	PurpleBlistUiOps *ops;
+
+	g_return_if_fail(node != NULL);
+	g_return_if_fail(node->settings != NULL);
+	g_return_if_fail(key != NULL);
+
+	value = purple_value_new(PURPLE_TYPE_STRING);
+	purple_value_set_string(value, data);
+
+	g_hash_table_replace(node->settings, g_strdup(key), value);
+
+	ops = purple_blist_get_ui_ops();
+	if (ops && ops->save_node)
+		ops->save_node(node);
+}
+
+const char *
+purple_blist_node_get_string(PurpleBlistNode* node, const char *key)
+{
+	PurpleValue *value;
+
+	g_return_val_if_fail(node != NULL, NULL);
+	g_return_val_if_fail(node->settings != NULL, NULL);
+	g_return_val_if_fail(key != NULL, NULL);
+
+	value = g_hash_table_lookup(node->settings, key);
+
+	if (value == NULL)
+		return NULL;
+
+	g_return_val_if_fail(purple_value_get_type(value) == PURPLE_TYPE_STRING, NULL);
+
+	return purple_value_get_string(value);
+}
+
+GList *
+purple_blist_node_get_extended_menu(PurpleBlistNode *n)
+{
+	GList *menu = NULL;
+
+	g_return_val_if_fail(n != NULL, NULL);
+
+	purple_signal_emit(purple_blist_get_handle(),
+			"blist-node-extended-menu",
+			n, &menu);
+	return menu;
+}
+
+int purple_blist_get_group_size(PurpleGroup *group, gboolean offline)
+{
+	if (!group)
+		return 0;
+
+	return offline ? group->totalsize : group->currentsize;
+}
+
+int purple_blist_get_group_online_count(PurpleGroup *group)
+{
+	if (!group)
+		return 0;
+
+	return group->online;
+}
+
+void
+purple_blist_set_ui_ops(PurpleBlistUiOps *ops)
+{
+	gboolean overrode = FALSE;
+	blist_ui_ops = ops;
+
+	if (!ops)
+		return;
+
+	if (!ops->save_node) {
+		ops->save_node = purple_blist_save_node;
+		overrode = TRUE;
+	}
+	if (!ops->remove_node) {
+		ops->remove_node = purple_blist_save_node;
+		overrode = TRUE;
+	}
+	if (!ops->save_account) {
+		ops->save_account = purple_blist_save_account;
+		overrode = TRUE;
+	}
+
+	if (overrode && (ops->save_node    != purple_blist_save_node ||
+	                 ops->remove_node  != purple_blist_save_node ||
+	                 ops->save_account != purple_blist_save_account)) {
+		purple_debug_warning("blist", "Only some of the blist saving UI ops "
+				"were overridden. This probably is not what you want!\n");
+	}
+}
+
+PurpleBlistUiOps *
+purple_blist_get_ui_ops(void)
+{
+	return blist_ui_ops;
+}
+
+
+void *
+purple_blist_get_handle(void)
+{
+	static int handle;
+
+	return &handle;
+}
+
+void
+purple_blist_init(void)
+{
+	void *handle = purple_blist_get_handle();
+
+	purple_signal_register(handle, "buddy-status-changed",
+	                     purple_marshal_VOID__POINTER_POINTER_POINTER, NULL,
+	                     3,
+	                     purple_value_new(PURPLE_TYPE_SUBTYPE,
+	                                    PURPLE_SUBTYPE_BLIST_BUDDY),
+	                     purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_STATUS),
+	                     purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_STATUS));
+	purple_signal_register(handle, "buddy-privacy-changed",
+	                     purple_marshal_VOID__POINTER, NULL,
+	                     1,
+	                     purple_value_new(PURPLE_TYPE_SUBTYPE,
+	                                    PURPLE_SUBTYPE_BLIST_BUDDY));
+
+	purple_signal_register(handle, "buddy-idle-changed",
+	                     purple_marshal_VOID__POINTER_INT_INT, NULL,
+	                     3,
+	                     purple_value_new(PURPLE_TYPE_SUBTYPE,
+	                                    PURPLE_SUBTYPE_BLIST_BUDDY),
+	                     purple_value_new(PURPLE_TYPE_INT),
+	                     purple_value_new(PURPLE_TYPE_INT));
+
+
+	purple_signal_register(handle, "buddy-signed-on",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_BUDDY));
+
+	purple_signal_register(handle, "buddy-signed-off",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_BUDDY));
+
+	purple_signal_register(handle, "buddy-got-login-time",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_BUDDY));
+
+	purple_signal_register(handle, "blist-node-added",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_NODE));
+
+	purple_signal_register(handle, "blist-node-removed",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_NODE));
+
+	purple_signal_register(handle, "buddy-added",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_BUDDY));
+
+	purple_signal_register(handle, "buddy-removed",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_BUDDY));
+
+	purple_signal_register(handle, "buddy-icon-changed",
+						 purple_marshal_VOID__POINTER, NULL, 1,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_BUDDY));
+
+	purple_signal_register(handle, "update-idle", purple_marshal_VOID, NULL, 0);
+
+	purple_signal_register(handle, "blist-node-extended-menu",
+			     purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			     purple_value_new(PURPLE_TYPE_SUBTYPE,
+					    PURPLE_SUBTYPE_BLIST_NODE),
+			     purple_value_new(PURPLE_TYPE_BOXED, "GList **"));
+
+	purple_signal_register(handle, "blist-node-aliased",
+						 purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+						 purple_value_new(PURPLE_TYPE_SUBTYPE,
+										PURPLE_SUBTYPE_BLIST_NODE),
+						 purple_value_new(PURPLE_TYPE_STRING));
+
+	purple_signal_register(handle, "buddy-caps-changed",
+			purple_marshal_VOID__POINTER_INT_INT, NULL,
+			3, purple_value_new(PURPLE_TYPE_SUBTYPE,
+				PURPLE_SUBTYPE_BLIST_BUDDY),
+			purple_value_new(PURPLE_TYPE_INT),
+			purple_value_new(PURPLE_TYPE_INT));
+
+	purple_signal_connect(purple_accounts_get_handle(), "account-created",
+			handle,
+			PURPLE_CALLBACK(purple_blist_buddies_cache_add_account),
+			NULL);
+
+	purple_signal_connect(purple_accounts_get_handle(), "account-destroying",
+			handle,
+			PURPLE_CALLBACK(purple_blist_buddies_cache_remove_account),
+			NULL);
+}
+
+void
+purple_blist_uninit(void)
+{
+	PurpleBlistNode *node, *next_node;
+
+	/* This happens if we quit before purple_set_blist is called. */
+	if (purplebuddylist == NULL)
+		return;
+
+	if (save_timer != 0) {
+		purple_timeout_remove(save_timer);
+		save_timer = 0;
+		purple_blist_sync();
+	}
+
+	purple_blist_destroy();
+
+	node = purple_blist_get_root();
+	while (node) {
+		next_node = node->next;
+		purple_blist_node_destroy(node);
+		node = next_node;
+	}
+	purplebuddylist->root = NULL;
+
+	g_hash_table_destroy(purplebuddylist->buddies);
+	g_hash_table_destroy(buddies_cache);
+	g_hash_table_destroy(groups_cache);
+
+	buddies_cache = NULL;
+	groups_cache = NULL;
+
+	PURPLE_DBUS_UNREGISTER_POINTER(purplebuddylist);
+	g_free(purplebuddylist);
+	purplebuddylist = NULL;
+
+	purple_signals_disconnect_by_handle(purple_blist_get_handle());
+	purple_signals_unregister_by_instance(purple_blist_get_handle());
+}
diff -rupN pidgin-2.7.7/libpurple/certificate.c~ pidgin-2.7.7-new//libpurple/certificate.c~
--- pidgin-2.7.7/libpurple/certificate.c~	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/certificate.c~	2011-03-27 09:15:31.012553000 -0600
@@ -0,0 +1,2235 @@
+/**
+ * @file certificate.c Public-Key Certificate API
+ * @ingroup core
+ */
+
+/*
+ *
+ * purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ */
+
+#include "internal.h"
+#include "certificate.h"
+#include "dbus-maybe.h"
+#include "debug.h"
+#include "request.h"
+#include "signals.h"
+#include "util.h"
+
+/** List holding pointers to all registered certificate schemes */
+static GList *cert_schemes = NULL;
+/** List of registered Verifiers */
+static GList *cert_verifiers = NULL;
+/** List of registered Pools */
+static GList *cert_pools = NULL;
+
+/*
+ * TODO: Merge this with PurpleCertificateVerificationStatus for 3.0.0 */
+typedef enum {
+	PURPLE_CERTIFICATE_UNKNOWN_ERROR = -1,
+
+	/* Not an error */
+	PURPLE_CERTIFICATE_NO_PROBLEMS = 0,
+
+	/* Non-fatal */
+	PURPLE_CERTIFICATE_NON_FATALS_MASK = 0x0000FFFF,
+
+	/* The certificate is self-signed. */
+	PURPLE_CERTIFICATE_SELF_SIGNED = 0x01,
+
+	/* The CA is not in libpurple's pool of certificates. */
+	PURPLE_CERTIFICATE_CA_UNKNOWN = 0x02,
+
+	/* The current time is before the certificate's specified
+	 * activation time.
+	 */
+	PURPLE_CERTIFICATE_NOT_ACTIVATED = 0x04,
+
+	/* The current time is after the certificate's specified expiration time */
+	PURPLE_CERTIFICATE_EXPIRED = 0x08,
+
+	/* The certificate's subject name doesn't match the expected */
+	PURPLE_CERTIFICATE_NAME_MISMATCH = 0x10,
+
+	/* No CA pool was found. This shouldn't happen... */
+	PURPLE_CERTIFICATE_NO_CA_POOL = 0x20,
+
+	/* Fatal */
+	PURPLE_CERTIFICATE_FATALS_MASK = 0xFFFF0000,
+
+	/* The signature chain could not be validated. Due to limitations in the
+	 * the current API, this also indicates one of the CA certificates in the
+	 * chain is expired (or not yet activated). FIXME 3.0.0 */
+	PURPLE_CERTIFICATE_INVALID_CHAIN = 0x10000,
+
+	/* The signature has been revoked. */
+	PURPLE_CERTIFICATE_REVOKED = 0x20000,
+
+	PURPLE_CERTIFICATE_LAST = 0x40000,
+} PurpleCertificateInvalidityFlags;
+
+static const gchar *
+invalidity_reason_to_string(PurpleCertificateInvalidityFlags flag)
+{
+	switch (flag) {
+		case PURPLE_CERTIFICATE_SELF_SIGNED:
+			return _("The certificate is self-signed and cannot be "
+			         "automatically checked.");
+			break;
+		case PURPLE_CERTIFICATE_CA_UNKNOWN:
+			return _("The certificate is not trusted because no certificate "
+			         "that can verify it is currently trusted.");
+			break;
+		case PURPLE_CERTIFICATE_NOT_ACTIVATED:
+			return _("The certificate is not valid yet.  Check that your "
+			         "computer's date and time are accurate.");
+			break;
+		case PURPLE_CERTIFICATE_EXPIRED:
+			return _("The certificate has expired and should not be "
+			         "considered valid.  Check that your computer's date "
+			         "and time are accurate.");
+			break;
+		case PURPLE_CERTIFICATE_NAME_MISMATCH:
+			/* Translators: "domain" refers to a DNS domain (e.g. talk.google.com) */
+			return _("The certificate presented is not issued to this domain.");
+			break;
+		case PURPLE_CERTIFICATE_NO_CA_POOL:
+			return _("You have no database of root certificates, so "
+			         "this certificate cannot be validated.");
+			break;
+		case PURPLE_CERTIFICATE_INVALID_CHAIN:
+			return _("The certificate chain presented is invalid.");
+			break;
+		case PURPLE_CERTIFICATE_REVOKED:
+			return _("The certificate has been revoked.");
+			break;
+		case PURPLE_CERTIFICATE_UNKNOWN_ERROR:
+		default:
+			return _("An unknown certificate error occurred.");
+			break;
+	}
+}
+
+void
+purple_certificate_verify (PurpleCertificateVerifier *verifier,
+			   const gchar *subject_name, GList *cert_chain,
+			   PurpleCertificateVerifiedCallback cb,
+			   gpointer cb_data)
+{
+	PurpleCertificateVerificationRequest *vrq;
+	PurpleCertificateScheme *scheme;
+
+	g_return_if_fail(subject_name != NULL);
+	/* If you don't have a cert to check, why are you requesting that it
+	   be verified? */
+	g_return_if_fail(cert_chain != NULL);
+	g_return_if_fail(cb != NULL);
+
+	/* Look up the CertificateScheme */
+	scheme = purple_certificate_find_scheme(verifier->scheme_name);
+	g_return_if_fail(scheme);
+
+	/* Check that at least the first cert in the chain matches the
+	   Verifier scheme */
+	g_return_if_fail(scheme ==
+			 ((PurpleCertificate *) (cert_chain->data))->scheme);
+
+	/* Construct and fill in the request fields */
+	vrq = g_new0(PurpleCertificateVerificationRequest, 1);
+	vrq->verifier = verifier;
+	vrq->scheme = scheme;
+	vrq->subject_name = g_strdup(subject_name);
+	vrq->cert_chain = purple_certificate_copy_list(cert_chain);
+	vrq->cb = cb;
+	vrq->cb_data = cb_data;
+
+	/* Initiate verification */
+	(verifier->start_verification)(vrq);
+}
+
+void
+purple_certificate_verify_complete(PurpleCertificateVerificationRequest *vrq,
+				   PurpleCertificateVerificationStatus st)
+{
+	PurpleCertificateVerifier *vr;
+
+	g_return_if_fail(vrq);
+
+	const char *acceptbadcert;
+	acceptbadcert = purple_prefs_get_string("/purple/acceptbadcert");
+
+	if (acceptbadcert != NULL)
+	{
+		purple_debug_warning("certificate", "Certificate Error. Accepting as requested!\n");
+		purple_prefs_remove("/purple/acceptbadcert");
+
+
+		const char *acceptbadcert;
+		acceptbadcert = purple_prefs_get_string("/purple/acceptbadcert");
+
+		if (acceptbadcert != NULL)
+		{
+			purple_debug_warning("certificate", "Certificate Error. Accepting as requested!\n");
+			purple_prefs_remove("/purple/acceptbadcert");
+
+			//Dodgy Cert Acceptance
+			st = PURPLE_CERTIFICATE_VALID;
+		}
+		//Dodgy Cert Acceptance
+		st = PURPLE_CERTIFICATE_VALID;
+	}
+	
+	if (st == PURPLE_CERTIFICATE_VALID) {
+		purple_debug_info("certificate",
+				  "Successfully verified certificate for %s\n",
+				  vrq->subject_name);
+	} else {
+		purple_debug_error("certificate",
+				  "Failed to verify certificate for %s\n",
+				  vrq->subject_name);
+	}
+
+	/* Pass the results on to the request's callback */
+	(vrq->cb)(st, vrq->cb_data);
+
+	/* And now to eliminate the request */
+	/* Fetch the Verifier responsible... */
+	vr = vrq->verifier;
+	/* ...and order it to KILL */
+	(vr->destroy_request)(vrq);
+
+	/* Now the internals have been cleaned up, so clean up the libpurple-
+	   created elements */
+	g_free(vrq->subject_name);
+	purple_certificate_destroy_list(vrq->cert_chain);
+
+	/*  A structure born
+	 *          to much ado
+	 *                   and with so much within.
+	 * It reaches now
+	 *             its quiet end. */
+	g_free(vrq);
+}
+
+
+PurpleCertificate *
+purple_certificate_copy(PurpleCertificate *crt)
+{
+	g_return_val_if_fail(crt, NULL);
+	g_return_val_if_fail(crt->scheme, NULL);
+	g_return_val_if_fail(crt->scheme->copy_certificate, NULL);
+
+	return (crt->scheme->copy_certificate)(crt);
+}
+
+GList *
+purple_certificate_copy_list(GList *crt_list)
+{
+	GList *new_l, *l;
+
+	/* First, make a shallow copy of the list */
+	new_l = g_list_copy(crt_list);
+
+	/* Now go through and actually duplicate each certificate */
+	for (l = new_l; l; l = l->next) {
+		l->data = purple_certificate_copy(l->data);
+	}
+
+	return new_l;
+}
+
+void
+purple_certificate_destroy (PurpleCertificate *crt)
+{
+	PurpleCertificateScheme *scheme;
+
+	if (NULL == crt) return;
+
+	scheme = crt->scheme;
+
+	(scheme->destroy_certificate)(crt);
+}
+
+void
+purple_certificate_destroy_list (GList * crt_list)
+{
+	PurpleCertificate *crt;
+	GList *l;
+
+	for (l=crt_list; l; l = l->next) {
+		crt = (PurpleCertificate *) l->data;
+		purple_certificate_destroy(crt);
+	}
+
+	g_list_free(crt_list);
+}
+
+gboolean
+purple_certificate_signed_by(PurpleCertificate *crt, PurpleCertificate *issuer)
+{
+	PurpleCertificateScheme *scheme;
+
+	g_return_val_if_fail(crt, FALSE);
+	g_return_val_if_fail(issuer, FALSE);
+
+	scheme = crt->scheme;
+	g_return_val_if_fail(scheme, FALSE);
+	/* We can't compare two certs of unrelated schemes, obviously */
+	g_return_val_if_fail(issuer->scheme == scheme, FALSE);
+
+	return (scheme->signed_by)(crt, issuer);
+}
+
+gboolean
+purple_certificate_check_signature_chain_with_failing(GList *chain,
+                                                      PurpleCertificate **failing)
+{
+	GList *cur;
+	PurpleCertificate *crt, *issuer;
+	gchar *uid;
+	time_t now, activation, expiration;
+	gboolean ret;
+
+	g_return_val_if_fail(chain, FALSE);
+
+	if (failing)
+		*failing = NULL;
+
+	uid = purple_certificate_get_unique_id((PurpleCertificate *) chain->data);
+	purple_debug_info("certificate",
+			  "Checking signature chain for uid=%s\n",
+			  uid);
+	g_free(uid);
+
+	/* If this is a single-certificate chain, say that it is valid */
+	if (chain->next == NULL) {
+		purple_debug_info("certificate",
+				  "...Singleton. We'll say it's valid.\n");
+		return TRUE;
+	}
+
+	now = time(NULL);
+
+	/* Load crt with the first certificate */
+	crt = (PurpleCertificate *)(chain->data);
+	/* And start with the second certificate in the chain */
+	for ( cur = chain->next; cur; cur = cur->next ) {
+
+		issuer = (PurpleCertificate *)(cur->data);
+
+		uid = purple_certificate_get_unique_id(issuer);
+
+		ret = purple_certificate_get_times(issuer, &activation, &expiration);
+		if (!ret || now < activation || now > expiration) { 
+			if (!ret)
+				purple_debug_error("certificate",
+						"...Failed to get validity times for certificate %s\n"
+						"Chain is INVALID\n", uid);
+			else if (now > expiration)
+				purple_debug_error("certificate",
+						"...Issuer %s expired at %s\nChain is INVALID\n",
+						uid, ctime(&expiration));
+			else
+				purple_debug_error("certificate",
+						"...Not-yet-activated issuer %s will be valid at %s\n"
+						"Chain is INVALID\n", uid, ctime(&activation));
+
+			if (failing)
+				*failing = crt;
+
+			g_free(uid);
+			return FALSE;
+		}
+
+		/* Check the signature for this link */
+		if (! purple_certificate_signed_by(crt, issuer) ) {
+			purple_debug_error("certificate",
+					  "...Bad or missing signature by %s\nChain is INVALID\n",
+					  uid);
+			g_free(uid);
+
+			if (failing)
+				*failing = crt;
+
+			return FALSE;
+		}
+
+		purple_debug_info("certificate",
+				  "...Good signature by %s\n",
+				  uid);
+		g_free(uid);
+
+		/* The issuer is now the next crt whose signature is to be
+		   checked */
+		crt = issuer;
+	}
+
+	/* If control reaches this point, the chain is valid */
+	purple_debug_info("certificate", "Chain is VALID\n");
+	return TRUE;
+}
+
+gboolean
+purple_certificate_check_signature_chain(GList *chain)
+{
+	return purple_certificate_check_signature_chain_with_failing(chain, NULL);
+}
+
+PurpleCertificate *
+purple_certificate_import(PurpleCertificateScheme *scheme, const gchar *filename)
+{
+	g_return_val_if_fail(scheme, NULL);
+	g_return_val_if_fail(scheme->import_certificate, NULL);
+	g_return_val_if_fail(filename, NULL);
+
+	return (scheme->import_certificate)(filename);
+}
+
+GSList *
+purple_certificates_import(PurpleCertificateScheme *scheme, const gchar *filename)
+{
+	g_return_val_if_fail(scheme, NULL);
+	g_return_val_if_fail(scheme->import_certificates, NULL);
+	g_return_val_if_fail(filename, NULL);
+
+	return (scheme->import_certificates)(filename);
+}
+
+gboolean
+purple_certificate_export(const gchar *filename, PurpleCertificate *crt)
+{
+	PurpleCertificateScheme *scheme;
+
+	g_return_val_if_fail(filename, FALSE);
+	g_return_val_if_fail(crt, FALSE);
+	g_return_val_if_fail(crt->scheme, FALSE);
+
+	scheme = crt->scheme;
+	g_return_val_if_fail(scheme->export_certificate, FALSE);
+
+	return (scheme->export_certificate)(filename, crt);
+}
+
+static gboolean
+byte_arrays_equal(const GByteArray *array1, const GByteArray *array2)
+{
+	g_return_val_if_fail(array1 != NULL, FALSE);
+	g_return_val_if_fail(array2 != NULL, FALSE);
+
+	return (array1->len == array2->len) &&
+		(0 == memcmp(array1->data, array2->data, array1->len));
+}
+	
+GByteArray *
+purple_certificate_get_fingerprint_sha1(PurpleCertificate *crt)
+{
+	PurpleCertificateScheme *scheme;
+	GByteArray *fpr;
+
+	g_return_val_if_fail(crt, NULL);
+	g_return_val_if_fail(crt->scheme, NULL);
+
+	scheme = crt->scheme;
+
+	g_return_val_if_fail(scheme->get_fingerprint_sha1, NULL);
+
+	fpr = (scheme->get_fingerprint_sha1)(crt);
+
+	return fpr;
+}
+
+gchar *
+purple_certificate_get_unique_id(PurpleCertificate *crt)
+{
+	g_return_val_if_fail(crt, NULL);
+	g_return_val_if_fail(crt->scheme, NULL);
+	g_return_val_if_fail(crt->scheme->get_unique_id, NULL);
+
+	return (crt->scheme->get_unique_id)(crt);
+}
+
+gchar *
+purple_certificate_get_issuer_unique_id(PurpleCertificate *crt)
+{
+	g_return_val_if_fail(crt, NULL);
+	g_return_val_if_fail(crt->scheme, NULL);
+	g_return_val_if_fail(crt->scheme->get_issuer_unique_id, NULL);
+
+	return (crt->scheme->get_issuer_unique_id)(crt);
+}
+
+gchar *
+purple_certificate_get_subject_name(PurpleCertificate *crt)
+{
+	PurpleCertificateScheme *scheme;
+	gchar *subject_name;
+
+	g_return_val_if_fail(crt, NULL);
+	g_return_val_if_fail(crt->scheme, NULL);
+
+	scheme = crt->scheme;
+
+	g_return_val_if_fail(scheme->get_subject_name, NULL);
+
+	subject_name = (scheme->get_subject_name)(crt);
+
+	return subject_name;
+}
+
+gboolean
+purple_certificate_check_subject_name(PurpleCertificate *crt, const gchar *name)
+{
+	PurpleCertificateScheme *scheme;
+
+	g_return_val_if_fail(crt, FALSE);
+	g_return_val_if_fail(crt->scheme, FALSE);
+	g_return_val_if_fail(name, FALSE);
+
+	scheme = crt->scheme;
+
+	g_return_val_if_fail(scheme->check_subject_name, FALSE);
+
+	return (scheme->check_subject_name)(crt, name);
+}
+
+gboolean
+purple_certificate_get_times(PurpleCertificate *crt, time_t *activation, time_t *expiration)
+{
+	PurpleCertificateScheme *scheme;
+
+	g_return_val_if_fail(crt, FALSE);
+
+	scheme = crt->scheme;
+
+	g_return_val_if_fail(scheme, FALSE);
+
+	/* If both provided references are NULL, what are you doing calling
+	   this? */
+	g_return_val_if_fail( (activation != NULL) || (expiration != NULL), FALSE);
+
+	/* Throw the request on down to the certscheme */
+	return (scheme->get_times)(crt, activation, expiration);
+}
+
+gchar *
+purple_certificate_pool_mkpath(PurpleCertificatePool *pool, const gchar *id)
+{
+	gchar *path;
+	gchar *esc_scheme_name, *esc_name, *esc_id;
+
+	g_return_val_if_fail(pool, NULL);
+	g_return_val_if_fail(pool->scheme_name, NULL);
+	g_return_val_if_fail(pool->name, NULL);
+
+	/* Escape all the elements for filesystem-friendliness */
+	esc_scheme_name = pool ? g_strdup(purple_escape_filename(pool->scheme_name)) : NULL;
+	esc_name = pool ? g_strdup(purple_escape_filename(pool->name)) : NULL;
+	esc_id = id ? g_strdup(purple_escape_filename(id)) : NULL;
+
+	path = g_build_filename(purple_user_dir(),
+				"certificates", /* TODO: constantize this? */
+				esc_scheme_name,
+				esc_name,
+				esc_id,
+				NULL);
+
+	g_free(esc_scheme_name);
+	g_free(esc_name);
+	g_free(esc_id);
+	return path;
+}
+
+gboolean
+purple_certificate_pool_usable(PurpleCertificatePool *pool)
+{
+	g_return_val_if_fail(pool, FALSE);
+	g_return_val_if_fail(pool->scheme_name, FALSE);
+
+	/* Check that the pool's scheme is loaded */
+	if (purple_certificate_find_scheme(pool->scheme_name) == NULL) {
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+PurpleCertificateScheme *
+purple_certificate_pool_get_scheme(PurpleCertificatePool *pool)
+{
+	g_return_val_if_fail(pool, NULL);
+	g_return_val_if_fail(pool->scheme_name, NULL);
+
+	return purple_certificate_find_scheme(pool->scheme_name);
+}
+
+gboolean
+purple_certificate_pool_contains(PurpleCertificatePool *pool, const gchar *id)
+{
+	g_return_val_if_fail(pool, FALSE);
+	g_return_val_if_fail(id, FALSE);
+	g_return_val_if_fail(pool->cert_in_pool, FALSE);
+
+	return (pool->cert_in_pool)(id);
+}
+
+PurpleCertificate *
+purple_certificate_pool_retrieve(PurpleCertificatePool *pool, const gchar *id)
+{
+	g_return_val_if_fail(pool, NULL);
+	g_return_val_if_fail(id, NULL);
+	g_return_val_if_fail(pool->get_cert, NULL);
+
+	return (pool->get_cert)(id);
+}
+
+gboolean
+purple_certificate_pool_store(PurpleCertificatePool *pool, const gchar *id, PurpleCertificate *crt)
+{
+	gboolean ret = FALSE;
+
+	g_return_val_if_fail(pool, FALSE);
+	g_return_val_if_fail(id, FALSE);
+	g_return_val_if_fail(pool->put_cert, FALSE);
+
+	/* Whether crt->scheme matches find_scheme(pool->scheme_name) is not
+	   relevant... I think... */
+	g_return_val_if_fail(
+		g_ascii_strcasecmp(pool->scheme_name, crt->scheme->name) == 0,
+		FALSE);
+
+	ret = (pool->put_cert)(id, crt);
+
+	/* Signal that the certificate was stored if success*/
+	if (ret) {
+		purple_signal_emit(pool, "certificate-stored",
+				   pool, id);
+	}
+
+	return ret;
+}
+
+gboolean
+purple_certificate_pool_delete(PurpleCertificatePool *pool, const gchar *id)
+{
+	gboolean ret = FALSE;
+
+	g_return_val_if_fail(pool, FALSE);
+	g_return_val_if_fail(id, FALSE);
+	g_return_val_if_fail(pool->delete_cert, FALSE);
+
+	ret = (pool->delete_cert)(id);
+
+	/* Signal that the certificate was deleted if success */
+	if (ret) {
+		purple_signal_emit(pool, "certificate-deleted",
+				   pool, id);
+	}
+
+	return ret;
+}
+
+GList *
+purple_certificate_pool_get_idlist(PurpleCertificatePool *pool)
+{
+	g_return_val_if_fail(pool, NULL);
+	g_return_val_if_fail(pool->get_idlist, NULL);
+
+	return (pool->get_idlist)();
+}
+
+void
+purple_certificate_pool_destroy_idlist(GList *idlist)
+{
+	GList *l;
+
+	/* Iterate through and free them strings */
+	for ( l = idlist; l; l = l->next ) {
+		g_free(l->data);
+	}
+
+	g_list_free(idlist);
+}
+
+
+/****************************************************************************/
+/* Builtin Verifiers, Pools, etc.                                           */
+/****************************************************************************/
+
+static void
+x509_singleuse_verify_cb (PurpleCertificateVerificationRequest *vrq, gint id)
+{
+	g_return_if_fail(vrq);
+
+	purple_debug_info("certificate/x509_singleuse",
+			  "VRQ on cert from %s gave %d\n",
+			  vrq->subject_name, id);
+
+	/* Signal what happened back to the caller */
+	if (1 == id) {
+		/* Accepted! */
+		purple_certificate_verify_complete(vrq,
+						   PURPLE_CERTIFICATE_VALID);
+	} else {
+		/* Not accepted */
+		purple_certificate_verify_complete(vrq,
+						   PURPLE_CERTIFICATE_INVALID);
+
+	}
+}
+
+static void
+x509_singleuse_start_verify (PurpleCertificateVerificationRequest *vrq)
+{
+	gchar *sha_asc;
+	GByteArray *sha_bin;
+	gchar *cn;
+	const gchar *cn_match;
+	gchar *primary, *secondary;
+	PurpleCertificate *crt = (PurpleCertificate *) vrq->cert_chain->data;
+
+	/* Pull out the SHA1 checksum */
+	sha_bin = purple_certificate_get_fingerprint_sha1(crt);
+	/* Now decode it for display */
+	sha_asc = purple_base16_encode_chunked(sha_bin->data,
+					       sha_bin->len);
+
+	/* Get the cert Common Name */
+	cn = purple_certificate_get_subject_name(crt);
+
+	/* Determine whether the name matches */
+	if (purple_certificate_check_subject_name(crt, vrq->subject_name)) {
+		cn_match = "";
+	} else {
+		cn_match = _("(DOES NOT MATCH)");
+	}
+
+	/* Make messages */
+	primary = g_strdup_printf(_("%s has presented the following certificate for just-this-once use:"), vrq->subject_name);
+	secondary = g_strdup_printf(_("Common name: %s %s\nFingerprint (SHA1): %s"), cn, cn_match, sha_asc);
+
+	/* Make a semi-pretty display */
+	purple_request_accept_cancel(
+		vrq->cb_data, /* TODO: Find what the handle ought to be */
+		_("Single-use Certificate Verification"),
+		primary,
+		secondary,
+		0,            /* Accept by default */
+		NULL,         /* No account */
+		NULL,         /* No other user */
+		NULL,         /* No associated conversation */
+		vrq,
+		x509_singleuse_verify_cb,
+		x509_singleuse_verify_cb );
+
+	/* Cleanup */
+	g_free(cn);
+	g_free(primary);
+	g_free(secondary);
+	g_free(sha_asc);
+	g_byte_array_free(sha_bin, TRUE);
+}
+
+static void
+x509_singleuse_destroy_request (PurpleCertificateVerificationRequest *vrq)
+{
+	/* I don't do anything! */
+}
+
+static PurpleCertificateVerifier x509_singleuse = {
+	"x509",                         /* Scheme name */
+	"singleuse",                    /* Verifier name */
+	x509_singleuse_start_verify,    /* start_verification function */
+	x509_singleuse_destroy_request, /* Request cleanup operation */
+
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+
+
+/***** X.509 Certificate Authority pool, keyed by Distinguished Name *****/
+/* This is implemented in what may be the most inefficient and bugprone way
+   possible; however, future optimizations should not be difficult. */
+
+static PurpleCertificatePool x509_ca;
+
+/** Holds a key-value pair for quickish certificate lookup */
+typedef struct {
+	gchar *dn;
+	PurpleCertificate *crt;
+} x509_ca_element;
+
+static void
+x509_ca_element_free(x509_ca_element *el)
+{
+	if (NULL == el) return;
+
+	g_free(el->dn);
+	purple_certificate_destroy(el->crt);
+	g_free(el);
+}
+
+/** System directory to probe for CA certificates */
+/* This is set in the lazy_init function */
+static GList *x509_ca_paths = NULL;
+
+/** A list of loaded CAs, populated from the above path whenever the lazy_init
+    happens. Contains pointers to x509_ca_elements */
+static GList *x509_ca_certs = NULL;
+
+/** Used for lazy initialization purposes. */
+static gboolean x509_ca_initialized = FALSE;
+
+/** Adds a certificate to the in-memory cache, doing nothing else */
+static gboolean
+x509_ca_quiet_put_cert(PurpleCertificate *crt)
+{
+	x509_ca_element *el;
+
+	/* lazy_init calls this function, so calling lazy_init here is a
+	   Bad Thing */
+
+	g_return_val_if_fail(crt, FALSE);
+	g_return_val_if_fail(crt->scheme, FALSE);
+	/* Make sure that this is some kind of X.509 certificate */
+	/* TODO: Perhaps just check crt->scheme->name instead? */
+	g_return_val_if_fail(crt->scheme == purple_certificate_find_scheme(x509_ca.scheme_name), FALSE);
+
+	el = g_new0(x509_ca_element, 1);
+	el->dn = purple_certificate_get_unique_id(crt);
+	el->crt = purple_certificate_copy(crt);
+	x509_ca_certs = g_list_prepend(x509_ca_certs, el);
+
+	return TRUE;
+}
+
+/* Since the libpurple CertificatePools get registered before plugins are
+   loaded, an X.509 Scheme is generally not available when x509_ca_init is
+   called, but x509_ca requires X.509 operations in order to properly load.
+
+   To solve this, I present the lazy_init function. It attempts to finish
+   initialization of the Pool, but it usually fails when it is called from
+   x509_ca_init. However, this is OK; initialization is then simply deferred
+   until someone tries to use functions from the pool. */
+static gboolean
+x509_ca_lazy_init(void)
+{
+	PurpleCertificateScheme *x509;
+	GDir *certdir;
+	const gchar *entry;
+	GPatternSpec *pempat, *crtpat;
+	GList *iter = NULL;
+	GSList *crts = NULL;
+
+	if (x509_ca_initialized) return TRUE;
+
+	/* Check that X.509 is registered */
+	x509 = purple_certificate_find_scheme(x509_ca.scheme_name);
+	if ( !x509 ) {
+		purple_debug_warning("certificate/x509/ca",
+				  "Lazy init failed because an X.509 Scheme "
+				  "is not yet registered. Maybe it will be "
+				  "better later.\n");
+		return FALSE;
+	}
+
+	/* Use a glob to only read .pem files */
+	pempat = g_pattern_spec_new("*.pem");
+	crtpat = g_pattern_spec_new("*.crt");
+
+	/* Populate the certificates pool from the search path(s) */
+	for (iter = x509_ca_paths; iter; iter = iter->next) {
+		certdir = g_dir_open(iter->data, 0, NULL);
+		if (!certdir) {
+			purple_debug_error("certificate/x509/ca", "Couldn't open location '%s'\n", (const char *)iter->data);
+			continue;
+		}
+
+		while ( (entry = g_dir_read_name(certdir)) ) {
+			gchar *fullpath;
+			PurpleCertificate *crt;
+
+			if (!g_pattern_match_string(pempat, entry) && !g_pattern_match_string(crtpat, entry)) {
+				continue;
+			}
+
+			fullpath = g_build_filename(iter->data, entry, NULL);
+
+			/* TODO: Respond to a failure in the following? */
+			crts = purple_certificates_import(x509, fullpath);
+
+			while (crts && crts->data) {
+				crt = crts->data;
+				if (x509_ca_quiet_put_cert(crt)) {
+					gchar *name;
+					name = purple_certificate_get_subject_name(crt);
+					purple_debug_info("certificate/x509/ca",
+							  "Loaded %s from %s\n",
+							  name ? name : "(unknown)", fullpath);
+					g_free(name);
+				} else {
+					purple_debug_error("certificate/x509/ca",
+							  "Failed to load certificate from %s\n",
+							  fullpath);
+				}
+				purple_certificate_destroy(crt);
+				crts = g_slist_delete_link(crts, crts);
+			}
+
+			g_free(fullpath);
+		}
+		g_dir_close(certdir);
+	}
+
+	g_pattern_spec_free(pempat);
+	g_pattern_spec_free(crtpat);
+
+	purple_debug_info("certificate/x509/ca",
+			  "Lazy init completed.\n");
+	x509_ca_initialized = TRUE;
+	return TRUE;
+}
+
+static gboolean
+x509_ca_init(void)
+{
+	/* Attempt to point at the appropriate system path */
+	if (NULL == x509_ca_paths) {
+#ifdef _WIN32
+		x509_ca_paths = g_list_append(NULL, g_build_filename(DATADIR,
+						   "ca-certs", NULL));
+#else
+# ifdef SSL_CERTIFICATES_DIR
+		x509_ca_paths = g_list_append(NULL, g_strdup(SSL_CERTIFICATES_DIR));
+# endif
+		x509_ca_paths = g_list_append(x509_ca_paths,
+			g_build_filename("/media/internal", "Messaging_Certificates", NULL));
+#endif
+	}
+
+	/* Attempt to initialize now, but if it doesn't work, that's OK;
+	   it will get done later */
+	if ( ! x509_ca_lazy_init()) {
+		purple_debug_info("certificate/x509/ca",
+				  "Init failed, probably because a "
+				  "dependency is not yet registered. "
+				  "It has been deferred to later.\n");
+	}
+
+	return TRUE;
+}
+
+static void
+x509_ca_uninit(void)
+{
+	GList *l;
+
+	for (l = x509_ca_certs; l; l = l->next) {
+		x509_ca_element *el = l->data;
+		x509_ca_element_free(el);
+	}
+	g_list_free(x509_ca_certs);
+	x509_ca_certs = NULL;
+	x509_ca_initialized = FALSE;
+	g_list_foreach(x509_ca_paths, (GFunc)g_free, NULL);
+	g_list_free(x509_ca_paths);
+	x509_ca_paths = NULL;
+}
+
+/** Look up a ca_element by dn */
+static x509_ca_element *
+x509_ca_locate_cert(GList *lst, const gchar *dn)
+{
+	GList *cur;
+
+	for (cur = lst; cur; cur = cur->next) {
+		x509_ca_element *el = cur->data;
+		if (purple_strequal(dn, el->dn)) {
+			return el;
+		}
+	}
+	return NULL;
+}
+
+static GSList *
+x509_ca_locate_certs(GList *lst, const gchar *dn)
+{
+	GList *cur;
+	GSList *crts = NULL;
+
+	for (cur = lst; cur; cur = cur->next) {
+		x509_ca_element *el = cur->data;
+		if (purple_strequal(dn, el->dn)) {
+			crts = g_slist_prepend(crts, el);
+		}
+	}
+	return crts;
+}
+
+
+static gboolean
+x509_ca_cert_in_pool(const gchar *id)
+{
+	g_return_val_if_fail(x509_ca_lazy_init(), FALSE);
+	g_return_val_if_fail(id, FALSE);
+
+	if (x509_ca_locate_cert(x509_ca_certs, id) != NULL) {
+		return TRUE;
+	} else {
+		return FALSE;
+	}
+
+	return FALSE;
+}
+
+static PurpleCertificate *
+x509_ca_get_cert(const gchar *id)
+{
+	PurpleCertificate *crt = NULL;
+	x509_ca_element *el;
+
+	g_return_val_if_fail(x509_ca_lazy_init(), NULL);
+	g_return_val_if_fail(id, NULL);
+
+	/* Search the memory-cached pool */
+	el = x509_ca_locate_cert(x509_ca_certs, id);
+
+	if (el != NULL) {
+		/* Make a copy of the memcached one for the function caller
+		   to play with */
+		crt = purple_certificate_copy(el->crt);
+	} else {
+		crt = NULL;
+	}
+
+	return crt;
+}
+
+static GSList *
+x509_ca_get_certs(const gchar *id)
+{
+	GSList *crts = NULL, *els = NULL;
+
+	g_return_val_if_fail(x509_ca_lazy_init(), NULL);
+	g_return_val_if_fail(id, NULL);
+
+	/* Search the memory-cached pool */
+	els = x509_ca_locate_certs(x509_ca_certs, id);
+
+	if (els != NULL) {
+		GSList *cur;
+		/* Make a copy of the memcached ones for the function caller
+		   to play with */
+		for (cur = els; cur; cur = cur->next) {
+			x509_ca_element *el = cur->data;
+			crts = g_slist_prepend(crts, purple_certificate_copy(el->crt));
+		}
+		g_slist_free(els);
+	}
+
+	return crts;
+}
+
+static gboolean
+x509_ca_put_cert(const gchar *id, PurpleCertificate *crt)
+{
+	gboolean ret = FALSE;
+
+	g_return_val_if_fail(x509_ca_lazy_init(), FALSE);
+
+	/* TODO: This is a quick way of doing this. At some point the change
+	   ought to be flushed to disk somehow. */
+	ret = x509_ca_quiet_put_cert(crt);
+
+	return ret;
+}
+
+static gboolean
+x509_ca_delete_cert(const gchar *id)
+{
+	x509_ca_element *el;
+
+	g_return_val_if_fail(x509_ca_lazy_init(), FALSE);
+	g_return_val_if_fail(id, FALSE);
+
+	/* Is the id even in the pool? */
+	el = x509_ca_locate_cert(x509_ca_certs, id);
+	if ( el == NULL ) {
+		purple_debug_warning("certificate/x509/ca",
+				     "Id %s wasn't in the pool\n",
+				     id);
+		return FALSE;
+	}
+
+	/* Unlink it from the memory cache and destroy it */
+	x509_ca_certs = g_list_remove(x509_ca_certs, el);
+	x509_ca_element_free(el);
+
+	return TRUE;
+}
+
+static GList *
+x509_ca_get_idlist(void)
+{
+	GList *l, *idlist;
+
+	g_return_val_if_fail(x509_ca_lazy_init(), NULL);
+
+	idlist = NULL;
+	for (l = x509_ca_certs; l; l = l->next) {
+		x509_ca_element *el = l->data;
+		idlist = g_list_prepend(idlist, g_strdup(el->dn));
+	}
+
+	return idlist;
+}
+
+
+static PurpleCertificatePool x509_ca = {
+	"x509",                       /* Scheme name */
+	"ca",                         /* Pool name */
+	N_("Certificate Authorities"),/* User-friendly name */
+	NULL,                         /* Internal data */
+	x509_ca_init,                 /* init */
+	x509_ca_uninit,               /* uninit */
+	x509_ca_cert_in_pool,         /* Certificate exists? */
+	x509_ca_get_cert,             /* Cert retriever */
+	x509_ca_put_cert,             /* Cert writer */
+	x509_ca_delete_cert,          /* Cert remover */
+	x509_ca_get_idlist,           /* idlist retriever */
+
+	NULL,
+	NULL,
+	NULL,
+	NULL
+
+};
+
+
+
+/***** Cache of certificates given by TLS/SSL peers *****/
+static PurpleCertificatePool x509_tls_peers;
+
+static gboolean
+x509_tls_peers_init(void)
+{
+	gchar *poolpath;
+	int ret;
+
+	/* Set up key cache here if it isn't already done */
+	poolpath = purple_certificate_pool_mkpath(&x509_tls_peers, NULL);
+	ret = purple_build_dir(poolpath, 0700); /* Make it this user only */
+
+	if (ret != 0)
+		purple_debug_info("certificate/tls_peers",
+				"Could not create %s.  Certificates will not be cached.\n",
+				poolpath);
+
+	g_free(poolpath);
+
+	return TRUE;
+}
+
+static gboolean
+x509_tls_peers_cert_in_pool(const gchar *id)
+{
+	gchar *keypath;
+	gboolean ret = FALSE;
+
+	g_return_val_if_fail(id, FALSE);
+
+	keypath = purple_certificate_pool_mkpath(&x509_tls_peers, id);
+
+	ret = g_file_test(keypath, G_FILE_TEST_IS_REGULAR);
+
+	g_free(keypath);
+	return ret;
+}
+
+static PurpleCertificate *
+x509_tls_peers_get_cert(const gchar *id)
+{
+	PurpleCertificateScheme *x509;
+	PurpleCertificate *crt;
+	gchar *keypath;
+
+	g_return_val_if_fail(id, NULL);
+
+	/* Is it in the pool? */
+	if ( !x509_tls_peers_cert_in_pool(id) ) {
+		return NULL;
+	}
+
+	/* Look up the X.509 scheme */
+	x509 = purple_certificate_find_scheme("x509");
+	g_return_val_if_fail(x509, NULL);
+
+	/* Okay, now find and load that key */
+	keypath = purple_certificate_pool_mkpath(&x509_tls_peers, id);
+	crt = purple_certificate_import(x509, keypath);
+
+	g_free(keypath);
+
+	return crt;
+}
+
+static gboolean
+x509_tls_peers_put_cert(const gchar *id, PurpleCertificate *crt)
+{
+	gboolean ret = FALSE;
+	gchar *keypath;
+
+	g_return_val_if_fail(crt, FALSE);
+	g_return_val_if_fail(crt->scheme, FALSE);
+	/* Make sure that this is some kind of X.509 certificate */
+	/* TODO: Perhaps just check crt->scheme->name instead? */
+	g_return_val_if_fail(crt->scheme == purple_certificate_find_scheme(x509_tls_peers.scheme_name), FALSE);
+
+	/* Work out the filename and export */
+	keypath = purple_certificate_pool_mkpath(&x509_tls_peers, id);
+	ret = purple_certificate_export(keypath, crt);
+
+	g_free(keypath);
+	return ret;
+}
+
+static gboolean
+x509_tls_peers_delete_cert(const gchar *id)
+{
+	gboolean ret = FALSE;
+	gchar *keypath;
+
+	g_return_val_if_fail(id, FALSE);
+
+	/* Is the id even in the pool? */
+	if (!x509_tls_peers_cert_in_pool(id)) {
+		purple_debug_warning("certificate/tls_peers",
+				     "Id %s wasn't in the pool\n",
+				     id);
+		return FALSE;
+	}
+
+	/* OK, so work out the keypath and delete the thing */
+	keypath = purple_certificate_pool_mkpath(&x509_tls_peers, id);
+	if ( unlink(keypath) != 0 ) {
+		purple_debug_error("certificate/tls_peers",
+				   "Unlink of %s failed!\n",
+				   keypath);
+		ret = FALSE;
+	} else {
+		ret = TRUE;
+	}
+
+	g_free(keypath);
+	return ret;
+}
+
+static GList *
+x509_tls_peers_get_idlist(void)
+{
+	GList *idlist = NULL;
+	GDir *dir;
+	const gchar *entry;
+	gchar *poolpath;
+
+	/* Get a handle on the pool directory */
+	poolpath = purple_certificate_pool_mkpath(&x509_tls_peers, NULL);
+	dir = g_dir_open(poolpath,
+			 0,     /* No flags */
+			 NULL); /* Not interested in what the error is */
+	g_free(poolpath);
+
+	g_return_val_if_fail(dir, NULL);
+
+	/* Traverse the directory listing and create an idlist */
+	while ( (entry = g_dir_read_name(dir)) != NULL ) {
+		/* Unescape the filename */
+		const char *unescaped = purple_unescape_filename(entry);
+
+		/* Copy the entry name into our list (GLib owns the original
+		   string) */
+		idlist = g_list_prepend(idlist, g_strdup(unescaped));
+	}
+
+	/* Release the directory */
+	g_dir_close(dir);
+
+	return idlist;
+}
+
+static PurpleCertificatePool x509_tls_peers = {
+	"x509",                       /* Scheme name */
+	"tls_peers",                  /* Pool name */
+	N_("SSL Peers Cache"),        /* User-friendly name */
+	NULL,                         /* Internal data */
+	x509_tls_peers_init,          /* init */
+	NULL,                         /* uninit not required */
+	x509_tls_peers_cert_in_pool,  /* Certificate exists? */
+	x509_tls_peers_get_cert,      /* Cert retriever */
+	x509_tls_peers_put_cert,      /* Cert writer */
+	x509_tls_peers_delete_cert,   /* Cert remover */
+	x509_tls_peers_get_idlist,    /* idlist retriever */
+
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+
+/***** A Verifier that uses the tls_peers cache and the CA pool to validate certificates *****/
+static PurpleCertificateVerifier x509_tls_cached;
+
+
+/* The following is several hacks piled together and needs to be fixed.
+ * It exists because show_cert (see its comments) needs the original reason
+ * given to user_auth in order to rebuild the dialog.
+ */
+/* TODO: This will cause a ua_ctx to become memleaked if the request(s) get
+   closed by handle or otherwise abnormally. */
+typedef struct {
+	PurpleCertificateVerificationRequest *vrq;
+	gchar *reason;
+} x509_tls_cached_ua_ctx;
+
+static x509_tls_cached_ua_ctx *
+x509_tls_cached_ua_ctx_new(PurpleCertificateVerificationRequest *vrq,
+			   const gchar *reason)
+{
+	x509_tls_cached_ua_ctx *c;
+
+	c = g_new0(x509_tls_cached_ua_ctx, 1);
+	c->vrq = vrq;
+	c->reason = g_strdup(reason);
+
+	return c;
+}
+
+
+static void
+x509_tls_cached_ua_ctx_free(x509_tls_cached_ua_ctx *c)
+{
+	g_return_if_fail(c);
+	g_free(c->reason);
+	g_free(c);
+}
+
+static void
+x509_tls_cached_user_auth(PurpleCertificateVerificationRequest *vrq,
+			  const gchar *reason);
+
+static void
+x509_tls_cached_show_cert(x509_tls_cached_ua_ctx *c, gint id)
+{
+	PurpleCertificate *disp_crt = c->vrq->cert_chain->data;
+
+	/* Since clicking a button closes the request, show it again */
+	x509_tls_cached_user_auth(c->vrq, c->reason);
+
+	/* Show the certificate AFTER re-opening the dialog so that this
+	   appears above the other */
+	purple_certificate_display_x509(disp_crt);
+
+	x509_tls_cached_ua_ctx_free(c);
+}
+
+static void
+x509_tls_cached_user_auth_cb (x509_tls_cached_ua_ctx *c, gint id)
+{
+	PurpleCertificateVerificationRequest *vrq;
+	PurpleCertificatePool *tls_peers;
+
+	g_return_if_fail(c);
+	g_return_if_fail(c->vrq);
+
+	vrq = c->vrq;
+
+	x509_tls_cached_ua_ctx_free(c);
+
+	tls_peers = purple_certificate_find_pool("x509","tls_peers");
+
+	if (2 == id) {
+		gchar *cache_id = vrq->subject_name;
+		purple_debug_info("certificate/x509/tls_cached",
+				  "User ACCEPTED cert\nCaching first in chain for future use as %s...\n",
+				  cache_id);
+
+		purple_certificate_pool_store(tls_peers, cache_id,
+					      vrq->cert_chain->data);
+
+		purple_certificate_verify_complete(vrq,
+						   PURPLE_CERTIFICATE_VALID);
+	} else {
+		purple_debug_warning("certificate/x509/tls_cached",
+				  "User REJECTED cert\n");
+		purple_certificate_verify_complete(vrq,
+						   PURPLE_CERTIFICATE_INVALID);
+	}
+}
+
+static void
+x509_tls_cached_user_auth_accept_cb(x509_tls_cached_ua_ctx *c, gint ignore)
+{
+	x509_tls_cached_user_auth_cb(c, 2);
+}
+
+static void
+x509_tls_cached_user_auth_reject_cb(x509_tls_cached_ua_ctx *c, gint ignore)
+{
+	x509_tls_cached_user_auth_cb(c, 1);
+}
+
+/** Validates a certificate by asking the user
+ * @param reason    String to explain why the user needs to accept/refuse the
+ *                  certificate.
+ * @todo Needs a handle argument
+ */
+static void
+x509_tls_cached_user_auth(PurpleCertificateVerificationRequest *vrq,
+			  const gchar *reason)
+{
+	const char *acceptbadcert;
+	acceptbadcert = purple_prefs_get_string("/purple/acceptbadcert");
+
+	if (acceptbadcert != NULL)
+	{
+		purple_debug_warning("certificate/x509/tls_cached", "Certificate Error. Accepting as requested!\n");
+		purple_prefs_remove("/purple/acceptbadcert");
+
+		//Dodgy Cert Acceptance
+		x509_tls_cached_user_auth_accept_cb(x509_tls_cached_ua_ctx_new(vrq, reason),2);
+	}
+	else
+	{
+		purple_debug_warning("certificate/x509/tls_cached", "Certificate Error. Rejecting as requested!\n");
+
+		//Reject Bad Certificate
+		x509_tls_cached_user_auth_reject_cb(x509_tls_cached_ua_ctx_new(vrq, reason),1);
+	}
+}
+
+static void
+x509_tls_cached_unknown_peer(PurpleCertificateVerificationRequest *vrq,
+                             PurpleCertificateInvalidityFlags flags);
+
+static void
+x509_tls_cached_complete(PurpleCertificateVerificationRequest *vrq,
+                         PurpleCertificateInvalidityFlags flags)
+{
+	PurpleCertificatePool *tls_peers;
+	PurpleCertificate *peer_crt = vrq->cert_chain->data;
+
+	if (flags & PURPLE_CERTIFICATE_FATALS_MASK) {
+		/* TODO: Also print any other warnings? */
+		const gchar *error;
+		gchar *tmp, *secondary;
+
+		if (flags & PURPLE_CERTIFICATE_INVALID_CHAIN)
+			error = invalidity_reason_to_string(PURPLE_CERTIFICATE_INVALID_CHAIN);
+		else if (flags & PURPLE_CERTIFICATE_REVOKED)
+			error = invalidity_reason_to_string(PURPLE_CERTIFICATE_REVOKED);
+		else
+			error = invalidity_reason_to_string(PURPLE_CERTIFICATE_UNKNOWN_ERROR);
+
+		tmp = g_strdup_printf(_("The certificate for %s could not be validated."),
+					vrq->subject_name);
+		secondary = g_strconcat(tmp, " ", error, NULL);
+		g_free(tmp);
+
+		purple_notify_error(NULL, /* TODO: Probably wrong. */
+					_("SSL Certificate Error"),
+					_("Unable to validate certificate"),
+					secondary);
+		g_free(secondary);
+
+		purple_certificate_verify_complete(vrq, PURPLE_CERTIFICATE_INVALID);
+		return;
+	} else if (flags & PURPLE_CERTIFICATE_NON_FATALS_MASK) {
+		/* Non-fatal error. Prompt the user. */
+		gchar *tmp;
+		GString *errors;
+		guint32 i = 1;
+
+		tmp = g_strdup_printf(_("The certificate for %s could not be validated."),
+					vrq->subject_name);
+		errors = g_string_new(tmp);
+		g_free(tmp);
+
+		errors = g_string_append_c(errors, '\n');
+
+		/* Special case a name mismatch because we want to display the two names... */
+		if (flags & PURPLE_CERTIFICATE_NAME_MISMATCH) {
+			gchar *sn = purple_certificate_get_subject_name(peer_crt);
+
+			if (sn) {
+				g_string_append_printf(errors, _("The certificate claims to be "
+							"from \"%s\" instead. This could mean that you are "
+							"not connecting to the service you believe you are."),
+							sn);
+				g_free(sn);
+
+				flags &= ~PURPLE_CERTIFICATE_NAME_MISMATCH;
+			}
+		}
+
+		while (i != PURPLE_CERTIFICATE_LAST) {
+			if (flags & i) {
+				errors = g_string_append_c(errors, '\n');
+				g_string_append(errors, invalidity_reason_to_string(i));
+			}
+
+			i <<= 1;
+		}
+
+		x509_tls_cached_user_auth(vrq, errors->str);
+		g_string_free(errors, TRUE);
+		return;
+	}
+
+	/* If we reach this point, the certificate is good. */
+
+	/* Look up the local cache and store it there for future use */
+	tls_peers = purple_certificate_find_pool(x509_tls_cached.scheme_name,
+						 "tls_peers");
+	if (tls_peers) {
+		if (!purple_certificate_pool_store(tls_peers,vrq->subject_name,
+		                                   peer_crt)) {
+			purple_debug_error("certificate/x509/tls_cached",
+			                   "FAILED to cache peer certificate\n");
+		}
+	} else {
+		purple_debug_error("certificate/x509/tls_cached",
+		                   "Unable to locate tls_peers certificate cache.\n");
+	}
+
+	purple_certificate_verify_complete(vrq, PURPLE_CERTIFICATE_VALID);
+}
+
+static void
+x509_tls_cached_cert_in_cache(PurpleCertificateVerificationRequest *vrq,
+                              PurpleCertificateInvalidityFlags flags)
+{
+	/* TODO: Looking this up by name over and over is expensive.
+	   Fix, please! */
+	PurpleCertificatePool *tls_peers =
+		purple_certificate_find_pool(x509_tls_cached.scheme_name,
+					     "tls_peers");
+
+	/* The peer's certificate should be the first in the list */
+	PurpleCertificate *peer_crt =
+		(PurpleCertificate *) vrq->cert_chain->data;
+
+	PurpleCertificate *cached_crt;
+	GByteArray *peer_fpr, *cached_fpr;
+
+	/* Load up the cached certificate */
+	cached_crt = purple_certificate_pool_retrieve(
+		tls_peers, vrq->subject_name);
+	if ( !cached_crt ) {
+		purple_debug_warning("certificate/x509/tls_cached",
+				   "Lookup failed on cached certificate!\n"
+				   "Falling back to full verification.\n");
+		/* vrq now becomes the problem of unknown_peer */
+		x509_tls_cached_unknown_peer(vrq, flags);
+		return;
+	}
+
+	/* Now get SHA1 sums for both and compare them */
+	/* TODO: This is not an elegant way to compare certs */
+	peer_fpr = purple_certificate_get_fingerprint_sha1(peer_crt);
+	cached_fpr = purple_certificate_get_fingerprint_sha1(cached_crt);
+	if (!memcmp(peer_fpr->data, cached_fpr->data, peer_fpr->len)) {
+		purple_debug_info("certificate/x509/tls_cached",
+				  "Peer cert matched cached\n");
+		x509_tls_cached_complete(vrq, flags);
+	} else {
+		purple_debug_error("certificate/x509/tls_cached",
+				  "Peer cert did NOT match cached\n");
+		/* vrq now becomes the problem of the user */
+		x509_tls_cached_unknown_peer(vrq, flags);
+	}
+
+	purple_certificate_destroy(cached_crt);
+	g_byte_array_free(peer_fpr, TRUE);
+	g_byte_array_free(cached_fpr, TRUE);
+}
+
+/*
+ * This is called from two points in x509_tls_cached_unknown_peer below
+ * once we've verified the signature chain is valid. Now we need to verify
+ * the subject name of the certificate.
+ */
+static void
+x509_tls_cached_check_subject_name(PurpleCertificateVerificationRequest *vrq,
+                                   PurpleCertificateInvalidityFlags flags)
+{
+	PurpleCertificate *peer_crt;
+	GList *chain = vrq->cert_chain;
+
+	peer_crt = (PurpleCertificate *) chain->data;
+
+	/* Last, check that the hostname matches */
+	if ( ! purple_certificate_check_subject_name(peer_crt,
+						     vrq->subject_name) ) {
+		gchar *sn = purple_certificate_get_subject_name(peer_crt);
+
+		flags |= PURPLE_CERTIFICATE_NAME_MISMATCH;
+		purple_debug_error("certificate/x509/tls_cached",
+				  "Name mismatch: Certificate given for %s "
+				  "has a name of %s\n",
+				  vrq->subject_name, sn);
+		g_free(sn);
+	}
+
+	x509_tls_cached_complete(vrq, flags);
+}
+
+/* For when we've never communicated with this party before */
+/* TODO: Need ways to specify possibly multiple problems with a cert, or at
+   least  reprioritize them.
+ */
+static void
+x509_tls_cached_unknown_peer(PurpleCertificateVerificationRequest *vrq,
+                             PurpleCertificateInvalidityFlags flags)
+{
+	PurpleCertificatePool *ca;
+	PurpleCertificate *peer_crt;
+	PurpleCertificate *ca_crt, *end_crt;
+	PurpleCertificate *failing_crt;
+	GList *chain = vrq->cert_chain;
+	GSList *ca_crts, *cur;
+	GByteArray *last_fpr, *ca_fpr;
+	gboolean valid = FALSE;
+	gchar *ca_id;
+
+	peer_crt = (PurpleCertificate *) chain->data;
+
+	/* TODO: Figure out a way to check for a bad signature, as opposed to
+	   "not self-signed" */
+	if ( purple_certificate_signed_by(peer_crt, peer_crt) ) {
+		flags |= PURPLE_CERTIFICATE_SELF_SIGNED;
+
+		purple_debug_info("certificate/x509/tls_cached",
+				  "Certificate for %s is self-signed.\n",
+				  vrq->subject_name);
+
+		x509_tls_cached_check_subject_name(vrq, flags);
+		return;
+	} /* if (self signed) */
+
+	/* Next, attempt to verify the last certificate against a CA */
+	ca = purple_certificate_find_pool(x509_tls_cached.scheme_name, "ca");
+
+	/* Next, check that the certificate chain is valid */
+	if (!purple_certificate_check_signature_chain_with_failing(chain,
+				&failing_crt))
+	{
+		gboolean chain_validated = FALSE;
+		/*
+		 * Check if the failing certificate is in the CA store. If it is, then
+		 * consider this fully validated. This works around issues with some
+		 * prominent intermediate CAs whose signature is md5WithRSAEncryption.
+		 * I'm looking at CACert Class 3 here. See #4458 for details.
+		 */
+		if (ca) {
+			gchar *uid = purple_certificate_get_unique_id(failing_crt);
+			PurpleCertificate *ca_crt = purple_certificate_pool_retrieve(ca, uid);
+			if (ca_crt != NULL) {
+				GByteArray *failing_fpr;
+				GByteArray *ca_fpr;
+				failing_fpr = purple_certificate_get_fingerprint_sha1(failing_crt);
+				ca_fpr = purple_certificate_get_fingerprint_sha1(ca_crt);
+				if (byte_arrays_equal(failing_fpr, ca_fpr)) {
+					purple_debug_info("certificate/x509/tls_cached",
+							"Full chain verification failed (probably a bad "
+							"signature algorithm), but found the last "
+							"certificate %s in the CA pool.\n", uid);
+					chain_validated = TRUE;
+				}
+
+				g_byte_array_free(failing_fpr, TRUE);
+				g_byte_array_free(ca_fpr, TRUE);
+			}
+
+			purple_certificate_destroy(ca_crt);
+			g_free(uid);
+		}
+
+		/*
+		 * If we get here, either the cert matched the stuff right above
+		 * or it didn't, in which case we give up and complain to the user.
+		 */
+		if (!chain_validated)
+			/* TODO: Tell the user where the chain broke? */
+			flags |= PURPLE_CERTIFICATE_INVALID_CHAIN;
+
+		x509_tls_cached_check_subject_name(vrq, flags);
+		return;
+	} /* if (signature chain not good) */
+
+	/* If, for whatever reason, there is no Certificate Authority pool
+	   loaded, we'll verify the subject name and then warn about thsi. */
+	if ( !ca ) {
+		purple_debug_error("certificate/x509/tls_cached",
+				   "No X.509 Certificate Authority pool "
+				   "could be found!\n");
+
+		flags |= PURPLE_CERTIFICATE_NO_CA_POOL;
+
+		x509_tls_cached_check_subject_name(vrq, flags);
+		return;
+	}
+
+	end_crt = g_list_last(chain)->data;
+
+	/* Attempt to look up the last certificate's issuer */
+	ca_id = purple_certificate_get_issuer_unique_id(end_crt);
+	purple_debug_info("certificate/x509/tls_cached",
+			  "Checking for a CA with DN=%s\n",
+			  ca_id);
+	ca_crts = x509_ca_get_certs(ca_id);
+	if ( NULL == ca_crts ) {
+		flags |= PURPLE_CERTIFICATE_CA_UNKNOWN;
+
+		purple_debug_warning("certificate/x509/tls_cached",
+				  "Certificate Authority with DN='%s' not "
+				  "found. I'll prompt the user, I guess.\n",
+				  ca_id);
+		g_free(ca_id);
+
+		x509_tls_cached_check_subject_name(vrq, flags);
+		return;
+	}
+
+	g_free(ca_id);
+
+	/*
+	 * Check the fingerprints; if they match, then this certificate *is* one
+	 * of the designated "trusted roots", and we don't need to verify the
+	 * signature. This is good because some of the older roots are self-signed
+	 * with bad hash algorithms that we don't want to allow in any other
+	 * circumstances (one of Verisign's root CAs is self-signed with MD2).
+	 *
+	 * If the fingerprints don't match, we'll fall back to checking the
+	 * signature.
+	 *
+	 * GnuTLS doesn't seem to include the final root in the verification
+	 * list, so this check will never succeed.  NSS *does* include it in
+	 * the list, so here we are.
+	 */
+	last_fpr = purple_certificate_get_fingerprint_sha1(end_crt);
+	for (cur = ca_crts; cur; cur = cur->next) {
+		ca_crt = cur->data;
+		ca_fpr = purple_certificate_get_fingerprint_sha1(ca_crt);
+
+		if ( byte_arrays_equal(last_fpr, ca_fpr) ||
+				purple_certificate_signed_by(end_crt, ca_crt) )
+		{
+			/* TODO: If signed_by ever returns a reason, maybe mention
+			   that, too. */
+			/* TODO: Also mention the CA involved. While I could do this
+			   now, a full DN is a little much with which to assault the
+			   user's poor, leaky eyes. */
+			valid = TRUE;
+			g_byte_array_free(ca_fpr, TRUE);
+			break;
+		}
+
+		g_byte_array_free(ca_fpr, TRUE);
+	}
+
+	if (valid == FALSE)
+		flags |= PURPLE_CERTIFICATE_INVALID_CHAIN;
+
+	g_slist_foreach(ca_crts, (GFunc)purple_certificate_destroy, NULL);
+	g_slist_free(ca_crts);
+	g_byte_array_free(last_fpr, TRUE);
+
+	x509_tls_cached_check_subject_name(vrq, flags);
+}
+
+static void
+x509_tls_cached_start_verify(PurpleCertificateVerificationRequest *vrq)
+{
+	const gchar *tls_peers_name = "tls_peers"; /* Name of local cache */
+	PurpleCertificatePool *tls_peers;
+	time_t now, activation, expiration;
+	PurpleCertificateInvalidityFlags flags = PURPLE_CERTIFICATE_NO_PROBLEMS;
+	gboolean ret;
+
+	g_return_if_fail(vrq);
+
+	purple_debug_info("certificate/x509/tls_cached",
+			  "Starting verify for %s\n",
+			  vrq->subject_name);
+
+	/*
+	 * Verify the first certificate (the main one) has been activated and
+	 * isn't expired, i.e. activation < now < expiration.
+	 */
+	now = time(NULL);
+	ret = purple_certificate_get_times(vrq->cert_chain->data, &activation,
+	                                   &expiration);
+	if (!ret) {
+		flags |= PURPLE_CERTIFICATE_EXPIRED | PURPLE_CERTIFICATE_NOT_ACTIVATED;
+		purple_debug_error("certificate/x509/tls_cached",
+				"Failed to get validity times for certificate %s\n",
+				vrq->subject_name);
+	} else if (now > expiration) {
+		flags |= PURPLE_CERTIFICATE_EXPIRED;
+		purple_debug_error("certificate/x509/tls_cached",
+				"Certificate %s expired at %s\n",
+				vrq->subject_name, ctime(&expiration));
+	} else if (now < activation) {
+		flags |= PURPLE_CERTIFICATE_NOT_ACTIVATED;
+		purple_debug_error("certificate/x509/tls_cached",
+				"Certificate %s is not yet valid, will be at %s\n",
+				vrq->subject_name, ctime(&activation));
+	}
+
+	tls_peers = purple_certificate_find_pool(x509_tls_cached.scheme_name,tls_peers_name);
+
+	if (!tls_peers) {
+		purple_debug_error("certificate/x509/tls_cached",
+				   "Couldn't find local peers cache %s\n",
+				   tls_peers_name);
+
+		/* vrq now becomes the problem of unknown_peer */
+		x509_tls_cached_unknown_peer(vrq, flags);
+		return;
+	}
+
+	/* Check if the peer has a certificate cached already */
+	purple_debug_info("certificate/x509/tls_cached",
+			  "Checking for cached cert...\n");
+	if (purple_certificate_pool_contains(tls_peers, vrq->subject_name)) {
+		purple_debug_info("certificate/x509/tls_cached",
+				  "...Found cached cert\n");
+		/* vrq is now the responsibility of cert_in_cache */
+		x509_tls_cached_cert_in_cache(vrq, flags);
+	} else {
+		purple_debug_warning("certificate/x509/tls_cached",
+				  "...Not in cache\n");
+		/* vrq now becomes the problem of unknown_peer */
+		x509_tls_cached_unknown_peer(vrq, flags);
+	}
+}
+
+static void
+x509_tls_cached_destroy_request(PurpleCertificateVerificationRequest *vrq)
+{
+	g_return_if_fail(vrq);
+}
+
+static PurpleCertificateVerifier x509_tls_cached = {
+	"x509",                         /* Scheme name */
+	"tls_cached",                   /* Verifier name */
+	x509_tls_cached_start_verify,   /* Verification begin */
+	x509_tls_cached_destroy_request,/* Request cleanup */
+
+	NULL,
+	NULL,
+	NULL,
+	NULL
+
+};
+
+/****************************************************************************/
+/* Subsystem                                                                */
+/****************************************************************************/
+void
+purple_certificate_init(void)
+{
+	/* Register builtins */
+	purple_certificate_register_verifier(&x509_singleuse);
+	purple_certificate_register_pool(&x509_ca);
+	purple_certificate_register_pool(&x509_tls_peers);
+	purple_certificate_register_verifier(&x509_tls_cached);
+}
+
+void
+purple_certificate_uninit(void)
+{
+	/* Unregister all Verifiers */
+	g_list_foreach(cert_verifiers, (GFunc)purple_certificate_unregister_verifier, NULL);
+
+	/* Unregister all Pools */
+	g_list_foreach(cert_pools, (GFunc)purple_certificate_unregister_pool, NULL);
+}
+
+gpointer
+purple_certificate_get_handle(void)
+{
+	static gint handle;
+	return &handle;
+}
+
+PurpleCertificateScheme *
+purple_certificate_find_scheme(const gchar *name)
+{
+	PurpleCertificateScheme *scheme = NULL;
+	GList *l;
+
+	g_return_val_if_fail(name, NULL);
+
+	/* Traverse the list of registered schemes and locate the
+	   one whose name matches */
+	for(l = cert_schemes; l; l = l->next) {
+		scheme = (PurpleCertificateScheme *)(l->data);
+
+		/* Name matches? that's our man */
+		if(!g_ascii_strcasecmp(scheme->name, name))
+			return scheme;
+	}
+
+	purple_debug_warning("certificate",
+			     "CertificateScheme %s requested but not found.\n",
+			     name);
+
+	/* TODO: Signalling and such? */
+
+	return NULL;
+}
+
+GList *
+purple_certificate_get_schemes(void)
+{
+	return cert_schemes;
+}
+
+gboolean
+purple_certificate_register_scheme(PurpleCertificateScheme *scheme)
+{
+	g_return_val_if_fail(scheme != NULL, FALSE);
+
+	/* Make sure no scheme is registered with the same name */
+	if (purple_certificate_find_scheme(scheme->name) != NULL) {
+		return FALSE;
+	}
+
+	/* Okay, we're golden. Register it. */
+	cert_schemes = g_list_prepend(cert_schemes, scheme);
+
+	/* TODO: Signalling and such? */
+
+	purple_debug_info("certificate",
+			  "CertificateScheme %s registered\n",
+			  scheme->name);
+
+	return TRUE;
+}
+
+gboolean
+purple_certificate_unregister_scheme(PurpleCertificateScheme *scheme)
+{
+	if (NULL == scheme) {
+		purple_debug_warning("certificate",
+				     "Attempting to unregister NULL scheme\n");
+		return FALSE;
+	}
+
+	/* TODO: signalling? */
+
+	/* TODO: unregister all CertificateVerifiers for this scheme?*/
+	/* TODO: unregister all CertificatePools for this scheme? */
+	/* Neither of the above should be necessary, though */
+	cert_schemes = g_list_remove(cert_schemes, scheme);
+
+	purple_debug_info("certificate",
+			  "CertificateScheme %s unregistered\n",
+			  scheme->name);
+
+
+	return TRUE;
+}
+
+PurpleCertificateVerifier *
+purple_certificate_find_verifier(const gchar *scheme_name, const gchar *ver_name)
+{
+	PurpleCertificateVerifier *vr = NULL;
+	GList *l;
+
+	g_return_val_if_fail(scheme_name, NULL);
+	g_return_val_if_fail(ver_name, NULL);
+
+	/* Traverse the list of registered verifiers and locate the
+	   one whose name matches */
+	for(l = cert_verifiers; l; l = l->next) {
+		vr = (PurpleCertificateVerifier *)(l->data);
+
+		/* Scheme and name match? */
+		if(!g_ascii_strcasecmp(vr->scheme_name, scheme_name) &&
+		   !g_ascii_strcasecmp(vr->name, ver_name))
+			return vr;
+	}
+
+	purple_debug_warning("certificate",
+			     "CertificateVerifier %s, %s requested but not found.\n",
+			     scheme_name, ver_name);
+
+	/* TODO: Signalling and such? */
+
+	return NULL;
+}
+
+
+GList *
+purple_certificate_get_verifiers(void)
+{
+	return cert_verifiers;
+}
+
+gboolean
+purple_certificate_register_verifier(PurpleCertificateVerifier *vr)
+{
+	g_return_val_if_fail(vr != NULL, FALSE);
+
+	/* Make sure no verifier is registered with the same scheme/name */
+	if (purple_certificate_find_verifier(vr->scheme_name, vr->name) != NULL) {
+		return FALSE;
+	}
+
+	/* Okay, we're golden. Register it. */
+	cert_verifiers = g_list_prepend(cert_verifiers, vr);
+
+	/* TODO: Signalling and such? */
+
+	purple_debug_info("certificate",
+			  "CertificateVerifier %s registered\n",
+			  vr->name);
+	return TRUE;
+}
+
+gboolean
+purple_certificate_unregister_verifier(PurpleCertificateVerifier *vr)
+{
+	if (NULL == vr) {
+		purple_debug_warning("certificate",
+				     "Attempting to unregister NULL verifier\n");
+		return FALSE;
+	}
+
+	/* TODO: signalling? */
+
+	cert_verifiers = g_list_remove(cert_verifiers, vr);
+
+
+	purple_debug_info("certificate",
+			  "CertificateVerifier %s unregistered\n",
+			  vr->name);
+
+	return TRUE;
+}
+
+PurpleCertificatePool *
+purple_certificate_find_pool(const gchar *scheme_name, const gchar *pool_name)
+{
+	PurpleCertificatePool *pool = NULL;
+	GList *l;
+
+	g_return_val_if_fail(scheme_name, NULL);
+	g_return_val_if_fail(pool_name, NULL);
+
+	/* Traverse the list of registered pools and locate the
+	   one whose name matches */
+	for(l = cert_pools; l; l = l->next) {
+		pool = (PurpleCertificatePool *)(l->data);
+
+		/* Scheme and name match? */
+		if(!g_ascii_strcasecmp(pool->scheme_name, scheme_name) &&
+		   !g_ascii_strcasecmp(pool->name, pool_name))
+			return pool;
+	}
+
+	purple_debug_warning("certificate",
+			     "CertificatePool %s, %s requested but not found.\n",
+			     scheme_name, pool_name);
+
+	/* TODO: Signalling and such? */
+
+	return NULL;
+
+}
+
+GList *
+purple_certificate_get_pools(void)
+{
+	return cert_pools;
+}
+
+gboolean
+purple_certificate_register_pool(PurpleCertificatePool *pool)
+{
+	g_return_val_if_fail(pool, FALSE);
+	g_return_val_if_fail(pool->scheme_name, FALSE);
+	g_return_val_if_fail(pool->name, FALSE);
+	g_return_val_if_fail(pool->fullname, FALSE);
+
+	/* Make sure no pools are registered under this name */
+	if (purple_certificate_find_pool(pool->scheme_name, pool->name)) {
+		return FALSE;
+	}
+
+	/* Initialize the pool if needed */
+	if (pool->init) {
+		gboolean success;
+
+		success = pool->init();
+		if (!success)
+			return FALSE;
+	}
+
+	/* Register the Pool */
+	cert_pools = g_list_prepend(cert_pools, pool);
+
+	/* TODO: Emit a signal that the pool got registered */
+
+	PURPLE_DBUS_REGISTER_POINTER(pool, PurpleCertificatePool);
+	purple_signal_register(pool, /* Signals emitted from pool */
+			       "certificate-stored",
+			       purple_marshal_VOID__POINTER_POINTER,
+			       NULL, /* No callback return value */
+			       2,    /* Two non-data arguments */
+			       purple_value_new(PURPLE_TYPE_SUBTYPE,
+						PURPLE_SUBTYPE_CERTIFICATEPOOL),
+			       purple_value_new(PURPLE_TYPE_STRING));
+
+	purple_signal_register(pool, /* Signals emitted from pool */
+			       "certificate-deleted",
+			       purple_marshal_VOID__POINTER_POINTER,
+			       NULL, /* No callback return value */
+			       2,    /* Two non-data arguments */
+			       purple_value_new(PURPLE_TYPE_SUBTYPE,
+						PURPLE_SUBTYPE_CERTIFICATEPOOL),
+			       purple_value_new(PURPLE_TYPE_STRING));
+
+	purple_debug_info("certificate",
+		  "CertificatePool %s registered\n",
+		  pool->name);
+
+	return TRUE;
+}
+
+gboolean
+purple_certificate_unregister_pool(PurpleCertificatePool *pool)
+{
+	if (NULL == pool) {
+		purple_debug_warning("certificate",
+				     "Attempting to unregister NULL pool\n");
+		return FALSE;
+	}
+
+	/* Check that the pool is registered */
+	if (!g_list_find(cert_pools, pool)) {
+		purple_debug_warning("certificate",
+				     "Pool to unregister isn't registered!\n");
+
+		return FALSE;
+	}
+
+	/* Uninit the pool if needed */
+	PURPLE_DBUS_UNREGISTER_POINTER(pool);
+	if (pool->uninit) {
+		pool->uninit();
+	}
+
+	cert_pools = g_list_remove(cert_pools, pool);
+
+	/* TODO: Signalling? */
+	purple_signal_unregister(pool, "certificate-stored");
+	purple_signal_unregister(pool, "certificate-deleted");
+
+	purple_debug_info("certificate",
+			  "CertificatePool %s unregistered\n",
+			  pool->name);
+	return TRUE;
+}
+
+/****************************************************************************/
+/* Scheme-specific functions                                                */
+/****************************************************************************/
+
+void
+purple_certificate_display_x509(PurpleCertificate *crt)
+{
+	gchar *sha_asc;
+	GByteArray *sha_bin;
+	gchar *cn;
+	time_t activation, expiration;
+	gchar *activ_str, *expir_str;
+	gchar *secondary;
+
+	/* Pull out the SHA1 checksum */
+	sha_bin = purple_certificate_get_fingerprint_sha1(crt);
+	/* Now decode it for display */
+	sha_asc = purple_base16_encode_chunked(sha_bin->data,
+					       sha_bin->len);
+
+	/* Get the cert Common Name */
+	/* TODO: Will break on CA certs */
+	cn = purple_certificate_get_subject_name(crt);
+
+	/* Get the certificate times */
+	/* TODO: Check the times against localtime */
+	/* TODO: errorcheck? */
+	if (!purple_certificate_get_times(crt, &activation, &expiration)) {
+		purple_debug_error("certificate",
+				   "Failed to get certificate times!\n");
+		activation = expiration = 0;
+	}
+	activ_str = g_strdup(ctime(&activation));
+	expir_str = g_strdup(ctime(&expiration));
+
+	/* Make messages */
+	secondary = g_strdup_printf(_("Common name: %s\n\n"
+								  "Fingerprint (SHA1): %s\n\n"
+								  "Activation date: %s\n"
+								  "Expiration date: %s\n"),
+								cn ? cn : "(null)",
+								sha_asc ? sha_asc : "(null)",
+								activ_str ? activ_str : "(null)",
+								expir_str ? expir_str : "(null)");
+
+	/* Make a semi-pretty display */
+	purple_notify_info(
+		NULL,         /* TODO: Find what the handle ought to be */
+		_("Certificate Information"),
+		"",
+		secondary);
+
+	/* Cleanup */
+	g_free(cn);
+	g_free(secondary);
+	g_free(sha_asc);
+	g_free(activ_str);
+	g_free(expir_str);
+	g_byte_array_free(sha_bin, TRUE);
+}
+
+void purple_certificate_add_ca_search_path(const char *path)
+{
+	if (g_list_find_custom(x509_ca_paths, path, (GCompareFunc)strcmp))
+		return;
+	x509_ca_paths = g_list_append(x509_ca_paths, g_strdup(path));
+}
+
diff -rupN pidgin-2.7.7/libpurple/plugins/ssl/ssl-gnutls.c pidgin-2.7.7-new//libpurple/plugins/ssl/ssl-gnutls.c
--- pidgin-2.7.7/libpurple/plugins/ssl/ssl-gnutls.c	2011-03-27 09:05:47.652552999 -0600
+++ pidgin-2.7.7-new//libpurple/plugins/ssl/ssl-gnutls.c	2011-03-27 09:15:29.968552999 -0600
@@ -856,7 +856,10 @@ x509_destroy_certificate(PurpleCertifica
 static gboolean
 x509_certificate_signed_by(PurpleCertificate * crt,
 			   PurpleCertificate * issuer)
+
 {
+// Don't care if cert is signed with MD2 hash
+	gnutls_certificate_set_verify_flags(issuer, GNUTLS_VERIFY_ALLOW_SIGN_RSA_MD2);
 	gnutls_x509_crt crt_dat;
 	gnutls_x509_crt issuer_dat;
 	unsigned int verify; /* used to store result from GnuTLS verifier */
Binary files pidgin-2.7.7/libpurple/protocols/facebook/arm/libjson-glib-1.0.so and pidgin-2.7.7-new//libpurple/protocols/facebook/arm/libjson-glib-1.0.so differ
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/COPYING pidgin-2.7.7-new//libpurple/protocols/facebook/COPYING
--- pidgin-2.7.7/libpurple/protocols/facebook/COPYING	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/COPYING	2011-03-27 09:15:30.752552999 -0600
@@ -0,0 +1,674 @@
+                    GNU GENERAL PUBLIC LICENSE
+                       Version 3, 29 June 2007
+
+ Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+                            Preamble
+
+  The GNU General Public License is a free, copyleft license for
+software and other kinds of works.
+
+  The licenses for most software and other practical works are designed
+to take away your freedom to share and change the works.  By contrast,
+the GNU General Public License is intended to guarantee your freedom to
+share and change all versions of a program--to make sure it remains free
+software for all its users.  We, the Free Software Foundation, use the
+GNU General Public License for most of our software; it applies also to
+any other work released this way by its authors.  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+them if you wish), that you receive source code or can get it if you
+want it, that you can change the software or use pieces of it in new
+free programs, and that you know you can do these things.
+
+  To protect your rights, we need to prevent others from denying you
+these rights or asking you to surrender the rights.  Therefore, you have
+certain responsibilities if you distribute copies of the software, or if
+you modify it: responsibilities to respect the freedom of others.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must pass on to the recipients the same
+freedoms that you received.  You must make sure that they, too, receive
+or can get the source code.  And you must show them these terms so they
+know their rights.
+
+  Developers that use the GNU GPL protect your rights with two steps:
+(1) assert copyright on the software, and (2) offer you this License
+giving you legal permission to copy, distribute and/or modify it.
+
+  For the developers' and authors' protection, the GPL clearly explains
+that there is no warranty for this free software.  For both users' and
+authors' sake, the GPL requires that modified versions be marked as
+changed, so that their problems will not be attributed erroneously to
+authors of previous versions.
+
+  Some devices are designed to deny users access to install or run
+modified versions of the software inside them, although the manufacturer
+can do so.  This is fundamentally incompatible with the aim of
+protecting users' freedom to change the software.  The systematic
+pattern of such abuse occurs in the area of products for individuals to
+use, which is precisely where it is most unacceptable.  Therefore, we
+have designed this version of the GPL to prohibit the practice for those
+products.  If such problems arise substantially in other domains, we
+stand ready to extend this provision to those domains in future versions
+of the GPL, as needed to protect the freedom of users.
+
+  Finally, every program is threatened constantly by software patents.
+States should not allow patents to restrict development and use of
+software on general-purpose computers, but in those that do, we wish to
+avoid the special danger that patents applied to a free program could
+make it effectively proprietary.  To prevent this, the GPL assures that
+patents cannot be used to render the program non-free.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+                       TERMS AND CONDITIONS
+
+  0. Definitions.
+
+  "This License" refers to version 3 of the GNU General Public License.
+
+  "Copyright" also means copyright-like laws that apply to other kinds of
+works, such as semiconductor masks.
+
+  "The Program" refers to any copyrightable work licensed under this
+License.  Each licensee is addressed as "you".  "Licensees" and
+"recipients" may be individuals or organizations.
+
+  To "modify" a work means to copy from or adapt all or part of the work
+in a fashion requiring copyright permission, other than the making of an
+exact copy.  The resulting work is called a "modified version" of the
+earlier work or a work "based on" the earlier work.
+
+  A "covered work" means either the unmodified Program or a work based
+on the Program.
+
+  To "propagate" a work means to do anything with it that, without
+permission, would make you directly or secondarily liable for
+infringement under applicable copyright law, except executing it on a
+computer or modifying a private copy.  Propagation includes copying,
+distribution (with or without modification), making available to the
+public, and in some countries other activities as well.
+
+  To "convey" a work means any kind of propagation that enables other
+parties to make or receive copies.  Mere interaction with a user through
+a computer network, with no transfer of a copy, is not conveying.
+
+  An interactive user interface displays "Appropriate Legal Notices"
+to the extent that it includes a convenient and prominently visible
+feature that (1) displays an appropriate copyright notice, and (2)
+tells the user that there is no warranty for the work (except to the
+extent that warranties are provided), that licensees may convey the
+work under this License, and how to view a copy of this License.  If
+the interface presents a list of user commands or options, such as a
+menu, a prominent item in the list meets this criterion.
+
+  1. Source Code.
+
+  The "source code" for a work means the preferred form of the work
+for making modifications to it.  "Object code" means any non-source
+form of a work.
+
+  A "Standard Interface" means an interface that either is an official
+standard defined by a recognized standards body, or, in the case of
+interfaces specified for a particular programming language, one that
+is widely used among developers working in that language.
+
+  The "System Libraries" of an executable work include anything, other
+than the work as a whole, that (a) is included in the normal form of
+packaging a Major Component, but which is not part of that Major
+Component, and (b) serves only to enable use of the work with that
+Major Component, or to implement a Standard Interface for which an
+implementation is available to the public in source code form.  A
+"Major Component", in this context, means a major essential component
+(kernel, window system, and so on) of the specific operating system
+(if any) on which the executable work runs, or a compiler used to
+produce the work, or an object code interpreter used to run it.
+
+  The "Corresponding Source" for a work in object code form means all
+the source code needed to generate, install, and (for an executable
+work) run the object code and to modify the work, including scripts to
+control those activities.  However, it does not include the work's
+System Libraries, or general-purpose tools or generally available free
+programs which are used unmodified in performing those activities but
+which are not part of the work.  For example, Corresponding Source
+includes interface definition files associated with source files for
+the work, and the source code for shared libraries and dynamically
+linked subprograms that the work is specifically designed to require,
+such as by intimate data communication or control flow between those
+subprograms and other parts of the work.
+
+  The Corresponding Source need not include anything that users
+can regenerate automatically from other parts of the Corresponding
+Source.
+
+  The Corresponding Source for a work in source code form is that
+same work.
+
+  2. Basic Permissions.
+
+  All rights granted under this License are granted for the term of
+copyright on the Program, and are irrevocable provided the stated
+conditions are met.  This License explicitly affirms your unlimited
+permission to run the unmodified Program.  The output from running a
+covered work is covered by this License only if the output, given its
+content, constitutes a covered work.  This License acknowledges your
+rights of fair use or other equivalent, as provided by copyright law.
+
+  You may make, run and propagate covered works that you do not
+convey, without conditions so long as your license otherwise remains
+in force.  You may convey covered works to others for the sole purpose
+of having them make modifications exclusively for you, or provide you
+with facilities for running those works, provided that you comply with
+the terms of this License in conveying all material for which you do
+not control copyright.  Those thus making or running the covered works
+for you must do so exclusively on your behalf, under your direction
+and control, on terms that prohibit them from making any copies of
+your copyrighted material outside their relationship with you.
+
+  Conveying under any other circumstances is permitted solely under
+the conditions stated below.  Sublicensing is not allowed; section 10
+makes it unnecessary.
+
+  3. Protecting Users' Legal Rights From Anti-Circumvention Law.
+
+  No covered work shall be deemed part of an effective technological
+measure under any applicable law fulfilling obligations under article
+11 of the WIPO copyright treaty adopted on 20 December 1996, or
+similar laws prohibiting or restricting circumvention of such
+measures.
+
+  When you convey a covered work, you waive any legal power to forbid
+circumvention of technological measures to the extent such circumvention
+is effected by exercising rights under this License with respect to
+the covered work, and you disclaim any intention to limit operation or
+modification of the work as a means of enforcing, against the work's
+users, your or third parties' legal rights to forbid circumvention of
+technological measures.
+
+  4. Conveying Verbatim Copies.
+
+  You may convey verbatim copies of the Program's source code as you
+receive it, in any medium, provided that you conspicuously and
+appropriately publish on each copy an appropriate copyright notice;
+keep intact all notices stating that this License and any
+non-permissive terms added in accord with section 7 apply to the code;
+keep intact all notices of the absence of any warranty; and give all
+recipients a copy of this License along with the Program.
+
+  You may charge any price or no price for each copy that you convey,
+and you may offer support or warranty protection for a fee.
+
+  5. Conveying Modified Source Versions.
+
+  You may convey a work based on the Program, or the modifications to
+produce it from the Program, in the form of source code under the
+terms of section 4, provided that you also meet all of these conditions:
+
+    a) The work must carry prominent notices stating that you modified
+    it, and giving a relevant date.
+
+    b) The work must carry prominent notices stating that it is
+    released under this License and any conditions added under section
+    7.  This requirement modifies the requirement in section 4 to
+    "keep intact all notices".
+
+    c) You must license the entire work, as a whole, under this
+    License to anyone who comes into possession of a copy.  This
+    License will therefore apply, along with any applicable section 7
+    additional terms, to the whole of the work, and all its parts,
+    regardless of how they are packaged.  This License gives no
+    permission to license the work in any other way, but it does not
+    invalidate such permission if you have separately received it.
+
+    d) If the work has interactive user interfaces, each must display
+    Appropriate Legal Notices; however, if the Program has interactive
+    interfaces that do not display Appropriate Legal Notices, your
+    work need not make them do so.
+
+  A compilation of a covered work with other separate and independent
+works, which are not by their nature extensions of the covered work,
+and which are not combined with it such as to form a larger program,
+in or on a volume of a storage or distribution medium, is called an
+"aggregate" if the compilation and its resulting copyright are not
+used to limit the access or legal rights of the compilation's users
+beyond what the individual works permit.  Inclusion of a covered work
+in an aggregate does not cause this License to apply to the other
+parts of the aggregate.
+
+  6. Conveying Non-Source Forms.
+
+  You may convey a covered work in object code form under the terms
+of sections 4 and 5, provided that you also convey the
+machine-readable Corresponding Source under the terms of this License,
+in one of these ways:
+
+    a) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by the
+    Corresponding Source fixed on a durable physical medium
+    customarily used for software interchange.
+
+    b) Convey the object code in, or embodied in, a physical product
+    (including a physical distribution medium), accompanied by a
+    written offer, valid for at least three years and valid for as
+    long as you offer spare parts or customer support for that product
+    model, to give anyone who possesses the object code either (1) a
+    copy of the Corresponding Source for all the software in the
+    product that is covered by this License, on a durable physical
+    medium customarily used for software interchange, for a price no
+    more than your reasonable cost of physically performing this
+    conveying of source, or (2) access to copy the
+    Corresponding Source from a network server at no charge.
+
+    c) Convey individual copies of the object code with a copy of the
+    written offer to provide the Corresponding Source.  This
+    alternative is allowed only occasionally and noncommercially, and
+    only if you received the object code with such an offer, in accord
+    with subsection 6b.
+
+    d) Convey the object code by offering access from a designated
+    place (gratis or for a charge), and offer equivalent access to the
+    Corresponding Source in the same way through the same place at no
+    further charge.  You need not require recipients to copy the
+    Corresponding Source along with the object code.  If the place to
+    copy the object code is a network server, the Corresponding Source
+    may be on a different server (operated by you or a third party)
+    that supports equivalent copying facilities, provided you maintain
+    clear directions next to the object code saying where to find the
+    Corresponding Source.  Regardless of what server hosts the
+    Corresponding Source, you remain obligated to ensure that it is
+    available for as long as needed to satisfy these requirements.
+
+    e) Convey the object code using peer-to-peer transmission, provided
+    you inform other peers where the object code and Corresponding
+    Source of the work are being offered to the general public at no
+    charge under subsection 6d.
+
+  A separable portion of the object code, whose source code is excluded
+from the Corresponding Source as a System Library, need not be
+included in conveying the object code work.
+
+  A "User Product" is either (1) a "consumer product", which means any
+tangible personal property which is normally used for personal, family,
+or household purposes, or (2) anything designed or sold for incorporation
+into a dwelling.  In determining whether a product is a consumer product,
+doubtful cases shall be resolved in favor of coverage.  For a particular
+product received by a particular user, "normally used" refers to a
+typical or common use of that class of product, regardless of the status
+of the particular user or of the way in which the particular user
+actually uses, or expects or is expected to use, the product.  A product
+is a consumer product regardless of whether the product has substantial
+commercial, industrial or non-consumer uses, unless such uses represent
+the only significant mode of use of the product.
+
+  "Installation Information" for a User Product means any methods,
+procedures, authorization keys, or other information required to install
+and execute modified versions of a covered work in that User Product from
+a modified version of its Corresponding Source.  The information must
+suffice to ensure that the continued functioning of the modified object
+code is in no case prevented or interfered with solely because
+modification has been made.
+
+  If you convey an object code work under this section in, or with, or
+specifically for use in, a User Product, and the conveying occurs as
+part of a transaction in which the right of possession and use of the
+User Product is transferred to the recipient in perpetuity or for a
+fixed term (regardless of how the transaction is characterized), the
+Corresponding Source conveyed under this section must be accompanied
+by the Installation Information.  But this requirement does not apply
+if neither you nor any third party retains the ability to install
+modified object code on the User Product (for example, the work has
+been installed in ROM).
+
+  The requirement to provide Installation Information does not include a
+requirement to continue to provide support service, warranty, or updates
+for a work that has been modified or installed by the recipient, or for
+the User Product in which it has been modified or installed.  Access to a
+network may be denied when the modification itself materially and
+adversely affects the operation of the network or violates the rules and
+protocols for communication across the network.
+
+  Corresponding Source conveyed, and Installation Information provided,
+in accord with this section must be in a format that is publicly
+documented (and with an implementation available to the public in
+source code form), and must require no special password or key for
+unpacking, reading or copying.
+
+  7. Additional Terms.
+
+  "Additional permissions" are terms that supplement the terms of this
+License by making exceptions from one or more of its conditions.
+Additional permissions that are applicable to the entire Program shall
+be treated as though they were included in this License, to the extent
+that they are valid under applicable law.  If additional permissions
+apply only to part of the Program, that part may be used separately
+under those permissions, but the entire Program remains governed by
+this License without regard to the additional permissions.
+
+  When you convey a copy of a covered work, you may at your option
+remove any additional permissions from that copy, or from any part of
+it.  (Additional permissions may be written to require their own
+removal in certain cases when you modify the work.)  You may place
+additional permissions on material, added by you to a covered work,
+for which you have or can give appropriate copyright permission.
+
+  Notwithstanding any other provision of this License, for material you
+add to a covered work, you may (if authorized by the copyright holders of
+that material) supplement the terms of this License with terms:
+
+    a) Disclaiming warranty or limiting liability differently from the
+    terms of sections 15 and 16 of this License; or
+
+    b) Requiring preservation of specified reasonable legal notices or
+    author attributions in that material or in the Appropriate Legal
+    Notices displayed by works containing it; or
+
+    c) Prohibiting misrepresentation of the origin of that material, or
+    requiring that modified versions of such material be marked in
+    reasonable ways as different from the original version; or
+
+    d) Limiting the use for publicity purposes of names of licensors or
+    authors of the material; or
+
+    e) Declining to grant rights under trademark law for use of some
+    trade names, trademarks, or service marks; or
+
+    f) Requiring indemnification of licensors and authors of that
+    material by anyone who conveys the material (or modified versions of
+    it) with contractual assumptions of liability to the recipient, for
+    any liability that these contractual assumptions directly impose on
+    those licensors and authors.
+
+  All other non-permissive additional terms are considered "further
+restrictions" within the meaning of section 10.  If the Program as you
+received it, or any part of it, contains a notice stating that it is
+governed by this License along with a term that is a further
+restriction, you may remove that term.  If a license document contains
+a further restriction but permits relicensing or conveying under this
+License, you may add to a covered work material governed by the terms
+of that license document, provided that the further restriction does
+not survive such relicensing or conveying.
+
+  If you add terms to a covered work in accord with this section, you
+must place, in the relevant source files, a statement of the
+additional terms that apply to those files, or a notice indicating
+where to find the applicable terms.
+
+  Additional terms, permissive or non-permissive, may be stated in the
+form of a separately written license, or stated as exceptions;
+the above requirements apply either way.
+
+  8. Termination.
+
+  You may not propagate or modify a covered work except as expressly
+provided under this License.  Any attempt otherwise to propagate or
+modify it is void, and will automatically terminate your rights under
+this License (including any patent licenses granted under the third
+paragraph of section 11).
+
+  However, if you cease all violation of this License, then your
+license from a particular copyright holder is reinstated (a)
+provisionally, unless and until the copyright holder explicitly and
+finally terminates your license, and (b) permanently, if the copyright
+holder fails to notify you of the violation by some reasonable means
+prior to 60 days after the cessation.
+
+  Moreover, your license from a particular copyright holder is
+reinstated permanently if the copyright holder notifies you of the
+violation by some reasonable means, this is the first time you have
+received notice of violation of this License (for any work) from that
+copyright holder, and you cure the violation prior to 30 days after
+your receipt of the notice.
+
+  Termination of your rights under this section does not terminate the
+licenses of parties who have received copies or rights from you under
+this License.  If your rights have been terminated and not permanently
+reinstated, you do not qualify to receive new licenses for the same
+material under section 10.
+
+  9. Acceptance Not Required for Having Copies.
+
+  You are not required to accept this License in order to receive or
+run a copy of the Program.  Ancillary propagation of a covered work
+occurring solely as a consequence of using peer-to-peer transmission
+to receive a copy likewise does not require acceptance.  However,
+nothing other than this License grants you permission to propagate or
+modify any covered work.  These actions infringe copyright if you do
+not accept this License.  Therefore, by modifying or propagating a
+covered work, you indicate your acceptance of this License to do so.
+
+  10. Automatic Licensing of Downstream Recipients.
+
+  Each time you convey a covered work, the recipient automatically
+receives a license from the original licensors, to run, modify and
+propagate that work, subject to this License.  You are not responsible
+for enforcing compliance by third parties with this License.
+
+  An "entity transaction" is a transaction transferring control of an
+organization, or substantially all assets of one, or subdividing an
+organization, or merging organizations.  If propagation of a covered
+work results from an entity transaction, each party to that
+transaction who receives a copy of the work also receives whatever
+licenses to the work the party's predecessor in interest had or could
+give under the previous paragraph, plus a right to possession of the
+Corresponding Source of the work from the predecessor in interest, if
+the predecessor has it or can get it with reasonable efforts.
+
+  You may not impose any further restrictions on the exercise of the
+rights granted or affirmed under this License.  For example, you may
+not impose a license fee, royalty, or other charge for exercise of
+rights granted under this License, and you may not initiate litigation
+(including a cross-claim or counterclaim in a lawsuit) alleging that
+any patent claim is infringed by making, using, selling, offering for
+sale, or importing the Program or any portion of it.
+
+  11. Patents.
+
+  A "contributor" is a copyright holder who authorizes use under this
+License of the Program or a work on which the Program is based.  The
+work thus licensed is called the contributor's "contributor version".
+
+  A contributor's "essential patent claims" are all patent claims
+owned or controlled by the contributor, whether already acquired or
+hereafter acquired, that would be infringed by some manner, permitted
+by this License, of making, using, or selling its contributor version,
+but do not include claims that would be infringed only as a
+consequence of further modification of the contributor version.  For
+purposes of this definition, "control" includes the right to grant
+patent sublicenses in a manner consistent with the requirements of
+this License.
+
+  Each contributor grants you a non-exclusive, worldwide, royalty-free
+patent license under the contributor's essential patent claims, to
+make, use, sell, offer for sale, import and otherwise run, modify and
+propagate the contents of its contributor version.
+
+  In the following three paragraphs, a "patent license" is any express
+agreement or commitment, however denominated, not to enforce a patent
+(such as an express permission to practice a patent or covenant not to
+sue for patent infringement).  To "grant" such a patent license to a
+party means to make such an agreement or commitment not to enforce a
+patent against the party.
+
+  If you convey a covered work, knowingly relying on a patent license,
+and the Corresponding Source of the work is not available for anyone
+to copy, free of charge and under the terms of this License, through a
+publicly available network server or other readily accessible means,
+then you must either (1) cause the Corresponding Source to be so
+available, or (2) arrange to deprive yourself of the benefit of the
+patent license for this particular work, or (3) arrange, in a manner
+consistent with the requirements of this License, to extend the patent
+license to downstream recipients.  "Knowingly relying" means you have
+actual knowledge that, but for the patent license, your conveying the
+covered work in a country, or your recipient's use of the covered work
+in a country, would infringe one or more identifiable patents in that
+country that you have reason to believe are valid.
+
+  If, pursuant to or in connection with a single transaction or
+arrangement, you convey, or propagate by procuring conveyance of, a
+covered work, and grant a patent license to some of the parties
+receiving the covered work authorizing them to use, propagate, modify
+or convey a specific copy of the covered work, then the patent license
+you grant is automatically extended to all recipients of the covered
+work and works based on it.
+
+  A patent license is "discriminatory" if it does not include within
+the scope of its coverage, prohibits the exercise of, or is
+conditioned on the non-exercise of one or more of the rights that are
+specifically granted under this License.  You may not convey a covered
+work if you are a party to an arrangement with a third party that is
+in the business of distributing software, under which you make payment
+to the third party based on the extent of your activity of conveying
+the work, and under which the third party grants, to any of the
+parties who would receive the covered work from you, a discriminatory
+patent license (a) in connection with copies of the covered work
+conveyed by you (or copies made from those copies), or (b) primarily
+for and in connection with specific products or compilations that
+contain the covered work, unless you entered into that arrangement,
+or that patent license was granted, prior to 28 March 2007.
+
+  Nothing in this License shall be construed as excluding or limiting
+any implied license or other defenses to infringement that may
+otherwise be available to you under applicable patent law.
+
+  12. No Surrender of Others' Freedom.
+
+  If conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot convey a
+covered work so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you may
+not convey it at all.  For example, if you agree to terms that obligate you
+to collect a royalty for further conveying from those to whom you convey
+the Program, the only way you could satisfy both those terms and this
+License would be to refrain entirely from conveying the Program.
+
+  13. Use with the GNU Affero General Public License.
+
+  Notwithstanding any other provision of this License, you have
+permission to link or combine any covered work with a work licensed
+under version 3 of the GNU Affero General Public License into a single
+combined work, and to convey the resulting work.  The terms of this
+License will continue to apply to the part which is the covered work,
+but the special requirements of the GNU Affero General Public License,
+section 13, concerning interaction through a network will apply to the
+combination as such.
+
+  14. Revised Versions of this License.
+
+  The Free Software Foundation may publish revised and/or new versions of
+the GNU General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+  Each version is given a distinguishing version number.  If the
+Program specifies that a certain numbered version of the GNU General
+Public License "or any later version" applies to it, you have the
+option of following the terms and conditions either of that numbered
+version or of any later version published by the Free Software
+Foundation.  If the Program does not specify a version number of the
+GNU General Public License, you may choose any version ever published
+by the Free Software Foundation.
+
+  If the Program specifies that a proxy can decide which future
+versions of the GNU General Public License can be used, that proxy's
+public statement of acceptance of a version permanently authorizes you
+to choose that version for the Program.
+
+  Later license versions may give you additional or different
+permissions.  However, no additional obligations are imposed on any
+author or copyright holder as a result of your choosing to follow a
+later version.
+
+  15. Disclaimer of Warranty.
+
+  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
+APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
+HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY
+OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,
+THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM
+IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF
+ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
+
+  16. Limitation of Liability.
+
+  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS
+THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY
+GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE
+USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
+DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD
+PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),
+EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGES.
+
+  17. Interpretation of Sections 15 and 16.
+
+  If the disclaimer of warranty and limitation of liability provided
+above cannot be given local legal effect according to their terms,
+reviewing courts shall apply local law that most closely approximates
+an absolute waiver of all civil liability in connection with the
+Program, unless a warranty or assumption of liability accompanies a
+copy of the Program in return for a fee.
+
+                     END OF TERMS AND CONDITIONS
+
+            How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+state the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) <year>  <name of author>
+
+    This program is free software: you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation, either version 3 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program.  If not, see <http://www.gnu.org/licenses/>.
+
+Also add information on how to contact you by electronic and paper mail.
+
+  If the program does terminal interaction, make it output a short
+notice like this when it starts in an interactive mode:
+
+    <program>  Copyright (C) <year>  <name of author>
+    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, your program's commands
+might be different; for a GUI interface, you would use an "about box".
+
+  You should also get your employer (if you work as a programmer) or school,
+if any, to sign a "copyright disclaimer" for the program, if necessary.
+For more information on this, and how to apply and follow the GNU GPL, see
+<http://www.gnu.org/licenses/>.
+
+  The GNU General Public License does not permit incorporating your program
+into proprietary programs.  If your program is a subroutine library, you
+may consider it more useful to permit linking proprietary applications with
+the library.  If this is what you want to do, use the GNU Lesser General
+Public License instead of this License.  But first, please read
+<http://www.gnu.org/philosophy/why-not-lgpl.html>.
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/COPYRIGHT pidgin-2.7.7-new//libpurple/protocols/facebook/COPYRIGHT
--- pidgin-2.7.7/libpurple/protocols/facebook/COPYRIGHT	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/COPYRIGHT	2011-03-27 09:15:30.848552999 -0600
@@ -0,0 +1,5 @@
+This protocol plugin is copyright (C) 2008 by the following:
+
+Mark Doliner
+Casey Ho
+Eion Robb
Binary files pidgin-2.7.7/libpurple/protocols/facebook/facebook16.png and pidgin-2.7.7-new//libpurple/protocols/facebook/facebook16.png differ
Binary files pidgin-2.7.7/libpurple/protocols/facebook/facebook22.png and pidgin-2.7.7-new//libpurple/protocols/facebook/facebook22.png differ
Binary files pidgin-2.7.7/libpurple/protocols/facebook/facebook48.png and pidgin-2.7.7-new//libpurple/protocols/facebook/facebook48.png differ
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/facebook.nsi pidgin-2.7.7-new//libpurple/protocols/facebook/facebook.nsi
--- pidgin-2.7.7/libpurple/protocols/facebook/facebook.nsi	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/facebook.nsi	2011-03-27 09:15:30.820553000 -0600
@@ -0,0 +1,99 @@
+; Script based on the Skype4Pidgin and Off-the-Record Messaging NSI files
+
+
+SetCompress off
+
+; todo: SetBrandingImage
+; HM NIS Edit Wizard helper defines
+!define PRODUCT_NAME "pidgin-facebookchat"
+!define PRODUCT_VERSION "1.69"
+!define PRODUCT_PUBLISHER "Eion Robb"
+!define PRODUCT_WEB_SITE "http://pidgin-facebookchat.googlecode.com/"
+!define PRODUCT_UNINST_KEY "Software\Microsoft\Windows\CurrentVersion\Uninstall\${PRODUCT_NAME}"
+!define PRODUCT_UNINST_ROOT_KEY "HKLM"
+
+; MUI 1.67 compatible ------
+!include "MUI.nsh"
+
+; MUI Settings
+!define MUI_ABORTWARNING
+!define MUI_ICON "${NSISDIR}\Contrib\Graphics\Icons\modern-install.ico"
+!define MUI_UNICON "${NSISDIR}\Contrib\Graphics\Icons\modern-uninstall.ico"
+
+; Welcome page
+!insertmacro MUI_PAGE_WELCOME
+; License page
+!insertmacro MUI_PAGE_LICENSE "COPYING"
+; Instfiles page
+!insertmacro MUI_PAGE_INSTFILES
+!define MUI_FINISHPAGE_RUN
+!define MUI_FINISHPAGE_RUN_TEXT "Run Pidgin"
+!define MUI_FINISHPAGE_RUN_FUNCTION "RunPidgin"
+!insertmacro MUI_PAGE_FINISH
+
+; Uninstaller pages
+;!insertmacro MUI_UNPAGE_INSTFILES
+
+; Language files
+!insertmacro MUI_LANGUAGE "English"
+
+; MUI end ------
+
+Name "${PRODUCT_NAME} ${PRODUCT_VERSION}"
+OutFile "${PRODUCT_NAME}.exe"
+
+Var "PidginDir"
+
+ShowInstDetails show
+ShowUnInstDetails show
+
+Section "MainSection" SEC01
+    ;Check for pidgin installation
+    Call GetPidginInstPath
+    
+    SetOverwrite try
+    
+	SetOutPath "$PidginDir\pixmaps\pidgin"
+	File "/oname=protocols\16\facebook.png" "facebook16.png"
+	File "/oname=protocols\22\facebook.png" "facebook22.png"
+	File "/oname=protocols\48\facebook.png" "facebook48.png"
+
+	SetOutPath "$PidginDir\ca-certs"
+	File "login.facebook.com.pem"
+
+    SetOverwrite try
+	copy:
+		ClearErrors
+		Delete "$PidginDir\plugins\libfacebook.dll"
+		IfErrors dllbusy
+		SetOutPath "$PidginDir\plugins"
+	    File "libfacebook.dll"
+		Goto after_copy
+	dllbusy:
+		MessageBox MB_RETRYCANCEL "libfacebook.dll is busy. Please close Pidgin (including tray icon) and try again" IDCANCEL cancel
+		Goto copy
+	cancel:
+		Abort "Installation of pidgin-facebookchat aborted"
+	after_copy:
+	
+	SetOutPath "$PidginDir"
+	File "libjson-glib-1.0.dll"
+	
+SectionEnd
+
+Function GetPidginInstPath
+  Push $0
+  ReadRegStr $0 HKLM "Software\pidgin" ""
+	IfFileExists "$0\pidgin.exe" cont
+	ReadRegStr $0 HKCU "Software\pidgin" ""
+	IfFileExists "$0\pidgin.exe" cont
+		MessageBox MB_OK|MB_ICONINFORMATION "Failed to find Pidgin installation."
+		Abort "Failed to find Pidgin installation. Please install Pidgin first."
+  cont:
+	StrCpy $PidginDir $0
+FunctionEnd
+
+Function RunPidgin
+	ExecShell "" "$PidginDir\pidgin.exe"
+FunctionEnd
+
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/facebook.svg pidgin-2.7.7-new//libpurple/protocols/facebook/facebook.svg
--- pidgin-2.7.7/libpurple/protocols/facebook/facebook.svg	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/facebook.svg	2011-03-27 09:15:30.744552999 -0600
@@ -0,0 +1,108 @@
+<?xml version="1.0" encoding="UTF-8" standalone="no"?>
+<!-- Created with Inkscape (http://www.inkscape.org/) -->
+
+<svg
+   xmlns:svg="http://www.w3.org/2000/svg"
+   xmlns="http://www.w3.org/2000/svg"
+   xmlns:xlink="http://www.w3.org/1999/xlink"
+   version="1.1"
+   width="48"
+   height="48"
+   id="svg2">
+  <defs
+     id="defs6">
+    <linearGradient
+       id="linearGradient3650">
+      <stop
+         id="stop3652"
+         style="stop-color:#6a6a6a;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop3658"
+         style="stop-color:#779cf4;stop-opacity:1"
+         offset="0.88979578" />
+      <stop
+         id="stop3654"
+         style="stop-color:#545eff;stop-opacity:1"
+         offset="1" />
+    </linearGradient>
+    <linearGradient
+       id="linearGradient3634">
+      <stop
+         id="stop3636"
+         style="stop-color:#4072e6;stop-opacity:1"
+         offset="0" />
+      <stop
+         id="stop3638"
+         style="stop-color:#334e89;stop-opacity:1"
+         offset="1" />
+    </linearGradient>
+    <radialGradient
+       cx="13.327877"
+       cy="6.1316919"
+       r="17.96468"
+       fx="13.327877"
+       fy="6.1316919"
+       id="radialGradient3640"
+       xlink:href="#linearGradient3634"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.8070156,1.4532131,-1.0519575,1.3080694,-2.6667852,-23.653083)" />
+    <radialGradient
+       cx="24.023664"
+       cy="21.943848"
+       r="19.95002"
+       fx="24.023664"
+       fy="21.943848"
+       id="radialGradient3656"
+       xlink:href="#linearGradient3650"
+       gradientUnits="userSpaceOnUse"
+       gradientTransform="matrix(1.3070175,1.2268147e-7,-1.2100323e-7,1.289138,-7.3756861,-6.3448031)" />
+    <filter
+       x="-0.070605978"
+       y="-0.54366601"
+       width="1.1412119"
+       height="2.087332"
+       color-interpolation-filters="sRGB"
+       id="filter3678">
+      <feGaussianBlur
+         id="feGaussianBlur3680"
+         stdDeviation="1.2013434" />
+    </filter>
+  </defs>
+  <rect
+     width="40.835415"
+     height="5.3033009"
+     ry="1.7350562"
+     x="3.5355339"
+     y="38.277283"
+     transform="matrix(1,0,0,0.94255278,0.61871843,3.785993)"
+     id="rect3660"
+     style="opacity:0.53252037;fill:#000000;fill-opacity:1;fill-rule:nonzero;stroke:none;filter:url(#filter3678)" />
+  <g
+     id="g3618">
+    <rect
+       width="38.910927"
+       height="38.947548"
+       ry="3.0047133"
+       x="4.5682015"
+       y="2.4700744"
+       id="rect2818"
+       style="fill:url(#radialGradient3656);fill-opacity:1;fill-rule:nonzero;stroke:#24469d;stroke-width:0.98911101;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:4;stroke-opacity:1;stroke-dasharray:none;stroke-dashoffset:0" />
+    <rect
+       width="35.929359"
+       height="36.256153"
+       ry="1.7350562"
+       x="6.1269403"
+       y="3.735842"
+       id="rect3592"
+       style="fill:url(#radialGradient3640);fill-opacity:1;fill-rule:nonzero;stroke:none" />
+    <path
+       d="m 7,31.978036 -7.938e-4,5.031486 C 6.9992062,38.10436 7.9191305,39 8.9741214,39 L 38.95642,39 c 1.054991,0 1.971131,-0.904795 1.971131,-1.999633 l 0.0092,-4.994865 L 7,31.978036 z"
+       id="rect3598"
+       style="opacity:0.46341463;fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none" />
+  </g>
+  <path
+     d="m 31.5,6.96875 c -3.441955,0 -6.239955,2.6781558 -6.46875,6.0625 L 25,16 l -3,0 0,5 3,0 0,18 7,0 0,-18 5.5,0 0,-5 -5.46875,0 0,-1.875 c 0,-1.178295 0.915762,-2.125 2.09375,-2.125 1.828085,-0.153263 3.458457,-0.138113 4.885084,0.321843 l 0,-4.9999996 C 36.391262,6.8079395 33.910076,6.9137911 31.5,6.96875 z"
+     id="rect3609"
+     style="fill:#ffffff;fill-opacity:1;fill-rule:nonzero;stroke:none" />
+</svg>
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_blist.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_blist.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_blist.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_blist.c	2011-03-27 09:15:30.752552999 -0600
@@ -0,0 +1,719 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "libfacebook.h"
+#include "fb_connection.h"
+#include "fb_blist.h"
+#include "fb_util.h"
+#include "fb_friendlist.h"
+#include "blist.h"
+
+static void set_buddies_offline(PurpleBuddy *buddy,
+		GHashTable *online_buddies_list)
+{
+	if (PURPLE_BUDDY_IS_ONLINE(buddy) &&
+		g_hash_table_lookup(online_buddies_list, buddy->name) == NULL)
+	{
+		purple_prpl_got_user_status(buddy->account, buddy->name,
+				purple_primitive_get_id_from_type(
+					PURPLE_STATUS_OFFLINE),
+				NULL);
+	}
+}
+
+static void buddy_icon_cb(FacebookAccount *fba, const gchar *data, gsize data_len,
+		gpointer user_data)
+{
+	gchar *buddyname;
+	PurpleBuddy *buddy;
+	FacebookBuddy *fbuddy;
+	gpointer buddy_icon_data;
+
+	buddyname = user_data;
+
+	purple_debug_info("facebook",
+			"buddy icon for buddy %s %" G_GSIZE_FORMAT "\n",
+			buddyname, data_len);
+
+	buddy = purple_find_buddy(fba->account, buddyname);
+	g_free(buddyname);
+
+	g_return_if_fail(buddy != NULL);
+
+	fbuddy = buddy->proto_data;
+
+	g_return_if_fail(fbuddy != NULL);
+
+	buddy_icon_data = g_memdup(data, data_len);
+
+	purple_buddy_icons_set_for_user(fba->account, buddy->name,
+			buddy_icon_data, data_len, fbuddy->thumb_url);
+}
+
+/**
+ * Find buddy names 
+ */
+static GList *get_buddies(FacebookAccount *fba, const gchar *uid,
+		const gchar *name, JsonArray *friend_list_ids)
+{
+	GList *buddies;
+	GList *cur;
+
+	buddies = fb_get_buddies_friend_list(fba, uid, friend_list_ids);
+
+	// Initialize proto data for each buddy.
+	for (cur = buddies; cur != NULL; cur = cur->next)
+	{
+		PurpleBuddy *buddy;
+
+		buddy = (PurpleBuddy *) cur->data;
+
+		/* Set the FacebookBuddy structure */
+		if (buddy->proto_data == NULL)
+		{
+			FacebookBuddy *fbuddy;
+			gchar *buddy_icon_url;
+
+			fbuddy = g_new0(FacebookBuddy, 1);
+			fbuddy->buddy = buddy;
+			fbuddy->fba = fba;
+			fbuddy->uid = atoll(uid);
+			fbuddy->name = g_strdup(name);
+
+			// load the old buddy icon url from the icon 'checksum'
+			buddy_icon_url = (char *)
+				purple_buddy_icons_get_checksum_for_user(buddy);
+			if (buddy_icon_url != NULL)
+				fbuddy->thumb_url = g_strdup(buddy_icon_url);
+
+			buddy->proto_data = fbuddy;
+		}
+	}
+
+	return buddies;
+}
+
+static void process_buddy_icon(FacebookAccount *fba, FacebookBuddy *fbuddy,
+	const gchar *buddy_icon_url)
+{
+	PurpleBuddy *buddy;
+	gchar *icon_host;
+	gchar *icon_path, *real_path;
+	gchar *search_tmp;
+
+	buddy = fbuddy->buddy;
+	
+	/* Seperate the URL into pieces */
+	purple_url_parse(buddy_icon_url, &icon_host, NULL, &icon_path, NULL, NULL);
+	
+	if (icon_path != NULL && icon_path[0] != '/')
+	{
+		/* Slap a / at the front of that badboy */
+		real_path = g_strconcat("/", icon_path, NULL);
+		g_free(icon_path);
+		icon_path = real_path;
+	}
+	
+	if (fbuddy->thumb_url == NULL ||
+	    !g_str_equal(fbuddy->thumb_url, icon_path))
+	{
+		g_free(fbuddy->thumb_url);
+		if (g_str_equal(icon_path, "/pics/q_silhouette.gif"))
+		{
+			fbuddy->thumb_url = NULL;
+			/* User has no icon */
+			purple_buddy_icons_set_for_user(fba->account,
+				purple_buddy_get_name(buddy), NULL, 0, NULL);
+		}
+		else
+		{
+			fbuddy->thumb_url = g_strdup(icon_path);
+
+			/* small icon at /profile6/1845/74/q800753867_2878.jpg */
+			/* bigger icon at /profile6/1845/74/n800753867_2878.jpg */
+			search_tmp = strstr(icon_path, "/q");
+			if (search_tmp)
+				*(search_tmp + 1) = 'n';
+			else
+			{
+				search_tmp = strstr(icon_path, "_q.jpg");
+				if (search_tmp)
+					*(search_tmp + 1) = 'n';
+			}
+			purple_debug_info("facebook", "buddy %s has a new buddy icon at http://%s%s\n", buddy->name, icon_host, icon_path);
+			/* Fetch their icon */
+			fb_post_or_get(fba, FB_METHOD_GET, icon_host,
+					icon_path, NULL,
+					buddy_icon_cb, g_strdup(purple_buddy_get_name(buddy)), FALSE);
+		}
+	}
+	g_free(icon_host);
+	g_free(icon_path);
+}
+
+static void process_buddies(FacebookAccount *fba, GHashTable *online_buddies_list,
+	JsonObject *nowAvailableList, gchar *uid, JsonObject *userInfo)
+{
+	const gchar *name;
+	gboolean idle;
+	GList *buddies, *cur;
+	gboolean current_buddy_online;
+
+	JsonArray *friend_list_ids;
+
+	friend_list_ids = NULL;
+	name = json_node_get_string(json_object_get_member(userInfo, "name"));
+
+	/* look for "uid":{"i":_____} */
+	if (json_object_has_member(nowAvailableList, uid))
+	{
+		JsonObject *userBlistInfo;
+		userBlistInfo = json_node_get_object(
+			json_object_get_member(nowAvailableList, uid));
+		idle = json_node_get_boolean(
+			json_object_get_member(userBlistInfo, "i"));
+		if (json_object_has_member(userBlistInfo, "fl")) {
+			friend_list_ids = json_node_get_array(
+				json_object_get_member(userBlistInfo, "fl"));
+		}
+
+		current_buddy_online = TRUE;
+	} else {
+		/* if we're here, the buddy's info has been sent, 
+		 * but they're not actually online */
+		current_buddy_online = FALSE;
+		idle = FALSE;
+	}
+
+	/* is this us? */
+	if (atoll(uid) == fba->uid)
+	{
+		purple_connection_set_display_name(fba->pc, name);
+
+		/* check that we don't want to show ourselves */
+		current_buddy_online = !purple_account_get_bool(
+			fba->account, "facebook_hide_self", TRUE);
+	}
+
+	buddies = get_buddies(fba, uid, name, friend_list_ids);
+	for (cur = buddies; cur != NULL; cur = cur->next)
+	{
+		PurpleBuddy *buddy;
+		FacebookBuddy *fbuddy;
+
+		buddy = (PurpleBuddy *)cur->data;
+		fbuddy = buddy->proto_data;
+
+		process_buddy_icon(fba, fbuddy, json_node_get_string(
+			json_object_get_member(userInfo, "thumbSrc")));
+
+		purple_presence_set_idle(purple_buddy_get_presence(buddy),
+				idle, 0);
+
+		if (current_buddy_online)
+		{
+			/* Add buddy to the list of online buddies */
+			g_hash_table_insert(online_buddies_list, buddy->name, buddy);
+
+			// Set buddy as online in buddy list.  We check for several
+			// conditions before doing this, because if we set it always
+			// Pidgin has a bug where the logs go nuts with "x is online".
+			if (!PURPLE_BUDDY_IS_ONLINE(buddy) ||
+			    idle != purple_presence_is_idle(
+				purple_buddy_get_presence(buddy)))
+			{
+				purple_prpl_got_user_status(fba->account, buddy->name,
+					purple_primitive_get_id_from_type(
+						idle ? PURPLE_STATUS_AWAY :
+					       	PURPLE_STATUS_AVAILABLE), NULL);
+			}
+		}
+	}
+
+	/* update the blist if we have no previous alias */
+	fb_blist_set_alias(fba, uid, name);
+}
+
+static void process_notifications(FacebookAccount *fba,
+		JsonObject *notifications)
+{
+	if (notifications != NULL &&
+	    purple_account_get_check_mail(fba->account))
+	{
+		JsonNode *inboxCount_node = json_object_get_member(
+			notifications, "inboxCount");
+		if (inboxCount_node) {
+			gint inbox_count = json_node_get_int(inboxCount_node);
+			if (inbox_count &&
+			    inbox_count != fba->last_inbox_count) {
+				fba->last_inbox_count = inbox_count;
+				gchar *url = g_strdup("http://www.facebook.com/inbox/");
+				purple_notify_emails(
+					fba->pc, inbox_count,
+					FALSE, NULL, NULL,
+					(const char**) &(fba->account->username),
+					(const char**) &(url), NULL, NULL);
+				g_free(url);
+			}
+		}
+	}
+}
+
+static void got_status_stream_cb(FacebookAccount *fba, const gchar *data,
+		gsize data_len, gpointer userdata)
+{
+	gchar *error = NULL;
+	JsonParser *parser;
+	JsonObject *objnode;
+	gint new_latest;
+	const gchar *html;
+	gchar **messages;
+	gchar *message;
+	gint i;
+	gchar *uid_string;
+	gchar *message_string;
+	gsize uid_length;
+	FacebookBuddy *fbuddy;
+	PurpleBuddy *buddy;
+	GHashTable *processed_buddies;
+	
+	purple_debug_info("facebook", "parsing status message stream\n");
+	
+	if (fba == NULL)
+		return;
+
+	parser = fb_get_parser(data, data_len);
+	if (parser == NULL) {
+		purple_debug_info("facebook", "could not parse\n");
+		return;
+	}
+	
+	//purple_debug_misc("facebook", "status message stream\n%s\n", data);
+	
+	objnode = fb_get_json_object(parser, &error);
+	
+	if (error || !json_object_has_member(objnode, "payload")) {
+		purple_debug_info("facebook", "no payload\n");
+		json_parser_free(parser);
+		return;
+	}
+	
+	objnode = json_node_get_object(json_object_get_member(
+			objnode, "payload"));
+	
+	html = json_node_get_string(json_object_get_member(
+			objnode, "html"));
+	//purple_debug_misc("facebook", "html data\n%s\n", html);
+	
+	processed_buddies = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, NULL);
+	
+	messages = g_strsplit(html, "/h6>", -1);
+	for(i = 0; messages[i]; i++)
+	{
+		message = messages[i];
+		uid_length = 0;
+		
+		//find uid:
+		//start with aid_ ...  "
+		uid_string = strstr(message, "aid_");
+		if (!uid_string)
+			continue;
+		uid_string += 4;
+		while (uid_string[uid_length] >= '0' &&
+				uid_string[uid_length] <= '9')
+		{
+			uid_length++;
+		}
+		uid_string = g_strndup(uid_string, uid_length);
+		purple_debug_info("facebook", "uid: %s\n", uid_string);
+		
+		//find message:
+		// last index of
+		// /a> ... <
+		message_string = g_strrstr(message, "/a>");
+		if (!message_string)
+		{
+			g_free(uid_string);
+			continue;
+		}
+		message_string = strchr(message_string, '>');
+		if (!message_string)
+		{
+			g_free(uid_string);
+			continue;
+		}
+		message_string += 1;
+		message_string = g_strndup(message_string, g_strrstr(message_string, "<")-message_string);
+		purple_debug_info("facebook", "message: %s\n", message_string);
+
+		if (g_hash_table_lookup(processed_buddies, uid_string))
+		{
+			// Already processed a status message for this buddy
+			g_free(uid_string);
+			g_free(message_string);
+			continue;
+		}
+		g_hash_table_insert(processed_buddies, uid_string, uid_string);
+		
+		buddy = purple_find_buddy(fba->account, uid_string);
+		if (buddy && buddy->proto_data)
+		{
+			fbuddy = buddy->proto_data;
+			g_free(fbuddy->status);
+			
+			fbuddy->status = purple_strreplace(message_string, "&hearts;", "");
+			g_free(message_string); message_string = fbuddy->status;
+			fbuddy->status = purple_markup_strip_html(message_string);
+			
+			purple_prpl_got_user_status(fba->account, buddy->name,
+				purple_status_get_id(purple_presence_get_active_status(
+					purple_buddy_get_presence(buddy))), "message", fbuddy->status, NULL);
+		}
+		
+		g_free(message_string);
+	}
+	g_strfreev(messages);
+	g_hash_table_destroy(processed_buddies);
+	
+	new_latest = json_node_get_int(json_object_get_member(
+			objnode, "newestStoryTime"));
+	if (!new_latest)
+	{
+		purple_debug_info("facebook", "no newestStoryTime\n");
+	} else {
+		fba->last_status_timestamp = new_latest;
+	}
+	
+	json_parser_free(parser);
+}
+
+static void got_buddy_list_cb(FacebookAccount *fba, const gchar *data,
+		gsize data_len, gpointer userdata)
+{
+	GSList *buddies_list;
+	GHashTable *online_buddies_list = g_hash_table_new(
+			g_str_hash, g_str_equal);
+	gchar *uid;
+
+	purple_debug_info("facebook", "parsing buddy list\n");
+
+	if (fba == NULL)
+		return;
+
+	JsonParser *parser = fb_get_parser(data, data_len);
+	if (parser == NULL) {
+		if (fba->bad_buddy_list_count++ == 3)
+		{
+			purple_connection_error_reason(fba->pc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Could not retrieve buddy list"));
+		}
+		return;
+	}
+
+	purple_debug_misc("facebook", "buddy list\n%s\n", data);
+
+	gchar *error = NULL;
+	JsonObject *objnode = fb_get_json_object(parser, &error);
+	if (error) {
+		purple_debug_info("facebook", "eion test\n");
+		if (json_node_get_int(json_object_get_member(objnode, "error")) == 1356007)
+		{
+			//Chat is down for maintenence
+			purple_connection_error_reason(fba->pc,
+				PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE,
+				error);
+			fba->pc->wants_to_die = TRUE;
+		}
+		if (fba->bad_buddy_list_count++ == 3)
+		{
+			purple_connection_error_reason(
+				fba->pc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				error);
+		}
+		g_free(error);
+		json_parser_free(parser);
+		
+		return;
+	}
+	
+	/* look for "userInfos":{ ... }, */
+	if (!json_object_has_member(objnode, "payload"))
+	{
+		json_parser_free(parser);
+		return;
+	}
+	objnode = json_node_get_object(json_object_get_member(
+			objnode, "payload"));
+	if (!json_object_has_member(objnode, "buddy_list"))
+	{
+		json_parser_free(parser);
+		return;
+	}
+	JsonObject *buddy_list = json_node_get_object(json_object_get_member(
+			objnode, "buddy_list"));
+	if (!json_object_has_member(buddy_list, "userInfos"))
+	{
+		json_parser_free(parser);
+		return;
+	}
+	
+	//Reset invalid buddy list counter
+	fba->bad_buddy_list_count = 0;
+	
+	if (purple_account_get_bool(fba->account, "facebook_use_groups", TRUE))
+	{
+		//Only process if we have the setting
+		fb_process_friend_lists(fba, buddy_list);
+	}
+	
+	// Iterate through the list of buddy infos sent to us.	
+	JsonObject *userInfos;
+	JsonObject *nowAvailableList;
+	userInfos = json_node_get_object(json_object_get_member(
+			buddy_list, "userInfos"));
+	nowAvailableList = json_node_get_object(json_object_get_member(
+			buddy_list, "nowAvailableList"));
+	GList *userIds;
+	userIds = json_object_get_members(userInfos);
+	GList *currentUserNode;
+	for(	currentUserNode = userIds;
+		currentUserNode;
+		currentUserNode = g_list_next(currentUserNode))
+	{
+		uid = currentUserNode->data;
+
+		JsonObject *userInfo;
+		userInfo = json_node_get_object(json_object_get_member(
+					userInfos, uid));
+		// Process the user, which generally consists of updating
+		// state info such as name, idle item, status message,etc.
+		process_buddies(fba, online_buddies_list, nowAvailableList,
+				uid, userInfo);
+	}
+	g_list_free(userIds);
+
+	// Set users offline.  We do this in a seperate function because FB
+	// only sends us a list of users who are online.  We find the users
+	// that are not in the union of of buddy list users + online, and
+	// mark them as offline.
+	buddies_list = purple_find_buddies(fba->account, NULL);
+	if (buddies_list != NULL)
+	{
+		g_slist_foreach(
+			buddies_list,
+			(GFunc)set_buddies_offline, online_buddies_list);
+		g_slist_free(buddies_list);
+	}
+	g_hash_table_destroy(online_buddies_list);
+	
+	// The buddy list also contains notifications data.  Process and
+	// display is appropriate.
+	process_notifications(fba, json_node_get_object(
+		json_object_get_member(objnode, "notifications")));
+
+	json_parser_free(parser);
+}
+
+gboolean fb_get_buddy_list(gpointer data)
+{
+	FacebookAccount *fba;
+	gchar *postdata;
+
+	fba = data;
+
+	postdata = g_strdup_printf(
+			"user=%" G_GINT64_FORMAT "&popped_out=true&force_render=true&buddy_list=1&__a=1&post_form_id_source=AsyncRequest&post_form_id=%s&fb_dtsg=%s&notifications=1",
+			fba->uid, fba->post_form_id?fba->post_form_id:"(null)", fba->dtsg?fba->dtsg:"(null)");
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/chat/buddy_list.php",
+			postdata, got_buddy_list_cb, NULL, FALSE);
+	g_free(postdata);
+	
+	postdata = g_strdup_printf("/ajax/intent.php?filter=app_2915120374&request_type=1&__a=1&newest=%d&ignore_self=true",
+			fba->last_status_timestamp);
+	fb_post_or_get(fba, FB_METHOD_GET, NULL, postdata,
+			NULL, got_status_stream_cb, NULL, FALSE);
+	g_free(postdata);
+
+	return TRUE;
+}
+
+static void got_full_buddy_list(FacebookAccount *fba, const gchar *data,
+		gsize data_len, gpointer userdata)
+{
+	int i;
+	PurpleGroup *fb_group;
+	JsonParser *parser;
+	gchar *error = NULL;
+	JsonObject *objnode, *node;
+	JsonArray *entries;
+	
+	purple_debug_info("facebook", "parsing full buddy list\n");
+
+	if (fba == NULL)
+		return;
+
+	parser = fb_get_parser(data, data_len);
+	if (parser == NULL)
+		return;
+
+	purple_debug_misc("facebook", "full buddy list\n%s\n", data);
+
+	objnode = fb_get_json_object(parser, &error);
+	if (!json_object_has_member(objnode, "payload"))
+	{
+		json_parser_free(parser);
+		return;
+	}
+	objnode = json_node_get_object(json_object_get_member(
+			objnode, "payload"));
+	if (!json_object_has_member(objnode, "entries"))
+	{
+		json_parser_free(parser);
+		return;
+	}
+	entries = json_node_get_array(json_object_get_member(
+			objnode, "entries"));
+			
+	fb_group = purple_find_group(DEFAULT_GROUP_NAME);
+	if (fb_group == NULL)
+	{
+		fb_group = purple_group_new(DEFAULT_GROUP_NAME);
+		purple_blist_add_group(fb_group, NULL);
+	}
+	for(i = 0; i < json_array_get_length(entries); i++)
+	{
+		node = json_node_get_object(json_array_get_element(entries, i));
+		const gchar *type = json_node_get_string(json_object_get_member(node, "ty"));
+		if (type[0] != 'u' && type[0] != 'g')
+			continue;
+		const gchar *uid = json_node_get_string(json_object_get_member(node, "i"));
+		const gchar *name = json_node_get_string(json_object_get_member(node, "t"));
+		
+		if (type[0] == 'g')
+		{
+			PurpleChat *chat = purple_blist_find_chat(fba->account, uid);
+			purple_blist_alias_chat(chat, name);
+			continue;
+		}
+		
+		if (purple_find_buddy(fba->account, uid))
+			continue;
+		
+		PurpleBuddy *buddy = purple_buddy_new(fba->account, uid, name);
+		purple_blist_add_buddy(buddy, NULL, fb_group, NULL);
+		FacebookBuddy *fbuddy = g_new0(FacebookBuddy, 1);
+		fbuddy->buddy = buddy;
+		fbuddy->fba = fba;
+		fbuddy->uid = atoll(uid);
+		fbuddy->name = g_strdup(name);
+		buddy->proto_data = fbuddy;
+		
+		const gchar *thumb_url = json_node_get_string(json_object_get_member(node, "it"));
+		process_buddy_icon(fba, fbuddy, thumb_url);
+	}
+
+	json_parser_free(parser);	
+}
+
+void fb_get_full_buddy_list(FacebookAccount *fba)
+{
+	gchar *url;
+	
+	url = g_strdup_printf("/ajax/typeahead_search.php?u=%" G_GINT64_FORMAT "&__a=1", fba->uid);
+	fb_post_or_get(fba, FB_METHOD_GET, NULL, url, NULL, got_full_buddy_list, NULL, FALSE);
+	g_free(url);
+}
+
+void fb_blist_poke_buddy(PurpleBlistNode *node, gpointer data)
+{
+	PurpleBuddy *buddy;
+	FacebookBuddy *fbuddy;
+	FacebookAccount *fba;
+	gchar *postdata;
+	
+	if(!PURPLE_BLIST_NODE_IS_BUDDY(node))
+		return;
+	buddy = (PurpleBuddy *) node;
+	if (!buddy)
+		return;
+	fbuddy = buddy->proto_data;
+	if (!fbuddy)
+		return;
+	fba = fbuddy->fba;
+	if (!fba)
+		return;
+	
+	postdata = g_strdup_printf("uid=%" G_GINT64_FORMAT "&pokeback=0&post_form_id=%s", fbuddy->uid, fba->post_form_id);
+	
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/poke.php",
+				postdata, NULL, NULL, FALSE);
+	
+	g_free(postdata);
+}
+
+void fb_blist_set_alias(FacebookAccount *fba, const gchar *id,
+		const gchar *name)
+{
+	const char *current_alias;
+	PurpleBuddy *buddy;
+
+	buddy = purple_find_buddy(fba->account, id);
+	if (!buddy) {
+		return;
+	}	
+
+	/* Set an alias if no user-defined alias is set yet.  This provides
+	 * a basic name alias for each user which is more useful than a
+	 * number.  A small corner case bug here- aliases will not change
+	 * in accordance with people changing their names on Facebook.
+	 */
+	current_alias = purple_buddy_get_alias_only(buddy);
+	if (!current_alias) {
+		purple_debug_info("facebook", "aliasing %s to %s\n", id, name);
+		purple_blist_alias_buddy(buddy, name);
+	}
+
+	/* In case user removes an alias, we have the server as fallback */
+	serv_got_alias(fba->pc, id, name);
+}
+
+void fb_blist_init(FacebookAccount *fba)
+{
+	fb_friendlist_init(fba);
+
+	fb_get_buddy_list(fba);
+
+	/* periodically check for updates to your buddy list */
+	fba->buddy_list_timer = purple_timeout_add_seconds(60,
+			fb_get_buddy_list, fba);
+
+	fb_get_full_buddy_list(fba);
+}
+
+void fb_blist_destroy(FacebookAccount *fba)
+{
+	if (fba->buddy_list_timer) {
+		purple_timeout_remove(fba->buddy_list_timer);
+	}
+
+	fb_friendlist_destroy(fba);
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_blist.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_blist.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_blist.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_blist.h	2011-03-27 09:15:30.736552999 -0600
@@ -0,0 +1,37 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_BLIST_H
+#define FACEBOOK_BLIST_H
+
+#include "libfacebook.h"
+
+gboolean fb_get_buddy_list(gpointer data);
+void fb_blist_poke_buddy(PurpleBlistNode *node, gpointer data);
+
+void fb_blist_set_alias(FacebookAccount *fba, const char *id,
+		const char *name);
+
+void fb_blist_init(FacebookAccount *fba);
+void fb_blist_destroy(FacebookAccount *fba);
+
+void fb_get_full_buddy_list(FacebookAccount *fba);
+
+#endif /* FACEBOOK_BLIST_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_chat.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_chat.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_chat.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_chat.c	2011-03-27 09:15:30.888552999 -0600
@@ -0,0 +1,273 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_chat.h"
+#include "fb_blist.h"
+#include "fb_util.h"
+#include "fb_connection.h"
+#include "fb_friendlist.h"
+#include "fb_messages.h"
+#include "fb_conversation.h"
+
+#include "conversation.h"
+
+void
+fb_got_facepile(FacebookAccount *fba, const gchar *data, gsize data_len, gpointer user_data)
+{
+	gchar *group = user_data;
+	JsonParser *parser;
+	JsonObject *object, *payload, *user_obj;
+	JsonArray *facepile;
+	PurpleConversation *conv;
+	PurpleConvChat *chat;
+	gchar *uid;
+	guint i;
+	PurpleGroup *pgroup;
+	
+	purple_debug_info("facebook", "got facepile %s\n", data?data:"(null)");
+	
+	conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_CHAT, group, fba->account);
+	chat = PURPLE_CONV_CHAT(conv);
+	
+	parser = fb_get_parser(data, data_len);
+	
+	if (!parser)
+	{
+		purple_debug_warning("facebook",
+			"could not fetch facepile for group %s\n", group);
+		g_free(group);
+		return;
+	}
+	
+	object = fb_get_json_object(parser, NULL);
+	payload = json_node_get_object(
+		json_object_get_member(object, "payload"));
+	facepile = json_node_get_array(
+		json_object_get_member(payload, "facepile_click_info"));
+	
+	pgroup = purple_find_group(DEFAULT_GROUP_NAME);
+	if (!pgroup)
+	{
+		pgroup = purple_group_new(DEFAULT_GROUP_NAME);
+		purple_blist_add_group(pgroup, NULL);
+	}
+
+	purple_conv_chat_clear_users(chat);
+	uid = g_strdup_printf("%" G_GINT64_FORMAT, fba->uid);
+	purple_conv_chat_add_user(chat, uid, NULL, PURPLE_CBFLAGS_NONE, FALSE);
+	if (!purple_find_buddy(fba->account, uid))
+	{
+		PurpleBuddy *buddy = purple_buddy_new(fba->account, uid, "You");
+		purple_blist_node_set_flags((PurpleBlistNode *)buddy, PURPLE_BLIST_NODE_FLAG_NO_SAVE);
+		purple_blist_add_buddy(buddy, NULL, pgroup, NULL);
+	}
+	g_free(uid);
+	
+	for (i = 0; i < json_array_get_length(facepile); i++)
+	{
+		user_obj = json_node_get_object(
+			json_array_get_element(facepile, i));
+		uid = g_strdup_printf("%" G_GINT64_FORMAT, (gint64)json_node_get_int(json_object_get_member(user_obj, "uid")));
+		
+		purple_conv_chat_add_user(PURPLE_CONV_CHAT(conv), uid, NULL, PURPLE_CBFLAGS_NONE, FALSE);
+		
+		if (!purple_find_buddy(fba->account, uid))
+		{
+			const char *alias = json_node_get_string(json_object_get_member(user_obj, "name"));
+			PurpleBuddy *buddy = purple_buddy_new(fba->account, uid, alias);
+			purple_blist_node_set_flags((PurpleBlistNode *)buddy, PURPLE_BLIST_NODE_FLAG_NO_SAVE);
+			purple_blist_add_buddy(buddy, NULL, pgroup, NULL);
+		}
+		
+		g_free(uid);
+	}
+	
+	g_free(group);
+}
+
+PurpleConversation *
+fb_find_chat(FacebookAccount *fba, const gchar *group)
+{
+	PurpleConversation *conv;
+	gchar *postdata;
+	
+	conv = purple_find_conversation_with_account(PURPLE_CONV_TYPE_CHAT, group, fba->account);
+	
+	if (conv == NULL)
+	{
+		conv = serv_got_joined_chat(fba->pc, atoi(group), group);
+		
+		postdata = g_strdup_printf("gid=%s&post_form_id=%s&fb_dtsg=%s&lsd=", group,
+					fba->post_form_id, fba->dtsg);
+		fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/groups/chat/update_facepiles.php?__a=1",
+			postdata, fb_got_facepile, g_strdup(group), FALSE);
+		g_free(postdata);
+	}
+	
+	return conv;
+}
+
+void
+fb_got_groups(FacebookAccount *fba, const gchar *data, gsize data_len, gpointer user_data)
+{
+	// look for  /home.php?sk=group_ ...
+	gchar **splits;
+	gint i;
+	PurpleGroup *group;
+	
+	splits = g_strsplit(data, "<a href=\\\"\\/home.php?sk=group_", 0);
+	
+	if (!splits || !splits[0])
+	{
+		g_strfreev(splits);
+		return;
+	}
+	
+	group = purple_find_group(DEFAULT_GROUP_NAME);
+	if (!group)
+	{
+		group = purple_group_new(DEFAULT_GROUP_NAME);
+		purple_blist_add_group(group, NULL);
+	}
+	
+	for(i = 1; splits[i]; i++)
+	{
+		gchar *eos;
+		eos = strchr(splits[i], '\\');
+		if (eos != NULL)
+		{
+			*eos = '\0';
+			purple_debug_info("facebook", "searching for %s\n", splits[i]);
+			if (!purple_blist_find_chat(fba->account, splits[i]))
+			{
+				gchar *alias = NULL;
+				if (eos[1] == '"' && eos[2] == '>')
+				{
+					purple_debug_info("facebook", "searching for alias\n");
+					gchar *eoa = strchr(&eos[3], '<');
+					if (eoa)
+					{
+						*eoa = '\0';
+						alias = &eos[3];
+						purple_debug_info("facebook", "found chat alias %s\n", alias);
+					}
+				}
+
+				purple_debug_info("facebook", "adding chat %s to buddy list...\n", splits[i]);
+				// Add the group chat to the buddy list
+				GHashTable *components = fb_chat_info_defaults(fba->pc, splits[i]);
+				PurpleChat *chat = purple_chat_new(fba->account, alias, components);
+				purple_blist_add_chat(chat, group, NULL);
+				purple_debug_info("facebook", "done\n");
+			}
+		}
+	}
+	
+	g_strfreev(splits);
+}
+
+void
+fb_get_groups(FacebookAccount *fba)
+{
+	fb_post_or_get(fba, FB_METHOD_GET, NULL, "/ajax/home/groups.php?__a=1", NULL, fb_got_groups, NULL, FALSE);
+}
+
+int
+fb_chat_send(PurpleConnection *pc, int id, const char *message, PurpleMessageFlags flags)
+{
+	PurpleConversation *conv;
+	const char *group;
+	
+	conv = purple_find_chat(pc, id);
+	if (conv != NULL)
+	{
+		group = purple_conversation_get_name(conv);
+		
+		return fb_send_im(pc, group, message, flags);
+	}
+	
+	return -1;
+}
+
+void
+fb_chat_fake_leave(PurpleConnection *pc, int id)
+{
+	PurpleConversation *conv;
+	const char *group;
+	
+	conv = purple_find_chat(pc, id);
+	if (conv != NULL)
+	{
+		group = purple_conversation_get_name(conv);
+		fb_conversation_closed(pc, group);
+	}
+}
+
+GHashTable *
+fb_chat_info_defaults(PurpleConnection *pc, const char *chat_name)
+{
+	GHashTable *table;
+	
+	table = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, g_free);
+	
+	if (chat_name != NULL)
+	{
+		g_hash_table_insert(table, "group", g_strdup(chat_name));
+	}
+	
+	return table;
+}
+
+gchar *
+fb_get_chat_name(GHashTable *components)
+{
+	gchar *group;
+	
+	group = (gchar *) g_hash_table_lookup(components, "group");
+	
+	return g_strdup(group);
+}
+
+GList *
+fb_chat_info(PurpleConnection *pc)
+{
+	GList *m = NULL;
+	struct proto_chat_entry *pce;
+	
+	pce = g_new0(struct proto_chat_entry, 1);
+	pce->label = _("Group ID");
+	pce->identifier = "group";
+	pce->required = TRUE;
+	m = g_list_append(m, pce);
+	
+	return m;
+}
+
+void
+fb_fake_join_chat(PurpleConnection *pc, GHashTable *components)
+{
+	FacebookAccount *fba = pc->proto_data;
+	gchar *group = (gchar *) g_hash_table_lookup(components, "group");
+
+	if (group != NULL)
+	{
+		fb_find_chat(fba, group);
+	}
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_chat.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_chat.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_chat.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_chat.h	2011-03-27 09:15:30.876553000 -0600
@@ -0,0 +1,35 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_CHAT_H
+#define FACEBOOK_CHAT_H
+
+#include "libfacebook.h"
+
+PurpleConversation *fb_find_chat(FacebookAccount *fba, const gchar *group);
+void fb_get_groups(FacebookAccount *fba);
+int fb_chat_send(PurpleConnection *, int id, const char *message, PurpleMessageFlags flags);
+void fb_chat_fake_leave(PurpleConnection *, int id);
+GHashTable *fb_chat_info_defaults(PurpleConnection *, const char *chat_name);
+gchar *fb_get_chat_name(GHashTable *components);
+GList *fb_chat_info(PurpleConnection *);
+void fb_fake_join_chat(PurpleConnection *, GHashTable *components);
+
+#endif /* FACEBOOK_CHAT_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_connection.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_connection.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_connection.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_connection.c	2011-03-27 09:15:30.744552999 -0600
@@ -0,0 +1,685 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_connection.h"
+
+#if !GLIB_CHECK_VERSION (2, 22, 0)
+#define g_hostname_is_ip_address(hostname) (g_ascii_isdigit(hostname[0]) && g_strstr_len(hostname, 4, "."))
+#endif
+
+static void fb_attempt_connection(FacebookConnection *);
+static void fb_next_connection(FacebookAccount *fba);
+
+#ifdef HAVE_ZLIB
+#include <zlib.h>
+
+static gchar *fb_gunzip(const guchar *gzip_data, ssize_t *len_ptr)
+{
+	gsize gzip_data_len	= *len_ptr;
+	z_stream zstr;
+	int gzip_err = 0;
+	gchar *data_buffer;
+	gulong gzip_len = G_MAXUINT16;
+	GString *output_string = NULL;
+
+	data_buffer = g_new0(gchar, gzip_len);
+
+	zstr.next_in = NULL;
+	zstr.avail_in = 0;
+	zstr.zalloc = Z_NULL;
+	zstr.zfree = Z_NULL;
+	zstr.opaque = 0;
+	gzip_err = inflateInit2(&zstr, MAX_WBITS+32);
+	if (gzip_err != Z_OK)
+	{
+		g_free(data_buffer);
+		purple_debug_error("facebook", "no built-in gzip support in zlib\n");
+		return NULL;
+	}
+	
+	zstr.next_in = (Bytef *)gzip_data;
+	zstr.avail_in = gzip_data_len;
+	
+	zstr.next_out = (Bytef *)data_buffer;
+	zstr.avail_out = gzip_len;
+	
+	gzip_err = inflate(&zstr, Z_SYNC_FLUSH);
+
+	if (gzip_err == Z_DATA_ERROR)
+	{
+		inflateEnd(&zstr);
+		inflateInit2(&zstr, -MAX_WBITS);
+		if (gzip_err != Z_OK)
+		{
+			g_free(data_buffer);
+			purple_debug_error("facebook", "Cannot decode gzip header\n");
+			return NULL;
+		}
+		zstr.next_in = (Bytef *)gzip_data;
+		zstr.avail_in = gzip_data_len;
+		zstr.next_out = (Bytef *)data_buffer;
+		zstr.avail_out = gzip_len;
+		gzip_err = inflate(&zstr, Z_SYNC_FLUSH);
+	}
+	output_string = g_string_new("");
+	while (gzip_err == Z_OK)
+	{
+		//append data to buffer
+		output_string = g_string_append_len(output_string, data_buffer, gzip_len - zstr.avail_out);
+		//reset buffer pointer
+		zstr.next_out = (Bytef *)data_buffer;
+		zstr.avail_out = gzip_len;
+		gzip_err = inflate(&zstr, Z_SYNC_FLUSH);
+	}
+	if (gzip_err == Z_STREAM_END)
+	{
+		output_string = g_string_append_len(output_string, data_buffer, gzip_len - zstr.avail_out);
+	} else {
+		purple_debug_error("facebook", "gzip inflate error\n");
+	}
+	inflateEnd(&zstr);
+
+	g_free(data_buffer);	
+
+	if (len_ptr)
+		*len_ptr = output_string->len;
+
+	return g_string_free(output_string, FALSE);
+}
+#else /* !HAVE_ZLIB */
+#warning You really want to compile with -DHAVE_ZLIB
+#endif
+
+void fb_connection_destroy(FacebookConnection *fbconn)
+{
+	fbconn->fba->conns = g_slist_remove(fbconn->fba->conns, fbconn);
+
+	if (fbconn->request != NULL)
+		g_string_free(fbconn->request, TRUE);
+
+	g_free(fbconn->rx_buf);
+
+	if (fbconn->connect_data != NULL)
+		purple_proxy_connect_cancel(fbconn->connect_data);
+
+	if (fbconn->ssl_conn != NULL)
+		purple_ssl_close(fbconn->ssl_conn);
+
+	if (fbconn->fd >= 0) {
+		close(fbconn->fd);
+	}
+
+	if (fbconn->input_watcher > 0)
+		purple_input_remove(fbconn->input_watcher);
+
+	g_free(fbconn->url);
+	g_free(fbconn->hostname);
+	g_free(fbconn);
+}
+
+static void fb_update_cookies(FacebookAccount *fba, const gchar *headers)
+{
+	const gchar *cookie_start;
+	const gchar *cookie_end;
+	gchar *cookie_name;
+	gchar *cookie_value;
+	int header_len;
+
+	g_return_if_fail(headers != NULL);
+
+	header_len = strlen(headers);
+
+	/* look for the next "Set-Cookie: " */
+	/* grab the data up until ';' */
+	cookie_start = headers;
+	while ((cookie_start = strstr(cookie_start, "\r\nSet-Cookie: ")) &&
+			(cookie_start - headers) < header_len)
+	{
+		cookie_start += 14;
+		cookie_end = strchr(cookie_start, '=');
+		cookie_name = g_strndup(cookie_start, cookie_end-cookie_start);
+		cookie_start = cookie_end + 1;
+		cookie_end = strchr(cookie_start, ';');
+		cookie_value= g_strndup(cookie_start, cookie_end-cookie_start);
+		cookie_start = cookie_end;
+
+		g_hash_table_replace(fba->cookie_table, cookie_name,
+				cookie_value);
+	}
+}
+
+static void fb_connection_process_data(FacebookConnection *fbconn)
+{
+	ssize_t len;
+	gchar *tmp;
+
+	len = fbconn->rx_len;
+	tmp = g_strstr_len(fbconn->rx_buf, len, "\r\n\r\n");
+	if (tmp == NULL) {
+		/* This is a corner case that occurs when the connection is
+		 * prematurely closed either on the client or the server.
+		 * This can either be no data at all or a partial set of
+		 * headers.  We pass along the data to be good, but don't
+		 * do any fancy massaging.  In all likelihood the result will
+		 * be tossed by the connection callback func anyways
+		 */
+		tmp = g_strndup(fbconn->rx_buf, len);
+	} else {
+		tmp += 4;
+		len -= g_strstr_len(fbconn->rx_buf, len, "\r\n\r\n") -
+				fbconn->rx_buf + 4;
+		tmp = g_memdup(tmp, len + 1);
+		tmp[len] = '\0';
+		fbconn->rx_buf[fbconn->rx_len - len] = '\0';
+		fb_update_cookies(fbconn->fba, fbconn->rx_buf);
+
+#ifdef HAVE_ZLIB
+		if (strstr(fbconn->rx_buf, "Content-Encoding: gzip"))
+		{
+			/* we've received compressed gzip data, decompress */
+			gchar *gunzipped;
+			gunzipped = fb_gunzip((const guchar *)tmp, &len);
+			g_free(tmp);
+			tmp = gunzipped;
+		}
+#endif
+	}
+
+	g_free(fbconn->rx_buf);
+	fbconn->rx_buf = NULL;
+
+	if (fbconn->callback != NULL) {
+		purple_debug_info("facebook", "executing callback for %s\n", fbconn->url);
+		fbconn->callback(fbconn->fba, tmp, len, fbconn->user_data);
+	}
+
+	g_free(tmp);
+}
+
+static void fb_fatal_connection_cb(FacebookConnection *fbconn)
+{
+	PurpleConnection *pc = fbconn->fba->pc;
+
+	purple_debug_error("facebook", "fatal connection error\n");
+
+	fb_connection_destroy(fbconn);
+
+	/* We died.  Do not pass Go.  Do not collect $200 */
+	/* In all seriousness, don't attempt to call the normal callback here.
+	 * That may lead to the wrong error message being displayed */
+	purple_connection_error_reason(pc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Server closed the connection."));
+
+}
+
+static void fb_post_or_get_readdata_cb(gpointer data, gint source,
+		PurpleInputCondition cond)
+{
+	FacebookConnection *fbconn;
+	FacebookAccount *fba;
+	gchar buf[4096];
+	ssize_t len;
+
+	fbconn = data;
+	fba = fbconn->fba;
+
+	if (fbconn->method & FB_METHOD_SSL) {
+		len = purple_ssl_read(fbconn->ssl_conn,
+				buf, sizeof(buf) - 1);
+	} else {
+		len = recv(fbconn->fd, buf, sizeof(buf) - 1, 0);
+	}
+
+	if (len < 0)
+	{
+		if (errno == EAGAIN || errno == EWOULDBLOCK || errno == EINTR) {
+			/* Try again later */
+			return;
+		}
+
+		if (fbconn->method & FB_METHOD_SSL && fbconn->rx_len > 0) {
+			/*
+			 * This is a slightly hacky workaround for a bug in either
+			 * GNU TLS or in the SSL implementation on Facebook's web
+			 * servers.  The sequence of events is:
+			 * 1. We attempt to read the first time and successfully read
+			 *    the server's response.
+			 * 2. We attempt to read a second time and libpurple's call
+			 *    to gnutls_record_recv() returns the error
+			 *    GNUTLS_E_UNEXPECTED_PACKET_LENGTH, or
+			 *    "A TLS packet with unexpected length was received."
+			 *
+			 * Normally the server would have closed the connection
+			 * cleanly and this second read() request would have returned
+			 * 0.  Or maybe it's normal for SSL connections to be severed
+			 * in this manner?  In any case, this differs from the behavior
+			 * of the standard recv() system call.
+			 */
+			purple_debug_warning("facebook",
+				"ssl error, but data received.  attempting to continue\n");
+		} else {
+			/* TODO: Is this a regular occurrence?  If so then maybe resend the request? */
+			fb_fatal_connection_cb(fbconn);
+			return;
+		}
+	}
+
+	if (len > 0)
+	{
+		buf[len] = '\0';
+
+		fbconn->rx_buf = g_realloc(fbconn->rx_buf,
+				fbconn->rx_len + len + 1);
+		memcpy(fbconn->rx_buf + fbconn->rx_len, buf, len + 1);
+		fbconn->rx_len += len;
+
+		/* Wait for more data before processing */
+		return;
+	}
+
+	/* The server closed the connection, let's parse the data */
+	fb_connection_process_data(fbconn);
+
+	fb_connection_destroy(fbconn);
+	
+	fb_next_connection(fba);
+}
+
+static void fb_post_or_get_ssl_readdata_cb (gpointer data,
+		PurpleSslConnection *ssl, PurpleInputCondition cond)
+{
+	fb_post_or_get_readdata_cb(data, -1, cond);
+}
+
+static void fb_post_or_get_connect_cb(gpointer data, gint source,
+		const gchar *error_message)
+{
+	FacebookConnection *fbconn;
+	ssize_t len;
+
+	fbconn = data;
+	fbconn->connect_data = NULL;
+
+	if (error_message)
+	{
+		purple_debug_error("facebook", "post_or_get_connect failure to %s\n", fbconn->url);
+		purple_debug_error("facebook", "post_or_get_connect_cb %s\n",
+				error_message);
+		fb_fatal_connection_cb(fbconn);
+		return;
+	}
+
+	fbconn->fd = source;
+
+	/* TODO: Check the return value of write() */
+	len = write(fbconn->fd, fbconn->request->str,
+			fbconn->request->len);
+	fbconn->input_watcher = purple_input_add(fbconn->fd,
+			PURPLE_INPUT_READ,
+			fb_post_or_get_readdata_cb, fbconn);
+}
+
+static void fb_post_or_get_ssl_connect_cb(gpointer data,
+		PurpleSslConnection *ssl, PurpleInputCondition cond)
+{
+	FacebookConnection *fbconn;
+	ssize_t len;
+
+	fbconn = data;
+
+	purple_debug_info("facebook", "post_or_get_ssl_connect_cb\n");
+
+	/* TODO: Check the return value of write() */
+	len = purple_ssl_write(fbconn->ssl_conn,
+			fbconn->request->str, fbconn->request->len);
+	purple_ssl_input_add(fbconn->ssl_conn,
+			fb_post_or_get_ssl_readdata_cb, fbconn);
+}
+
+static void fb_host_lookup_cb(GSList *hosts, gpointer data,
+		const char *error_message)
+{
+	GSList *host_lookup_list;
+	struct sockaddr_in *addr;
+	gchar *hostname;
+	gchar *ip_address;
+	FacebookAccount *fba;
+	PurpleDnsQueryData *query;
+
+	/* Extract variables */
+	host_lookup_list = data;
+
+	fba = host_lookup_list->data;
+	host_lookup_list =
+			g_slist_delete_link(host_lookup_list, host_lookup_list);
+	hostname = host_lookup_list->data;
+	host_lookup_list =
+			g_slist_delete_link(host_lookup_list, host_lookup_list);
+	query = host_lookup_list->data;
+	host_lookup_list =
+			g_slist_delete_link(host_lookup_list, host_lookup_list);
+
+	/* The callback has executed, so we no longer need to keep track of
+	 * the original query.  This always needs to run when the cb is 
+	 * executed. */
+	fba->dns_queries = g_slist_remove(fba->dns_queries, query);
+
+	/* Any problems, capt'n? */
+	if (error_message != NULL)
+	{
+		purple_debug_warning("facebook",
+				"Error doing host lookup: %s\n", error_message);
+		return;
+	}
+
+	if (hosts == NULL)
+	{
+		purple_debug_warning("facebook",
+				"Could not resolve host name\n");
+		return;
+	}
+
+	/* Discard the length... */
+	hosts = g_slist_delete_link(hosts, hosts);
+	/* Copy the address then free it... */
+	addr = hosts->data;
+	ip_address = g_strdup(inet_ntoa(addr->sin_addr));
+	g_free(addr);
+	hosts = g_slist_delete_link(hosts, hosts);
+
+	/*
+	 * DNS lookups can return a list of IP addresses, but we only cache
+	 * the first one.  So free the rest.
+	 */
+	while (hosts != NULL)
+	{
+		/* Discard the length... */
+		hosts = g_slist_delete_link(hosts, hosts);
+		/* Free the address... */
+		g_free(hosts->data);
+		hosts = g_slist_delete_link(hosts, hosts);
+	}
+
+	g_hash_table_insert(fba->hostname_ip_cache, hostname, ip_address);
+}
+
+static void fb_cookie_foreach_cb(gchar *cookie_name,
+		gchar *cookie_value, GString *str)
+{
+	/* TODO: Need to escape name and value? */
+	g_string_append_printf(str, "%s=%s;", cookie_name, cookie_value);
+}
+
+/**
+ * Serialize the fba->cookie_table hash table to a string.
+ */
+gchar *fb_cookies_to_string(FacebookAccount *fba)
+{
+	GString *str;
+
+	str = g_string_new(NULL);
+
+	g_hash_table_foreach(fba->cookie_table,
+			(GHFunc)fb_cookie_foreach_cb, str);
+
+	return g_string_free(str, FALSE);
+}
+
+static void fb_ssl_connection_error(PurpleSslConnection *ssl,
+		PurpleSslErrorType errortype, gpointer data)
+{
+	FacebookConnection *fbconn = data;
+	PurpleConnection *pc = fbconn->fba->pc;
+
+	fbconn->ssl_conn = NULL;
+	fb_connection_destroy(fbconn);
+	purple_connection_ssl_error(pc, errortype);
+}
+
+void fb_post_or_get(FacebookAccount *fba, FacebookMethod method,
+		const gchar *host, const gchar *url, const gchar *postdata,
+		FacebookProxyCallbackFunc callback_func, gpointer user_data,
+		gboolean keepalive)
+{
+	GString *request;
+	gchar *cookies;
+	FacebookConnection *fbconn;
+	gchar *real_url;
+	gboolean is_proxy = FALSE;
+	const gchar *user_agent;
+	const gchar* const *languages;
+	gchar *language_names;
+	PurpleProxyInfo *proxy_info = NULL;
+	gchar *proxy_auth;
+	gchar *proxy_auth_base64;
+
+	/* TODO: Fix keepalive and use it as much as possible */
+	keepalive = FALSE;
+
+	if (host == NULL)
+		host = "www.facebook.com";
+
+	if (fba && fba->account)
+	{
+		if (purple_account_get_bool(fba->account, "use-https", FALSE))
+			method |= FB_METHOD_SSL;
+	}
+
+	if (fba && fba->account && !(method & FB_METHOD_SSL))
+	{
+		proxy_info = purple_proxy_get_setup(fba->account);
+		if (purple_proxy_info_get_type(proxy_info) == PURPLE_PROXY_USE_GLOBAL)
+			proxy_info = purple_global_proxy_get_info();
+		if (purple_proxy_info_get_type(proxy_info) == PURPLE_PROXY_HTTP)
+		{
+			is_proxy = TRUE;
+		}	
+	}
+	if (is_proxy == TRUE)
+	{
+		real_url = g_strdup_printf("http://%s%s", host, url);
+	} else {
+		real_url = g_strdup(url);
+	}
+
+	cookies = fb_cookies_to_string(fba);
+	user_agent = purple_account_get_string(fba->account, "user-agent", "Opera/9.50 (Windows NT 5.1; U; en-GB)");
+	
+	if (method & FB_METHOD_POST && !postdata)
+		postdata = "";
+
+	/* Build the request */
+	request = g_string_new(NULL);
+	g_string_append_printf(request, "%s %s HTTP/1.0\r\n",
+			(method & FB_METHOD_POST) ? "POST" : "GET",
+			real_url);
+	if (is_proxy == FALSE)
+		g_string_append_printf(request, "Host: %s\r\n", host);
+	g_string_append_printf(request, "Connection: %s\r\n",
+			(keepalive ? "Keep-Alive" : "close"));
+	g_string_append_printf(request, "User-Agent: %s\r\n", user_agent);
+	if (method & FB_METHOD_POST) {
+		g_string_append_printf(request,
+				"Content-Type: application/x-www-form-urlencoded\r\n");
+		g_string_append_printf(request,
+				"Content-length: %zu\r\n", strlen(postdata));
+	}
+	g_string_append_printf(request, "Accept: */*\r\n");
+	g_string_append_printf(request, "Cookie: isfbe=false;%s\r\n", cookies);
+#ifdef HAVE_ZLIB
+	g_string_append_printf(request, "Accept-Encoding: gzip\r\n");
+#endif
+	if (is_proxy == TRUE)
+	{
+		if (purple_proxy_info_get_username(proxy_info) &&
+			purple_proxy_info_get_password(proxy_info))
+		{
+			proxy_auth = g_strdup_printf("%s:%s", purple_proxy_info_get_username(proxy_info), purple_proxy_info_get_password(proxy_info));
+			proxy_auth_base64 = purple_base64_encode((guchar *)proxy_auth, strlen(proxy_auth));
+			g_string_append_printf(request, "Proxy-Authorization: Basic %s\r\n", proxy_auth_base64);
+			g_free(proxy_auth_base64);
+			g_free(proxy_auth);
+		}
+	}
+
+	/* Tell the server what language we accept, so that we get error messages in our language (rather than our IP's) */
+	languages = g_get_language_names();
+	language_names = g_strjoinv(", ", (gchar **)languages);
+	purple_util_chrreplace(language_names, '_', '-');
+	g_string_append_printf(request, "Accept-Language: %s\r\n", language_names);
+	g_free(language_names);
+
+	purple_debug_info("facebook", "getting url %s\n", url);
+
+	g_string_append_printf(request, "\r\n");
+	if (method & FB_METHOD_POST)
+		g_string_append_printf(request, "%s", postdata);
+
+	/* If it needs to go over a SSL connection, we probably shouldn't print
+	 * it in the debug log.  Without this condition a user's password is
+	 * printed in the debug log */
+	if (method == FB_METHOD_POST)
+		purple_debug_info("facebook", "sending request data:\n%s\n",
+			postdata);
+
+	g_free(cookies);
+
+	fbconn = g_new0(FacebookConnection, 1);
+	fbconn->fba = fba;
+	fbconn->url = real_url;
+	fbconn->method = method;
+	fbconn->hostname = g_strdup(host);
+	fbconn->request = request;
+	fbconn->callback = callback_func;
+	fbconn->user_data = user_data;
+	fbconn->fd = -1;
+	fbconn->connection_keepalive = keepalive;
+	fbconn->request_time = time(NULL);
+	
+	g_queue_push_head(fba->waiting_conns, fbconn);
+	fb_next_connection(fba);
+}
+
+static void fb_next_connection(FacebookAccount *fba)
+{
+	FacebookConnection *fbconn;
+	
+	g_return_if_fail(fba != NULL);	
+	
+	if (!g_queue_is_empty(fba->waiting_conns))
+	{
+		if(g_slist_length(fba->conns) < FB_MAX_CONNECTIONS)
+		{
+			fbconn = g_queue_pop_tail(fba->waiting_conns);
+			fb_attempt_connection(fbconn);
+		}
+	}
+}
+
+static void fb_attempt_connection(FacebookConnection *fbconn)
+{
+	gboolean is_proxy = FALSE;
+	FacebookAccount *fba = fbconn->fba;
+	PurpleProxyInfo *proxy_info = NULL;
+
+	if (fba && fba->account && !(fbconn->method & FB_METHOD_SSL))
+	{
+		proxy_info = purple_proxy_get_setup(fba->account);
+		if (purple_proxy_info_get_type(proxy_info) == PURPLE_PROXY_USE_GLOBAL)
+			proxy_info = purple_global_proxy_get_info();
+		if (purple_proxy_info_get_type(proxy_info) == PURPLE_PROXY_HTTP)
+		{
+			is_proxy = TRUE;
+		}	
+	}
+
+#if 0
+	/* Connection to attempt retries.  This code doesn't work perfectly, but
+	 * remains here for future reference if needed */
+	if (time(NULL) - fbconn->request_time > 5) {
+		/* We've continuously tried to remake this connection for a 
+		 * bit now.  It isn't happening, sadly.  Time to die. */
+		purple_debug_error("facebook", "could not connect after retries\n");
+		fb_fatal_connection_cb(fbconn);
+		return;
+	}
+
+	purple_debug_info("facebook", "making connection attempt\n");
+
+	/* TODO: If we're retrying the connection, consider clearing the cached
+	 * DNS value.  This will require some juggling with the hostname param */
+	/* TODO/FIXME: This retries almost instantenously, which in some cases
+	 * runs at blinding speed.  Slow it down. */
+	/* TODO/FIXME: this doesn't retry properly on non-ssl connections */
+#endif
+	
+	fba->conns = g_slist_prepend(fba->conns, fbconn);
+
+	/*
+	 * Do a separate DNS lookup for the given host name and cache it
+	 * for next time.
+	 *
+	 * TODO: It would be better if we did this before we call
+	 *       purple_proxy_connect(), so we could re-use the result.
+	 *       Or even better: Use persistent HTTP connections for servers
+	 *       that we access continually.
+	 *
+	 * TODO: This cache of the hostname<-->IP address does not respect
+	 *       the TTL returned by the DNS server.  We should expire things
+	 *       from the cache after some amount of time.
+	 */
+	if (!is_proxy && !(fbconn->method & FB_METHOD_SSL) && !g_hostname_is_ip_address(fbconn->hostname))
+	{
+		/* Don't do this for proxy connections, since proxies do the DNS lookup */
+		gchar *host_ip;
+
+		host_ip = g_hash_table_lookup(fba->hostname_ip_cache, fbconn->hostname);
+		if (host_ip != NULL) {
+			g_free(fbconn->hostname);
+			fbconn->hostname = g_strdup(host_ip);
+		} else if (fba->account && !fba->account->disconnecting) {
+			GSList *host_lookup_list = NULL;
+			PurpleDnsQueryData *query;
+
+			host_lookup_list = g_slist_prepend(
+					host_lookup_list, g_strdup(fbconn->hostname));
+			host_lookup_list = g_slist_prepend(
+					host_lookup_list, fba);
+
+			query = purple_dnsquery_a(fbconn->hostname, 80,
+					fb_host_lookup_cb, host_lookup_list);
+			fba->dns_queries = g_slist_prepend(fba->dns_queries, query);
+			host_lookup_list = g_slist_append(host_lookup_list, query);
+		}
+	}
+
+	if (fbconn->method & FB_METHOD_SSL) {
+		fbconn->ssl_conn = purple_ssl_connect(fba->account, fbconn->hostname,
+				443, fb_post_or_get_ssl_connect_cb,
+				fb_ssl_connection_error, fbconn);
+	} else {
+		fbconn->connect_data = purple_proxy_connect(NULL, fba->account,
+				fbconn->hostname, 80, fb_post_or_get_connect_cb, fbconn);
+	}
+
+	return;
+}
+
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_connection.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_connection.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_connection.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_connection.h	2011-03-27 09:15:30.712552999 -0600
@@ -0,0 +1,62 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_CONNECTION_H
+#define FACEBOOK_CONNECTION_H
+
+#include "libfacebook.h"
+
+/*
+ * This is a bitmask.
+ */
+typedef enum
+{
+	FB_METHOD_GET  = 0x0001,
+	FB_METHOD_POST = 0x0002,
+	FB_METHOD_SSL  = 0x0004
+} FacebookMethod;
+
+typedef struct _FacebookConnection FacebookConnection;
+struct _FacebookConnection {
+	FacebookAccount *fba;
+	FacebookMethod method;
+	gchar *hostname;
+	gchar *url;
+	GString *request;
+	FacebookProxyCallbackFunc callback;
+	gpointer user_data;
+	char *rx_buf;
+	size_t rx_len;
+	PurpleProxyConnectData *connect_data;
+	PurpleSslConnection *ssl_conn;
+	int fd;
+	guint input_watcher;
+	gboolean connection_keepalive;
+	time_t request_time;
+};
+
+void fb_connection_destroy(FacebookConnection *fbconn);
+void fb_post_or_get(FacebookAccount *fba, FacebookMethod method,
+		const gchar *host, const gchar *url, const gchar *postdata,
+		FacebookProxyCallbackFunc callback_func, gpointer user_data,
+		gboolean keepalive);
+gchar *fb_cookies_to_string(FacebookAccount *fba);
+
+#endif /* FACEBOOK_CONNECTION_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_conversation.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_conversation.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_conversation.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_conversation.c	2011-03-27 09:15:30.860553000 -0600
@@ -0,0 +1,307 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_conversation.h"
+#include "fb_connection.h"
+#include "fb_util.h"
+#include "fb_json.h"
+
+#include "conversation.h"
+#include "signals.h"
+
+/*****************************************************************************
+ * MESSAGE PROCESSING                                                        *
+ *****************************************************************************/
+void fb_conversation_handle_message(FacebookAccount *fba, const char *from,
+	const char *to, gint64 message_time, const gchar *message_orig,
+	gboolean log)
+{
+	gchar *tmp, *message_text;
+
+	if (!log) {
+		purple_debug_info("facebook", "message with no logging\n");
+	}
+
+	// Process message.
+	message_text = fb_strdup_withhtml(message_orig);
+	tmp = message_text;
+	message_text = fb_replace_styled_text(message_text);
+	g_free(tmp);
+
+	if (fba->uid != atoll(from) || fba->uid == atoll(to)) {
+		purple_debug_info("facebook",
+			"displaying received message %lld: %s\n",
+			(long long int) message_time, message_text);
+		// TODO/FIXME: cheat here by changing formatting colors.
+		// Or add an option to just disable history on conv open.  TBD.
+		serv_got_im(fba->pc, from, message_text,
+			log? 
+				PURPLE_MESSAGE_RECV :
+				PURPLE_MESSAGE_RECV,
+			message_time / 1000);
+		if (message_time > fba->last_message_time) {
+			fba->last_message_time = message_time;
+		} else {
+			purple_debug_warning("facebook",
+					"displaying message out of sync\n");
+		}
+	} else if (!g_hash_table_remove(
+		fba->sent_messages_hash, message_orig))
+	{
+		purple_debug_info("facebook",
+			"displaying sent message %lld: %s\n",
+			(long long int) message_time, message_text);
+
+		serv_got_im(fba->pc, to, message_text,
+			log? 
+				PURPLE_MESSAGE_SEND :
+				PURPLE_MESSAGE_SEND,
+			message_time / 1000);
+		if (message_time > fba->last_message_time) {
+			fba->last_message_time = message_time;
+		} else {
+			purple_debug_warning("facebook",
+					"displaying message out of sync\n");
+		}
+	}
+
+	// Cleanup.
+	g_free(message_text);
+}
+
+void fb_conversation_handle_chat(FacebookAccount *fba, const char *from,
+	const char *group, gint64 message_time, const gchar *message_orig,
+	gboolean log)
+{
+	gchar *tmp, *message_text;
+
+	if (!log) {
+		purple_debug_info("facebook", "message with no logging\n");
+	}
+
+	// Process message.
+	message_text = fb_strdup_withhtml(message_orig);
+	tmp = message_text;
+	message_text = fb_replace_styled_text(message_text);
+	g_free(tmp);
+	
+	purple_debug_info("facebook",
+		"displaying group message %lld: %s\n",
+		(long long int) message_time, message_text);
+
+	if (!purple_find_conversation_with_account(PURPLE_CONV_TYPE_CHAT, group, fba->account))
+		serv_got_joined_chat(fba->pc, atoi(group), group);
+	
+	serv_got_chat_in(fba->pc, atoi(group), from, PURPLE_MESSAGE_RECV, message_text, message_time / 1000);
+
+	if (message_time > fba->last_message_time)
+	{
+		fba->last_message_time = message_time;
+	} else {
+		purple_debug_warning("facebook",
+				"displaying message out of sync\n");
+	}
+
+	// Cleanup.
+	g_free(message_text);
+}
+
+
+/*****************************************************************************
+ * HISTORY CODE                                                              *
+ *****************************************************************************/
+
+static void fb_history_fetch_cb(FacebookAccount *fba, const gchar *data,
+	gsize data_len, gpointer userdata)
+{
+	JsonParser *parser;
+	JsonObject *object, *payload;
+	JsonArray *history;
+	guint i;
+	gint64 min_time;
+
+	parser = fb_get_parser(data, data_len);
+
+	if (!parser) {
+		// We didn't get data, but this isn't necessarily fatal.
+		purple_debug_warning("facebook",
+			"bad data while fetching history\n");
+		return;
+	}
+
+	min_time = atoll((char *) userdata);
+	g_free(userdata);
+	purple_debug_info("facebook", "history fetch with min time of %lld\n",
+		       (long long int) min_time);	
+
+	object = fb_get_json_object(parser, NULL);
+	payload = json_node_get_object(
+		json_object_get_member(object, "payload"));
+	history = json_node_get_array(
+		json_object_get_member(payload, "history"));
+
+	purple_debug_info("facebook",
+			"found %d history items to possibly render\n",
+			json_array_get_length(history));
+
+	for (i = 0; i < json_array_get_length(history); i++) {
+		const gchar *type;
+		JsonObject *message_obj;
+
+		message_obj = json_node_get_object(
+			json_array_get_element(history, i));
+		type = json_node_get_string(json_object_get_member(
+			message_obj, "type"));
+	
+		if (g_str_equal(type, "msg")) {
+			gint64 message_time;
+			const gchar *message;
+			gchar *from;
+			gchar *to;
+			JsonObject *text_obj;
+
+			from = g_strdup_printf("%" G_GINT64_FORMAT, (gint64)json_node_get_int(
+				json_object_get_member(message_obj, "from")));
+			to = g_strdup_printf("%" G_GINT64_FORMAT, (gint64)json_node_get_int(
+				json_object_get_member(message_obj, "to")));
+
+			text_obj = json_node_get_object(
+				json_object_get_member(message_obj, "msg"));
+			message = json_node_get_string(
+				json_object_get_member(text_obj, "text"));
+
+			message_time = fb_time_kludge(json_node_get_int(
+				json_object_get_member(message_obj, "time")));
+
+			if (message_time > min_time) {
+				purple_debug_info("facebook",
+					"displaying history message %lld\n",
+					(long long int) message_time);
+				
+				//check to see that this isn't for a multi-user chat
+				if (purple_blist_find_chat(fba->account, to) ||
+					purple_find_conversation_with_account(
+						PURPLE_CONV_TYPE_CHAT, to, fba->account))
+				{
+					fb_conversation_handle_chat(
+						fba, from, to, message_time, message,
+						min_time != 0);
+				} else {
+					fb_conversation_handle_message(
+						fba, from, to, message_time, message,
+						min_time != 0);
+				}
+			}
+
+			g_free(from);
+			g_free(to);
+		}
+	}
+	
+	json_parser_free(parser);
+}
+
+void fb_history_fetch(FacebookAccount *fba, const char *who,
+		gboolean display_all)
+{
+	g_return_if_fail(fba != NULL);
+	
+	purple_debug_info("facebook", "fetching history with %s\n", who);
+
+	gint64 min_time = fba->last_message_time;
+	if (display_all) {
+		min_time = 0;
+	}
+
+	gchar *url = g_strdup_printf("/ajax/chat/history.php?id=%s&__a=1", who);
+	fb_post_or_get(
+		fba, FB_METHOD_GET, NULL, url, NULL, fb_history_fetch_cb,
+		g_strdup_printf("%lld", (long long int) min_time), FALSE);
+	g_free(url);
+}
+
+/*****************************************************************************
+ * GENERAL EVENTS CODE                                                       *
+ *****************************************************************************/
+
+void fb_conversation_closed(PurpleConnection *gc, const char *who)
+{
+	FacebookAccount *fba = gc->proto_data;
+	gchar *postdata;
+
+	g_return_if_fail(fba->post_form_id != NULL);
+
+	/* notify server that we closed the chat window */
+	/* close_chat=589039771&window_id=3168919846&
+	 * post_form_id=c258fe42460c7e8b61e242a37ef05afc */
+	postdata = g_strdup_printf("close_chat=%s&post_form_id=%s&fb_dtsg=%s&"
+			"post_form_id_source=AsyncRequest&__a=1", who,
+			fba->post_form_id, fba->dtsg);
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/chat/settings.php",
+			postdata, NULL, NULL, FALSE);
+	g_free(postdata);
+}
+
+static void fb_conversation_created(PurpleConversation *conv)
+{
+	PurpleAccount *account = purple_conversation_get_account(conv);
+
+	if (!fb_conversation_is_fb(conv)) {
+		return;
+	}
+
+	purple_debug_info("facebook", "conversation created with %s\n",
+		conv->name);
+
+	if (purple_account_get_bool(account, "facebook_show_history", TRUE))
+	{
+		fb_history_fetch(account->gc->proto_data, conv->name, TRUE);
+	}
+}
+
+gboolean fb_conversation_is_fb(PurpleConversation *conv)
+{
+	PurpleAccount *account = purple_conversation_get_account(conv);
+	const gchar *prpl = purple_account_get_protocol_id(account);
+	return g_str_equal(prpl, FACEBOOK_PLUGIN_ID);
+}
+
+void fb_conversation_init(FacebookAccount *fba)
+{
+	fba->last_message_time = 0;
+
+	purple_signal_connect(
+		purple_conversations_get_handle(),
+		"conversation-created",
+		fba,
+		PURPLE_CALLBACK(fb_conversation_created),
+		NULL);
+}
+
+void fb_conversation_destroy(FacebookAccount *fba)
+{
+	purple_signal_disconnect(
+		purple_conversations_get_handle(),
+		"conversation-created",
+		fba,
+		PURPLE_CALLBACK(fb_conversation_created));
+}
+
+
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_conversation.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_conversation.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_conversation.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_conversation.h	2011-03-27 09:15:30.852553000 -0600
@@ -0,0 +1,41 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_CONVERSATION_H
+#define FACEBOOK_CONVERSATION_H
+
+#include "libfacebook.h"
+
+void fb_conversation_init(FacebookAccount *fba);
+void fb_conversation_destroy(FacebookAccount *fba);
+
+void fb_conversation_closed(PurpleConnection *gc, const char *who);
+gboolean fb_conversation_is_fb(PurpleConversation *conv);
+
+void fb_history_fetch(FacebookAccount *fba, const char *who,
+		gboolean display_all);
+void fb_conversation_handle_message(FacebookAccount *fba, const char *from,
+	const char *to, gint64 message_time, const gchar *message_orig,
+	gboolean log);
+void fb_conversation_handle_chat(FacebookAccount *fba, const char *from,
+	const char *group, gint64 message_time, const gchar *message_orig,
+	gboolean log);
+
+#endif /* FACEBOOK_CONVERSATION_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_friendlist.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_friendlist.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_friendlist.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_friendlist.c	2011-03-27 09:15:30.856552999 -0600
@@ -0,0 +1,520 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_friendlist.h"
+#include "fb_connection.h"
+#include "libfacebook.h"
+#include "fb_util.h"
+
+typedef struct _MoveRequest MoveRequest;
+struct _MoveRequest {
+	char *old_group;
+	char *new_group;
+	char *who;
+};
+
+/******************************************************************************/
+/* Friend list modification methods */
+/******************************************************************************/
+static void handle_move_request(FacebookAccount *fba, MoveRequest *request)
+{
+	const gchar *old_list_id;
+	const gchar *new_list_id;
+	gchar *postdata;
+	gboolean remove_flist, no_original_list;
+	const gchar *command;
+
+	purple_debug_info("facebook",
+		"handling movement of %s from %s to %s\n",
+		request->who, request->old_group, request->new_group);
+
+	old_list_id = fb_get_list_id(fba, request->old_group);
+	new_list_id = fb_get_list_id(fba, request->new_group);
+
+	remove_flist = !new_list_id || g_str_equal(new_list_id, "-1");
+	no_original_list = !old_list_id || g_str_equal(old_list_id, "-1");
+
+	if (remove_flist) {
+		command = "&remove_fl=true";
+	} else if (no_original_list) {
+		command = "&add_fl=true";
+	} else {
+		command = "&move_fl=true";
+	}
+
+	postdata = g_strdup_printf(
+		"post_form_id=%s&drag_uid=%s&user=%" G_GINT64_FORMAT
+		"&new_flid=%s&old_flid=%s%s",
+		fba->post_form_id,
+		request->who,
+		fba->uid,
+		remove_flist ? "" : new_list_id,
+		no_original_list ? "" : old_list_id,
+		command);
+
+	fb_post_or_get(fba, FB_METHOD_POST, NULL,
+		"/ajax/chat/buddy_list_settings.php",
+		postdata, NULL, NULL, FALSE);
+
+	g_free(postdata);
+
+	g_free(request->who);
+	g_free(request->old_group);
+	g_free(request->new_group);
+	g_free(request);
+}
+
+static void create_list_cb(FacebookAccount *fba, const gchar *data,
+	gsize data_len, gpointer userdata)
+{
+	// NOTE: this method can also be used for movements between
+	// friend lists if necessary.
+
+	JsonParser *parser;
+	JsonObject *objnode;
+	MoveRequest *request;
+
+	// Parse out old data.
+	parser = fb_get_parser(data, data_len);
+	if (parser == NULL) {
+		return;
+	}
+
+	objnode = fb_get_json_object(parser, NULL);
+	if (!objnode ||
+	    !json_object_has_member(objnode, "payload"))
+	{
+		json_parser_free(parser);
+		return;
+	}
+
+	objnode = json_node_get_object(json_object_get_member(
+			objnode, "payload"));
+	fb_process_friend_lists(fba, objnode);
+
+	json_parser_free(parser);
+
+	// Move Friend
+	request = (MoveRequest *) userdata;
+	if (request) {
+		handle_move_request(fba, request);
+	}
+}
+
+static void create_friend_list(FacebookAccount *fba, const gchar *new_group,
+	MoveRequest *request)
+{
+	gchar *postdata;
+	gchar *new_group_escaped;
+
+	purple_debug_info("facebook", "creating friend list %s\n", new_group);
+
+	new_group_escaped = fb_strdup_withhtml(new_group);
+
+	postdata = g_strdup_printf(
+		"post_form_id=%s&create=%s&user=%" G_GINT64_FORMAT,
+		fba->post_form_id,
+		new_group_escaped,
+		fba->uid);
+
+	fb_post_or_get(fba, FB_METHOD_POST, NULL,
+		"/ajax/chat/buddy_list_settings.php",
+		postdata, create_list_cb, request, FALSE);
+
+	g_free(postdata);
+	g_free(new_group_escaped);
+}
+
+void fb_group_buddy_move(PurpleConnection *pc, const char *who,
+	const char *old_group, const char *new_group)
+{
+	FacebookAccount *fba;
+	MoveRequest *request;
+	const gchar *new_list_id;
+	
+	if (!purple_account_get_bool(pc->account, "facebook_use_groups", TRUE))
+	{
+		//Dont do anything if we're ignoring groups
+		return;
+	}
+	
+	fba = pc->proto_data;
+
+	purple_debug_info("facebook", "handling move of %s from %s to %s\n",
+		who, old_group, new_group);
+
+	// Don't do anything if groups are not actually changing.
+	if (!purple_utf8_strcasecmp(old_group, new_group)) {
+		purple_debug_info("facebook", "groups are same, not moving\n");
+		return;
+	}
+
+	// Facebook doesn't support moving yourself because you can't be in a
+	// friend list.  Let buddy list be updated as appropriate.
+	if (atoll(who) == fba->uid) {
+		purple_debug_info("facebook",
+			"moving self, do not update server\n");
+		return;
+	}
+
+	request = g_new0(MoveRequest, 1);
+	request->old_group = g_utf8_strdown(old_group, -1);
+	request->new_group = g_utf8_strdown(new_group, -1);
+	request->who = g_strdup(who);
+
+	new_list_id = fb_get_list_id(fba, request->new_group);
+	if (new_list_id) {
+		handle_move_request(fba, request);
+	} else {
+		create_friend_list(fba, new_group, request);
+	}
+}
+
+void fb_buddy_remove(PurpleConnection *pc, PurpleBuddy *buddy,
+		PurpleGroup *group)
+{
+	// This method should only remove a buddy from a friend list.
+	// Nothing more.  It should not defriend a user ever.  See issue
+	// #185 for a good explaination of why this is a bad idea.
+	//
+	// Moreover, defriending is such a rare operation that we should
+	// never make it easy.  Facebook intentionally hides such a action
+	// behind multiple layers of links and dialogs.
+	//
+	// If the plugin is ever to perform an actual defriending, it needs
+	// to provide a dialog and user prompt at the absolute bare minimum.
+	FacebookAccount *fba;
+	
+	if (!purple_account_get_bool(pc->account, "facebook_use_groups", TRUE))
+	{
+		//Dont do anything if we're ignoring groups
+		return;
+	}
+
+	purple_debug_info("facebook", "handing removal of buddy %s\n",
+		buddy->name);
+       
+	fba = pc->proto_data;
+
+	fb_group_buddy_move(pc, buddy->name, purple_group_get_name(group),
+			DEFAULT_GROUP_NAME);
+}
+
+void fb_group_rename(PurpleConnection *pc, const char *old_name,
+	PurpleGroup *group, GList *moved_buddies)
+{
+	
+	if (!purple_account_get_bool(pc->account, "facebook_use_groups", TRUE))
+	{
+		//Dont do anything if we're ignoring groups
+		return;
+	}
+	
+	purple_debug_info("facebook",
+		"handling group rename of %s to %s\n",
+		old_name, purple_group_get_name(group));
+	
+	// We don't do anything here.  Facebook's AJAX API for renaming groups
+	// is horribly, horribly overcomplicated.  There is no simple rename
+	// call, instead you must also pass in all the current data about the
+	// friend list and port it over.  While it is possible to implement
+	// this, it is risky and could potentially destroy a friend list if
+	// the API changes.  That's a Bad Thing(tm).  Given the risk involved
+	// with this operation and how rare it is, it's not worth it.
+	// 
+	// The problem is compounded by the fact that renaming groups triggers
+	// all sorts of weird behaviors in Pidgin.  Renaming to a new name is
+	// simple.  Renaming to an existing group name (hence a merge)
+	// triggers completely different behavior with calls to group_buddy
+	// before the call to rename.  This completely defeats the purpose of
+	// having a rename function because group_buddy is called instead.
+	//
+	// Thus, the final decision is to use the buddy_move call.
+
+	// TODO: warn users that renaming has no effect here.
+}
+
+void fb_group_remove(PurpleConnection *pc, PurpleGroup *group)
+{
+	if (!purple_account_get_bool(pc->account, "facebook_use_groups", TRUE))
+	{
+		//Dont do anything if we're ignoring groups
+		return;
+	}
+	
+	purple_debug_info("facebook", "got group removal of %s\n",
+		purple_group_get_name(group));
+
+	// We don't do anything here.  This is because a group rename also
+	// fires a group removal event.  This assumes that the new group is
+	// equivalent to the old group, but Facebook friend lists are much more
+	// than simple groups- they are privacy control lists too.  There is
+	// no easy way to port the settings between groups.  Better off not
+	// deleting, and the user can do the cleanup with their browser.
+}
+
+/******************************************************************************/
+/* Friend list fetch methods */
+/******************************************************************************/
+
+const gchar *fb_get_list_id(FacebookAccount *fba, const gchar *list_name)
+{
+	if (!purple_utf8_strcasecmp(list_name, DEFAULT_GROUP_NAME)) {
+		return "-1";
+	}
+
+	return g_hash_table_lookup(fba->friend_lists_reverse, purple_normalize_nocase(NULL, list_name));
+}
+
+gboolean fb_process_friend_lists(FacebookAccount *fba,
+		JsonObject *buddy_list)
+{
+	JsonObject *fl_obj;
+	GList *friend_list_ids, *cur;
+
+	purple_debug_info("facebook", "processing friend list data\n");
+
+	if (!json_object_has_member(buddy_list, "flData"))
+	{
+		purple_debug_info("facebook", "no friend list data\n");
+		return FALSE;
+	}
+
+
+	fl_obj = json_node_get_object(json_object_get_member(
+			buddy_list, "flData"));
+	friend_list_ids = json_object_get_members(fl_obj);
+	for (cur = friend_list_ids; cur != NULL; cur = cur->next)
+	{
+		gchar *id;
+		const gchar *name;
+		JsonObject *data;
+
+		id = (gchar *) cur->data;
+		data = json_node_get_object(json_object_get_member(
+				fl_obj, id));
+		name = json_node_get_string(json_object_get_member(
+				data, "n"));
+		if (name) {
+			// Either -1 isnt a valid JSON string or JSON-glib does
+			// this wrong.  I'm too tired to tell the difference.
+			if (g_str_equal(id, "_1")) {
+				id = "-1";
+			}
+			purple_debug_info("facebook",
+					"got friend list %s with id %s\n",
+					name, id);
+			g_hash_table_insert(fba->friend_lists,
+					g_strdup(id), g_strdup(name));
+			g_hash_table_insert(fba->friend_lists_reverse,
+					g_utf8_strdown(name, -1), g_strdup(id));
+		}
+	}
+
+	g_list_free(friend_list_ids);
+
+	return TRUE;
+}
+
+static void destroy_buddy(gpointer key, gpointer value, gpointer data)
+{
+	PurpleBuddy *buddy;
+	gchar *group_name;
+	FacebookAccount *fba;
+
+	buddy = (PurpleBuddy *) value;
+	group_name = (gchar *) key;
+	fba = (FacebookAccount *) data;
+
+	purple_debug_info("facebook", "removing %s from group %s\n",
+			buddy->name, group_name);
+	if (atoll(buddy->name) == fba->uid) {
+		purple_debug_info("facebook", "not removing self from %s\n",
+			group_name);
+		return;
+	}
+
+	purple_blist_remove_buddy(buddy);
+}
+
+static PurpleBuddy *add_buddy(FacebookAccount *fba,
+	const gchar *friend_list_id, const gchar *uid, GHashTable *cur_groups)
+{
+	const gchar *group_name;
+	PurpleGroup *fb_group;
+	PurpleBuddy *buddy;
+
+	group_name = g_hash_table_lookup(fba->friend_lists, purple_normalize_nocase(NULL, friend_list_id));
+	if (!group_name || group_name[0] == '\0') {
+		purple_debug_info("facebook",
+				"did not find name of list %s\n",
+				friend_list_id);
+		group_name = DEFAULT_GROUP_NAME;
+	}
+
+	// Initialize group as necessary.
+	fb_group = purple_find_group(group_name);
+	if (fb_group == NULL)
+	{
+		purple_debug_info("facebook", "adding friend list %s\n",
+				group_name);
+		fb_group = purple_group_new(group_name);
+		purple_blist_add_group(fb_group, NULL);
+	} 
+
+	buddy = (PurpleBuddy *)g_hash_table_lookup(cur_groups, purple_normalize_nocase(NULL, group_name));
+	if (!buddy) {
+		purple_debug_info("facebook", "adding %s to %s\n",
+				uid, group_name);
+		buddy = purple_buddy_new(fba->account, uid, NULL);
+		purple_blist_add_buddy(buddy, NULL, fb_group, NULL);
+		g_hash_table_remove(cur_groups, purple_normalize_nocase(NULL, group_name));
+	}
+
+	return buddy;
+}
+
+
+GList *fb_get_buddies_friend_list (FacebookAccount *fba,
+		const gchar *uid, JsonArray *friend_list_ids)
+{
+	GSList *buddies;
+	GSList *cur;       
+	GHashTable *cur_groups;
+	int i;
+	GList *final_buddies, *cur_buddy;
+	PurpleGroup *fb_group;
+	PurpleBuddy *buddy;
+
+	final_buddies = NULL;
+	buddies = purple_find_buddies(fba->account, uid);
+
+	// If we're already in the buddy list, stop.  Ignore FB info because
+	// it will be incorrect.
+	if (atoll(uid) == fba->uid && buddies != NULL) {
+		purple_debug_info("facebook",
+			"already have buddies for self, not adding\n");
+		for (cur = buddies; cur != NULL; cur = cur->next)
+		{
+			final_buddies = g_list_append(
+				final_buddies, cur->data);
+		}
+		g_slist_free(buddies);
+		return final_buddies;
+	}
+	
+	//Do we want to ignore groups?
+	if (!purple_account_get_bool(fba->account, "facebook_use_groups", TRUE))
+	{
+		if (buddies != NULL) {
+			//Copy the slist into the list
+			for (cur = buddies; cur != NULL; cur = cur->next)
+			{
+				final_buddies = g_list_append(
+					final_buddies, cur->data);
+			}
+			g_slist_free(buddies);
+			return final_buddies;
+		} else {
+			buddy = purple_buddy_new(fba->account, uid, NULL);
+			fb_group = purple_find_group(DEFAULT_GROUP_NAME);
+			if (fb_group == NULL)
+			{
+				fb_group = purple_group_new(DEFAULT_GROUP_NAME);
+				purple_blist_add_group(fb_group, NULL);
+			}
+			purple_blist_add_buddy(buddy, NULL, fb_group, NULL);
+			final_buddies = g_list_append(final_buddies, buddy);
+			return final_buddies;
+		}
+	}
+	
+	// Determine what buddies exist and what groups they are in.
+	cur_groups = g_hash_table_new_full(g_str_hash, g_str_equal,
+		g_free, NULL);
+	for (cur = buddies; cur != NULL; cur = cur->next)
+	{
+		const gchar *group_name;
+
+		group_name = purple_group_get_name(purple_buddy_get_group(
+					(PurpleBuddy *)cur->data));
+		group_name = purple_normalize_nocase(NULL, group_name);
+		
+		g_hash_table_insert(cur_groups, g_strdup(group_name), cur->data);
+	}
+	g_slist_free(buddies);
+
+	// Create/insert necessary buddies
+	if (friend_list_ids) {
+		for (i = 0; i < json_array_get_length(friend_list_ids); i++)
+		{
+			const gchar *friend_list_id;
+
+			friend_list_id = json_node_get_string(
+				json_array_get_element(friend_list_ids, i));
+
+			buddy = add_buddy(fba, friend_list_id, uid, cur_groups);
+
+			final_buddies = g_list_append(final_buddies, buddy);
+		}
+	} else {
+		// No friend list data, so we use the default group.
+		final_buddies = g_list_append(final_buddies,
+			add_buddy(fba, "-1", uid, cur_groups));
+	}
+
+	// Figure out which groups/buddies are not represented.
+	for (cur_buddy = final_buddies; cur_buddy != NULL;
+	     cur_buddy = cur_buddy->next)
+	{
+		const gchar *group_name = purple_group_get_name(purple_buddy_get_group(
+					(PurpleBuddy *)cur_buddy->data));
+		g_hash_table_remove(cur_groups, purple_normalize_nocase(NULL, group_name));
+	}
+
+	// Delete remaining buddies to maintain sync state with server.
+	g_hash_table_foreach(cur_groups, destroy_buddy, fba);
+
+	// Cleanup!
+	g_hash_table_destroy(cur_groups);
+
+	return final_buddies;
+}
+
+void fb_friendlist_init(FacebookAccount *fba)
+{
+	/* data structure mapping friend list id to name.  libpurple only
+	 * recognizes name, does not have group aliases */
+	fba->friend_lists = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, g_free);
+	/* structure mapping names to list id for speed. */
+	fba->friend_lists_reverse = g_hash_table_new_full(g_str_hash,
+			g_str_equal, g_free, g_free);
+}
+
+void fb_friendlist_destroy(FacebookAccount *fba)
+{
+	if (fba->friend_lists) {
+		g_hash_table_destroy(fba->friend_lists);
+	}
+	if (fba->friend_lists_reverse) {
+		g_hash_table_destroy(fba->friend_lists_reverse);
+	}
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_friendlist.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_friendlist.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_friendlist.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_friendlist.h	2011-03-27 09:15:30.688552999 -0600
@@ -0,0 +1,47 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_FRIENDLIST_H
+#define FACEBOOK_FRIENDLIST_H
+
+#include "libfacebook.h"
+#include "fb_json.h"
+
+#define DEFAULT_GROUP_NAME "Facebook"
+
+/* Friend list modification methods */
+void fb_group_buddy_move(PurpleConnection *pc, const char *who,
+	const char *old_group, const char *new_group);
+void fb_group_rename(PurpleConnection *pc, const char *old_name,
+	PurpleGroup *group, GList *moved_buddies);
+void fb_group_remove(PurpleConnection *pc, PurpleGroup *group);
+void fb_buddy_remove(PurpleConnection *pc, PurpleBuddy *buddy,
+	PurpleGroup *group);
+
+/* Friend list fetch methods */
+const gchar *fb_get_list_id(FacebookAccount *fba, const gchar *list_name);
+gboolean fb_process_friend_lists(FacebookAccount *fba, JsonObject *buddy_list);
+GList *fb_get_buddies_friend_list (FacebookAccount *fba,
+		const gchar *uid, JsonArray *friend_list_ids);
+
+void fb_friendlist_init(FacebookAccount *fba);
+void fb_friendlist_destroy(FacebookAccount *fba);
+
+#endif /* FACEBOOK_FRIENDLIST_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_info.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_info.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_info.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_info.c	2011-03-27 09:15:30.912552999 -0600
@@ -0,0 +1,237 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_connection.h"
+#include "fb_info.h"
+#include "fb_blist.h"
+
+/*
+ * TODO: Do we really want to do this?  Maybe we could just set a
+ *       flag that says that this protocol supports HTML?
+ */
+static gchar *fb_remove_useless_stripped_links(const gchar *input)
+{
+	/* removes stripped links like "(/s.php? ... )" from user info */
+	/* as an artifact of purple_markup_strip_html */
+
+	gchar *output = g_strdup(input);
+	gchar *i = output;
+	gchar *end;
+
+	while ((i = strstr(i, " (/")))
+	{
+		end = strchr(i, ')');
+		if (end)
+		{
+			end += 1;
+			/* overwrite everything after the brackets to before it */
+			g_stpcpy(i, end);
+		}
+	}
+
+	return output;
+}
+
+static void fb_get_info_cb(FacebookAccount *fba, const gchar *data, gsize data_len, gpointer user_data)
+{
+	PurpleNotifyUserInfo *user_info;
+	PurpleBuddyIcon *buddy_icon;
+	size_t image_size;
+	gconstpointer image_pointer;
+	int icon_id = -1;
+	gchar *uid = user_data;
+	gchar *label_tmp;
+	gchar *value_tmp;
+	gchar *value_tmp2;
+	gchar *search_start;
+	gchar *search_end;
+	PurpleBuddy *buddy = NULL;
+	FacebookBuddy *fbuddy = NULL;
+
+	purple_debug_info("facebook", "get_info_cb\n");
+	purple_debug_misc("facebook", "%s\n", data);
+
+	buddy = purple_find_buddy(fba->account, uid);
+	if (buddy)
+	{
+		fbuddy = buddy->proto_data;
+	}
+	
+	/* look from <div id="info_tab" class="info_tab"> */
+	/* until </div></div></div></div> */
+	search_start = g_strstr_len(data, data_len, "<div id=\"info_tab\" class=\"info_tab\">");
+	if (search_start == NULL)
+	{
+		search_start = g_strstr_len(data, data_len, "window.location.replace(\"http:\\/\\/www.facebook.com\\");
+		if (search_start)
+		{
+			search_start += strlen("window.location.replace(\"http:\\/\\/www.facebook.com\\");
+			search_end = strchr(search_start, '"');
+			value_tmp = g_strndup(search_start, search_end - search_start);
+			if (value_tmp) {
+				purple_debug_info("facebook", "info url: %s\n", value_tmp);
+				fb_post_or_get(fba, FB_METHOD_GET, NULL, value_tmp, NULL, fb_get_info_cb, uid, FALSE);
+				g_free(value_tmp);
+				return;
+			}
+		}
+		purple_debug_warning("facebook",
+				"could not find user info, showing default");
+		user_info = purple_notify_user_info_new();
+		value_tmp = g_strdup_printf("<a href=\"http://www.facebook.com/profile.php?id=%s\">%s</a>",
+				uid, _("View web profile"));
+		purple_notify_user_info_add_pair(user_info, NULL, value_tmp);
+		purple_notify_user_info_add_section_break(user_info);
+		g_free(value_tmp);
+		purple_notify_userinfo(fba->pc, uid, user_info, NULL, NULL);
+		purple_notify_user_info_destroy(user_info);
+		g_free(uid);
+		return;
+	}
+	search_end = strstr(search_start, "</div></div></div></div>");
+
+	user_info = purple_notify_user_info_new();
+
+	/* Insert link to profile at top */
+	value_tmp = g_strdup_printf("<a href=\"http://www.facebook.com/profile.php?id=%s\">%s</a>",
+			uid, _("View web profile"));
+	purple_notify_user_info_add_pair(user_info, NULL, value_tmp);
+	purple_notify_user_info_add_section_break(user_info);
+	g_free(value_tmp);
+
+	value_tmp = g_strstr_len(data, data_len, "<title>Facebook | ");
+	if (value_tmp)
+	{
+		value_tmp = strchr(value_tmp, '|')+2;
+		value_tmp2 = g_strndup(value_tmp, strstr(value_tmp, "</title>")-value_tmp);
+		value_tmp = g_strchomp(purple_markup_strip_html(value_tmp2));
+		purple_notify_user_info_add_pair(user_info, _("Name"), value_tmp);
+		fb_blist_set_alias(fba, uid, value_tmp);
+		g_free(value_tmp);
+		g_free(value_tmp2);
+	}
+
+	value_tmp = g_strstr_len(data, data_len, "<span id=\"profile_status\"");
+	if (value_tmp)
+	{
+		value_tmp2 = strstr(value_tmp, "</span>");
+		if (value_tmp2)
+		{
+			value_tmp = strchr(value_tmp, '>')+1;
+			value_tmp2 = g_strndup(value_tmp, strchr(value_tmp, '<')-value_tmp);
+			purple_debug_info("facebook", "status: %s\n", value_tmp2);
+			value_tmp = g_strchomp(purple_markup_strip_html(value_tmp2));
+			if (*value_tmp == '\0')
+			{
+				//For some reason their status message disappeared
+				//Try using their status message from the buddy list
+				if (fbuddy)
+				{
+					g_free(value_tmp);
+					value_tmp = g_strdup(fbuddy->status);
+				}
+			}
+			purple_notify_user_info_add_pair(user_info, _("Status"), value_tmp);
+			g_free(value_tmp);
+			g_free(value_tmp2);
+		}
+	}
+
+	buddy_icon = purple_buddy_icons_find(fba->account, uid);
+	if (buddy_icon)
+	{
+		image_pointer = purple_buddy_icon_get_data(buddy_icon, &image_size);
+		icon_id = purple_imgstore_add_with_id(g_memdup(image_pointer, image_size), image_size, NULL);
+		value_tmp = g_strdup_printf("<img id='%d'>", icon_id);
+		purple_debug_info("facebook", "user info pic: '%s'\n", value_tmp);
+		purple_notify_user_info_add_pair(user_info, NULL, value_tmp);
+		g_free(value_tmp);
+	}
+
+	while ((search_start = strstr(search_start, "<dt>")) && search_start < search_end)
+	{
+		search_start += 4;
+		if (search_start[0] == '<' && search_start[1] == '/' && search_start[2] == 'd' && search_start[3] == 't')
+		{
+			/* the tag closes as soon as it opens (bad xhtml) */
+			continue;
+		}
+
+		label_tmp = g_strndup(search_start, strchr(search_start, ':')-search_start);
+		if (!*label_tmp)
+		{
+			g_free(label_tmp);
+			continue;
+		}
+
+		search_start = strstr(search_start, "<dd>");
+		if (!search_start)
+		{
+			g_free(label_tmp);
+			break;
+		}
+
+		search_start += 4;
+		value_tmp = g_strndup(search_start, strstr(search_start, "</dd>")-search_start);
+		if (!*value_tmp)
+		{
+			g_free(label_tmp);
+			g_free(value_tmp);
+			continue;
+		}
+
+		/* turn html to plaintext */
+		if (strcmp(label_tmp, "AIM")) {
+			value_tmp2 = g_strchomp(purple_markup_strip_html(value_tmp));
+			g_free(value_tmp);
+			value_tmp = value_tmp2;
+
+			/* remove the silly links */
+			value_tmp2 = fb_remove_useless_stripped_links(value_tmp);
+			g_free(value_tmp);
+			value_tmp = value_tmp2;
+		}
+
+		purple_debug_info("facebook", "label: %s\n", label_tmp);
+		purple_debug_info("facebook", "value: %s\n", value_tmp);
+		purple_notify_user_info_add_pair(user_info, label_tmp, value_tmp);
+		g_free(label_tmp);
+		g_free(value_tmp);
+	}
+
+	purple_notify_userinfo(fba->pc, uid, user_info, NULL, NULL);
+	purple_notify_user_info_destroy(user_info);
+
+	if (icon_id >= 0)
+		purple_imgstore_unref_by_id(icon_id);
+
+	g_free(uid);
+}
+
+void fb_get_info(PurpleConnection *pc, const gchar *uid)
+{
+	gchar *profile_url;
+
+	profile_url = g_strdup_printf("/profile.php?id=%s&v=info", uid);
+
+	fb_post_or_get(pc->proto_data, FB_METHOD_GET, NULL, profile_url, NULL, fb_get_info_cb, g_strdup(uid), FALSE);
+
+	g_free(profile_url);
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_info.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_info.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_info.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_info.h	2011-03-27 09:15:30.876553000 -0600
@@ -0,0 +1,28 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_INFO_H
+#define FACEBOOK_INFO_H
+
+#include "libfacebook.h"
+
+void fb_get_info(PurpleConnection *pc, const gchar *uid);
+
+#endif /* FACEBOOK_INFO_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_json.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_json.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_json.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_json.c	2011-03-27 09:15:30.892553000 -0600
@@ -0,0 +1,87 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_json.h"
+
+#ifdef USE_JSONC
+
+JsonParser *
+json_parser_new(void)
+{
+	JsonParser *parser;
+	
+	parser = g_new0(JsonParser, 1);
+	parser->tok = json_tokener_new();
+	
+	return parser;
+}
+
+gboolean 
+json_parser_load_from_data(JsonParser *parser, const gchar *data,
+                           gssize length, GError **error)
+{
+	if (parser->tok == NULL)
+		return FALSE;
+
+	parser->root = json_tokener_parse_ex(parser->tok, (char*)data, (int)length);
+	
+	if (parser->tok->err != json_tokener_success)
+	{
+		json_object_put(parser->root);
+		parser->root = NULL;
+		return FALSE;
+	}
+	
+	return TRUE;
+}
+
+void
+json_parser_free(JsonParser *parser)
+{
+	json_tokener_free(parser->tok);
+	json_object_put(parser->root);
+	g_free(parser);
+}
+
+JsonNode *
+json_parser_get_root(JsonParser *parser)
+{
+	return parser->root;
+}
+
+GList *
+json_object_get_members(JsonObject *obj)
+{
+	GList *keys = NULL;
+	struct lh_entry *entry;	
+
+	for (entry = json_object_get_object(obj)->head;
+		entry;
+		entry = entry->next)
+	{
+		keys = g_list_prepend(keys, entry->k);
+	}
+	
+	keys = g_list_reverse(keys);
+	
+	return keys;
+}
+
+#endif
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_json.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_json.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_json.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_json.h	2011-03-27 09:15:30.744552999 -0600
@@ -0,0 +1,64 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_JSON_H
+#define FACEBOOK_JSON_H
+
+#ifndef USE_JSONC
+#	include <json-glib/json-glib.h>
+#define json_parser_free(parser) g_object_unref(parser)
+#else /* USE_JSONC */
+#	include <glib.h>
+#	include <json/json.h>
+typedef struct json_object JsonNode;
+typedef struct json_object JsonObject;
+typedef struct json_object JsonArray;
+typedef struct {
+	struct json_tokener *tok;
+	struct json_object *root;
+} JsonParser;
+
+gboolean json_parser_load_from_data(JsonParser *parser,
+									const gchar *data,
+                                    gssize length,
+                                    GError **error);
+
+JsonNode* json_parser_get_root(JsonParser *parser);
+JsonParser* json_parser_new(void);
+void json_parser_free(JsonParser *parser);
+
+#define json_object_has_member(obj, key) ((gboolean)json_object_object_get(obj, key))
+#define json_object_get_member(obj, key) json_object_object_get(obj, key)
+GList* json_object_get_members(JsonObject *object);
+
+#define json_node_get_array(node) (node)
+#define json_node_get_object(node) (node)
+#define json_node_get_boolean(node) json_object_get_boolean(node)
+#define json_node_get_double(node) json_object_get_double(node)
+#define json_node_get_int(node) json_object_get_int(node)
+#define json_node_get_string(node) json_object_get_string(node)
+
+#define json_array_get_element(array, index) json_object_array_get_idx(array, index)
+#define json_array_get_length(array) json_object_array_length(array)
+
+#endif /* USE_JSONC */
+
+#endif /* FACEBOOK_JSON_H */
+
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_managefriends.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_managefriends.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_managefriends.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_managefriends.c	2011-03-27 09:15:30.868553000 -0600
@@ -0,0 +1,233 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_managefriends.h"
+#include "fb_connection.h"
+
+static void fb_auth_accept_cb(gpointer data)
+{
+	FacebookBuddy *fbuddy = data;
+	FacebookAccount *fba = fbuddy->fba;
+	gchar *buddy_uid;
+	gchar *postdata;
+
+	g_return_if_fail(fba != NULL);
+	g_return_if_fail(fba->post_form_id != NULL);
+	g_return_if_fail(fbuddy->uid != 0);
+
+	buddy_uid = g_strdup_printf("%" G_GINT64_FORMAT, fbuddy->uid);
+
+	postdata = g_strdup_printf(
+			"type=friend_connect&id=%s&actions[accept]=Confirm&"
+			"post_form_id=%s&fb_dtsg=%s&confirm=%s&"
+			"post_form_id_source=AsyncRequest&__a=1",
+			buddy_uid, fba->post_form_id, fba->dtsg, buddy_uid);
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/reqs.php",
+			postdata, NULL, NULL, FALSE);
+
+	g_hash_table_remove(fba->auth_buddies, buddy_uid);
+	
+	g_free(postdata);
+	g_free(fbuddy);
+	g_free(buddy_uid);
+}
+
+static void fb_auth_reject_cb(gpointer data)
+{
+	FacebookBuddy *fbuddy = data;
+	FacebookAccount *fba = fbuddy->fba;
+	gchar *buddy_uid;
+	gchar *postdata;
+
+	g_return_if_fail(fba != NULL);
+	g_return_if_fail(fba->post_form_id != NULL);
+	g_return_if_fail(fbuddy->uid != 0);
+
+	buddy_uid = g_strdup_printf("%" G_GINT64_FORMAT, fbuddy->uid);
+
+	postdata = g_strdup_printf(
+			"type=friend_connect&id=%s&action=reject&"
+			"post_form_id=%s&fb_dtsg=%s&"
+			"post_form_id_source=AsyncRequest&__a=1",
+			buddy_uid, fba->post_form_id, fba->dtsg);
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/reqs.php",
+			postdata, NULL, NULL, FALSE);
+
+	g_hash_table_remove(fba->auth_buddies, buddy_uid);
+	
+	g_free(postdata);
+	g_free(fbuddy);
+	g_free(buddy_uid);
+}
+
+static void fb_check_friend_request_cb(FacebookAccount *fba, const gchar *data,
+		gsize data_len, gpointer user_data)
+{
+	const char *uid_pre_text = "class=\"confirm\" id=\"friend_connect_";
+	const char *name_pre_text = "<td class=\"info\"><a ";
+	const char *msg_pre_text = "<div class=\"personal_msg\"><span>";
+	gchar *uid;
+	gint64 uid_int;
+	gchar *name;
+	gchar *msg;
+	gchar *msg_plain;
+	FacebookBuddy *buddy;
+	const gchar *search_start = data;
+
+	g_return_if_fail(data_len > 0);
+	g_return_if_fail(data != NULL);
+
+	/* loop through the data and look for confirm_friend_add_([0-9]*)" */
+	while ((search_start = strstr(search_start, uid_pre_text)))
+	{
+		search_start += strlen(uid_pre_text);
+		uid = g_strndup(search_start,
+				strchr(search_start, '"') - search_start);
+		purple_debug_info("facebook", "uid: %s\n", uid);
+
+		uid_int = atoll(uid);
+
+		if (g_hash_table_lookup_extended(fba->auth_buddies,
+						uid, NULL, NULL))
+		{
+			/* we've already notified the user of this friend request */
+			g_free(uid);
+			continue;
+		}
+
+		name = strstr(search_start, name_pre_text);
+		if (name != NULL)
+		{
+			name += strlen(name_pre_text);
+			name = strchr(name, '>') + 1;
+			name = g_strndup(name, strchr(name, '<') - name);
+			purple_debug_info("facebook", "name: %s\n", name);
+		} else {
+			name = NULL;
+		}
+
+		msg = strstr(search_start, msg_pre_text);
+		if (msg != NULL)
+		{
+			msg += strlen(msg_pre_text);
+			msg = g_strndup(msg, strstr(msg, "</span></div>") - msg);
+			msg_plain = purple_markup_strip_html(msg);
+			g_free(msg);
+			purple_debug_info("facebook", "msg: %s\n", msg_plain);
+		} else {
+			msg_plain = NULL;
+		}
+
+		buddy = g_new0(FacebookBuddy, 1);
+		buddy->fba = fba;
+		buddy->uid = uid_int;
+		purple_account_request_authorization(
+				fba->account, uid, NULL,
+				name, msg_plain, TRUE,
+				fb_auth_accept_cb, fb_auth_reject_cb, buddy);
+
+		/* Don't display an auth request for this buddy again */
+		g_hash_table_insert(fba->auth_buddies, uid, NULL);
+		
+		g_free(name);
+		g_free(msg_plain);		
+	}
+}
+
+gboolean fb_check_friend_requests(gpointer data)
+{
+	FacebookAccount *fba;
+
+	fba = data;
+
+	if (purple_account_get_bool(
+			fba->account, "facebook_manage_friends", FALSE)) {
+		fb_post_or_get(fba, FB_METHOD_GET, NULL, "/reqs.php", NULL,
+				fb_check_friend_request_cb, NULL, FALSE);
+	}
+
+	return TRUE;
+}
+
+void fb_add_buddy(PurpleConnection *pc, PurpleBuddy *buddy, PurpleGroup *group)
+{
+	gchar *postdata;
+	FacebookAccount *fba = pc->proto_data;
+	gchar *buddy_tmp;
+
+	if (!purple_account_get_bool(
+				fba->account, "facebook_manage_friends", FALSE)) {
+		/*
+		 * We used to pop up dialogs here but if a user renamed a group,
+		 * this would spawn message for each person in the buddy list.  Bad!
+		purple_notify_info(fba->pc, _("Friend not added"),
+				_("Adding Facebook friends via Pidgin is disabled"),
+				_("Either add a friend via Facebook.com or edit your account preferences"));
+		*/
+		purple_debug_warning("facebook", "attempted to add %s but was blocked\n", buddy->name);
+		return;
+	}
+
+	if (atoll(buddy->name) == fba->uid)
+	{
+		purple_account_set_bool(fba->account,
+				"facebook_hide_self", FALSE);
+		return;
+	}
+
+	buddy_tmp = g_strdup(purple_url_encode(buddy->name));
+	postdata = g_strdup_printf(
+			"user=%" G_GINT64_FORMAT "&profile_id=%s&message=&"
+			"source=&submit=1&post_form_id=%s&fb_dtsg=%s&"
+			"post_form_id_source=AsyncRequest&__a=1",
+			fba->uid, buddy_tmp, fba->post_form_id, fba->dtsg);
+	g_free(buddy_tmp);
+
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/profile/connect.php",
+			postdata, NULL, NULL, FALSE);
+
+	g_free(postdata);
+}
+
+void fb_buddy_delete(PurpleConnection *pc, PurpleBuddy *buddy,
+		PurpleGroup *group)
+{
+	FacebookAccount *fba = pc->proto_data;
+	gchar *buddy_tmp, *postdata;
+
+	//This function removes a buddy from our friends list on facebook
+	//and shouldn't really be used
+	if (!purple_account_get_bool(fba->account, "facebook_manage_friends", FALSE)) {
+		purple_debug_warning("facebook", "attempted to add %s but was blocked\n", buddy->name);
+		return;
+	}
+
+	buddy_tmp = g_strdup(purple_url_encode(buddy->name));
+	postdata = g_strdup_printf(
+			"uid=%s&post_form_id=%s&fb_dtsg=%s&"
+			"post_form_id_source=AsyncRequest&__a=1",
+			buddy_tmp, fba->post_form_id, fba->dtsg);
+	g_free(buddy_tmp);
+
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/profile/removefriend.php",
+			postdata, NULL, NULL, FALSE);
+
+	g_free(postdata);
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_managefriends.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_managefriends.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_managefriends.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_managefriends.h	2011-03-27 09:15:30.868553000 -0600
@@ -0,0 +1,30 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_MANAGEFRIENDS_H
+#define FACEBOOK_MANAGEFRIENDS_H
+
+#include "libfacebook.h"
+
+gboolean fb_check_friend_requests(gpointer data);
+void fb_add_buddy(PurpleConnection *pc, PurpleBuddy *buddy, PurpleGroup *group);
+void fb_buddy_delete(PurpleConnection *pc, PurpleBuddy *buddy, PurpleGroup *group);
+
+#endif /* FACEBOOK_MANAGEFRIENDS_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_messages.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_messages.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_messages.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_messages.c	2011-03-27 09:15:30.744552999 -0600
@@ -0,0 +1,589 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_messages.h"
+#include "fb_connection.h"
+#include "fb_conversation.h"
+#include "fb_blist.h"
+#include "fb_util.h"
+#include "fb_chat.h"
+#include "fb_friendlist.h"
+
+#include "conversation.h"
+
+typedef struct _FacebookOutgoingMessage FacebookOutgoingMessage;
+
+struct _FacebookOutgoingMessage {
+	FacebookAccount *fba;
+	gchar *who;
+	GTimeVal time;
+	gchar *message;
+	gint msg_id;
+	guint retry_count;
+	guint resend_timer;
+};
+
+static gboolean fb_send_im_fom(FacebookOutgoingMessage *msg);
+static gboolean fb_resend_im_fom(FacebookOutgoingMessage *msg);
+
+static FacebookOutgoingMessage *fb_msg_create(FacebookAccount *fba)
+{
+	FacebookOutgoingMessage *msg;
+	
+	msg = g_new0(FacebookOutgoingMessage, 1);
+	msg->fba = fba;
+	
+	return msg;
+}
+
+static void fb_msg_destroy(FacebookOutgoingMessage *msg)
+{
+	if (msg->resend_timer) {
+		purple_timeout_remove(msg->resend_timer);
+	}
+	g_free(msg->who);
+	g_free(msg->message);
+	g_free(msg);	
+}
+
+void fb_cancel_resending_messages(FacebookAccount *fba)
+{
+	while (fba->resending_messages != NULL) {
+		FacebookOutgoingMessage *msg = fba->resending_messages->data;
+		fba->resending_messages = g_slist_remove(fba->resending_messages, msg);
+		fb_msg_destroy(msg);
+	}	
+}
+
+static void parse_message(PurpleConnection *pc, FacebookAccount *fba,
+	JsonObject *messageObj, const char* from, const char* to,
+	PurpleConversationType type)
+{
+	gint64 message_time;
+	const gchar *message;
+
+	purple_debug_info("facebook", "message from %s to %s\n", from, to);
+
+	message = json_node_get_string(
+		json_object_get_member(messageObj, "text"));
+
+	message_time = fb_time_kludge(json_node_get_int(
+				json_object_get_member(messageObj, "time")));
+
+	if (type == PURPLE_CONV_TYPE_CHAT)
+		fb_conversation_handle_chat(fba, from, to, message_time, message, TRUE);
+	else
+		fb_conversation_handle_message(fba, from, to, message_time, message, TRUE);			
+}
+
+static void parse_new_messages(PurpleConnection *pc, FacebookAccount *fba, JsonArray *messages)
+{
+	int i;
+	PurpleBuddy *buddy;
+
+	purple_debug_info("facebook", "parsing new messages\n");
+
+	for (i = 0; i < json_array_get_length(messages); i++) {
+		const gchar *type;
+		gchar *from, *to;
+		
+
+		JsonObject *object = json_node_get_object(json_array_get_element(messages, i));
+		type = json_node_get_string(json_object_get_member(object, "type"));
+
+		from = g_strdup_printf("%" G_GINT64_FORMAT, (gint64)json_node_get_int(json_object_get_member(object, "from")));
+		to = g_strdup_printf("%" G_GINT64_FORMAT, (gint64)json_node_get_int(json_object_get_member(object, "to")));
+		
+		/* Use the in-line buddy name if the buddy list hasn't been downloaded yet */
+		buddy = purple_find_buddy(pc->account, from);
+		if (buddy == NULL || buddy->server_alias == NULL || buddy->alias == NULL)
+		{
+			if (json_object_has_member(object, "from_name"))
+			{
+				const gchar *from_name = json_node_get_string(json_object_get_member(
+					object, "from_name"));
+				fb_blist_set_alias(fba, from, from_name);
+			}
+		}
+
+		if (from && to && g_str_equal(type, "msg")) {
+			JsonObject *messageObj = json_node_get_object(json_object_get_member(object, "msg"));
+			parse_message(pc, fba, messageObj, from, to, PURPLE_CONV_TYPE_IM);
+		} else if (from && g_str_equal(type, "typ")) {
+			purple_debug_info("facebook", "handling typing notification\n");
+
+			gint typing = json_node_get_int(json_object_get_member(object, "st"));
+			if (typing == 0) {
+				serv_got_typing(pc, from, 10, PURPLE_NOT_TYPING);
+			} else {
+				serv_got_typing(pc, from, 10, PURPLE_TYPING);
+			}
+		} else if (g_str_equal(type, "group_msg")) {
+			PurpleConversation *conv = fb_find_chat(fba, to);
+			
+			if (conv != NULL)
+			{			
+				if (json_object_has_member(object, "to_name"))
+				{
+					const gchar *to_name = json_node_get_string(json_object_get_member(
+						object, "to_name"));
+					purple_conversation_set_title(conv, to_name);
+
+					PurpleChat *chat = purple_blist_find_chat(fba->account, to);
+					purple_blist_alias_chat(chat, to_name);
+				}
+				if (!purple_conv_chat_cb_find(PURPLE_CONV_CHAT(conv), from))
+				{
+					purple_conv_chat_add_user(PURPLE_CONV_CHAT(conv), from, NULL, PURPLE_CBFLAGS_NONE, FALSE);
+				}
+				if (!purple_find_buddy(fba->account, from))
+				{
+					const char *from_name = json_node_get_string(json_object_get_member(
+						object, "from_name"));
+					buddy = purple_buddy_new(fba->account, from, from_name);
+					purple_blist_node_set_flags((PurpleBlistNode *)buddy, PURPLE_BLIST_NODE_FLAG_NO_SAVE);
+					purple_blist_add_buddy(buddy, NULL, purple_find_group(DEFAULT_GROUP_NAME), NULL);
+				}
+			}
+
+			JsonObject *messageObj = json_node_get_object(json_object_get_member(object, "msg"));
+			parse_message(pc, fba, messageObj, from, to, PURPLE_CONV_TYPE_CHAT);
+		}
+
+		/*
+		 * we've received something from a buddy, assume they're online
+		 * only if it's not from ourselves
+		 */
+		if (from && fba->uid != atoll(from)) {
+			purple_prpl_got_user_status(
+				fba->account, from, 
+				purple_primitive_get_id_from_type(PURPLE_STATUS_AVAILABLE), NULL);
+
+		}
+	
+		g_free(from);
+		g_free(to);
+
+		fba->message_fetch_sequence++;
+	}
+}
+								  
+static void got_new_messages(FacebookAccount *fba, const gchar *data,
+		gsize data_len, gpointer userdata)
+{
+	JsonParser *parser;
+
+	PurpleConnection *pc = userdata;
+
+	purple_debug_misc("facebook", "got new messages:\n%s\n", data);
+
+	/* for (;;);{"t":"msg","c":"p_800753867","ms":[{"type":"msg",
+		"msg":{"text":"yes","time":1211176515861,"clientTime":1211176514750,
+		"msgID":"367146364"},"from":596176850,"to":800753867,
+		"from_name":"Jeremy Lawson","to_name":"Eion Robb",
+		"from_first_name":"Jeremy","to_first_name":"Eion"}]} */
+	/* for (;;);{"t":"refresh"} */
+	/* for (;;);{"t":"msg","c":"p_800753867","ms":[{"type":"msg",
+		"msg":{"text":"porn head","time":1211177326689,"clientTime":1211177325,
+		"msgID":"-1992480367"},"from":800753867,"to":596176850,
+		"from_name":"Eion Robb","to_name":"Jeremy Lawson",
+		"from_first_name":"Eion","to_first_name":"Jeremy"}]} */
+	/* for (;;);{"t":"msg","c":"p_800753867","ms":[{"type":"typ","st":1,
+		"from":596176850,"to":800753867},{"type":"msg","msg":{"text":"nubile!",
+		"time":1211177334019,"clientTime":1211177326690,"msgID":"696260545"},
+		"from":596176850,"to":800753867,"from_name":"Jeremy Lawson",
+		"to_name":"Eion Robb","from_first_name":"Jeremy","to_first_name":"Eion"},
+		{"type":"msg","msg":{"text":"test2","time":1211177336688,
+		"clientTime":1211177326691,"msgID":"1527815367"},"from":596176850,
+		"to":800753867,"from_name":"Jeremy Lawson","to_name":"Eion Robb",
+		"from_first_name":"Jeremy","to_first_name":"Eion"},{"type":"msg",
+		"msg":{"text":"ahhhhhhh!","time":1211177344361,"clientTime":1211177326692,
+		"msgID":"4028916254"},"from":596176850,"to":800753867,
+		"from_name":"Jeremy Lawson","to_name":"Eion Robb",
+		"from_first_name":"Jeremy","to_first_name":"Eion"}]} */
+	/* for (;;);{"t":"msg","c":"p_800753867","ms":[{"type":"msg",
+		"msg":{"text":"2","time":1211178167261,"clientTime":1211178164656,
+		"msgID":"3382240259"},"from":596176850,"to":800753867,
+		"from_name":"Jeremy Lawson","to_name":"Eion Robb",
+		"from_first_name":"Jeremy","to_first_name":"Eion"}]} */
+	/* for (;;);{"t":"refresh", "seq":1} */
+
+	parser = fb_get_parser(data, data_len);
+	if (!parser)
+	{
+		/* Sometimes proxies will return incorrect data, so we just shrug 
+		 * it off.
+		 * TODO: Only do this for proxies.  And when we do it, keep track
+		 * of consecutive failures in the case something is actually
+		 * wrong with Facebook.  Eventually this condition should cause
+		 * failure */
+		/* Continue looping, waiting for more messages */
+		purple_debug_error("facebook",
+				"got data back, but it's not even json\n");
+				
+		fb_get_new_messages(fba);
+		return;
+	}
+
+	JsonObject *objnode = fb_get_json_object(parser, NULL);
+
+	if (json_object_has_member(objnode, "t")) {
+		const gchar* command = json_node_get_string(json_object_get_member(objnode, "t"));
+		if (g_str_equal(command, "refresh")) {
+			if (json_object_has_member(objnode, "seq")) {
+				fba->message_fetch_sequence = json_node_get_int(
+					json_object_get_member(objnode, "seq"));
+			}
+
+			/* grab history items for all open conversations */
+			GList *conversations = purple_get_conversations();
+			while (conversations != NULL) {
+				PurpleConversation *conv =
+					(PurpleConversation *)conversations->data;
+				if (fb_conversation_is_fb(conv)) {
+					purple_debug_info("facebook",
+						"checking for dropped messages with %s\n",
+						conv->name);
+					fb_history_fetch(fba, conv->name, FALSE);
+				}
+				conversations = conversations->next;
+			}
+
+			/* refresh means that the channel is invalid */
+			fb_reconnect(fba);
+			json_parser_free(parser);
+			return;
+		} else if (g_str_equal(command, "continue")) {
+			/* continue means that the server wants us to remake the connection.
+ 			 * continue the loop and wait for messages. noop. */
+		} else if (g_str_equal(command, "msg")) {
+			parse_new_messages(pc, fba,
+				json_node_get_array(json_object_get_member(objnode, "ms")));
+		}
+	}
+	
+	if (json_object_has_member(objnode, "s"))
+	{
+		gint new_seq = json_node_get_int(json_object_get_member(objnode, "s"));
+		fba->message_fetch_sequence = new_seq;
+	}
+
+	json_parser_free(parser);
+
+	/* Continue looping, waiting for more messages */
+	fb_get_new_messages(fba);
+}
+
+/* Message fetch loop.  An invariant here is that get_new_messages()
+ * is the only function which can create a new timer for
+ * new_messages_check_timer.  The timer always calls got_new_messages(),
+ * and got_new_messages always calls get_new_messages (either directly
+ * or indirectly).  To start the loops off, get_new_messages should be
+ * called ONCE and only ONCE.  After that the timers will take care of
+ * themselves until final cleanup.
+ */
+gboolean fb_get_new_messages(FacebookAccount *fba)
+{
+	time_t now;
+	gchar *fetch_url;
+	gchar *fetch_server;
+	const gchar *channel_number;
+
+	fba->new_messages_check_timer = 0;
+
+	now = time(NULL);
+	if (fba->last_messages_download_time > now - 3) {
+		/*
+		 * Wait a bit before fetching more messages, to make sure we
+		 * never hammer their servers.
+		 *
+		 * TODO: This could be smarter.  Like, allow 3 requests per
+		 *       10 seconds or something.
+		 */
+		fba->new_messages_check_timer = purple_timeout_add_seconds(
+				3 - (now - fba->last_messages_download_time),
+				(GSourceFunc)fb_get_new_messages, fba);
+		return FALSE;
+	}
+
+	if (fba->channel_number == NULL)
+	{
+		return FALSE;
+	} else {
+		channel_number = fba->channel_number;
+	}
+
+	purple_debug_info("facebook", "getting new messages\n");
+
+	fetch_server = g_strdup_printf("%d-%s.facebook.com", 0, channel_number);
+	/* use the current time in the url to get past any transparent proxy caches */
+	fetch_url = g_strdup_printf("/x/%lu/%s/p_%" G_GINT64_FORMAT "=%d", (gulong)time(NULL), (fba->is_idle?"false":"true"), fba->uid, fba->message_fetch_sequence);
+
+	fb_post_or_get(fba, FB_METHOD_GET, fetch_server, fetch_url, NULL, got_new_messages, fba->pc, TRUE);
+	fba->last_messages_download_time = now;
+
+	g_free(fetch_url);
+	g_free(fetch_server);
+
+	return FALSE;
+}
+
+static void fb_send_im_cb(FacebookAccount *fba, const gchar *data, gsize data_len, gpointer user_data)
+{
+	FacebookOutgoingMessage *msg = user_data;
+	JsonParser *parser;
+	JsonObject *object;
+	PurpleConversation *conv;
+	gchar *error = NULL;
+
+	purple_debug_misc("facebook", "sent im response: %s\n", data);
+	
+	parser = fb_get_parser(data, data_len);
+	if (!parser) {
+		// We didn't get data, but this isn't necessarily fatal.
+		purple_debug_warning("facebook", "bad data while parsing sent IM\n");
+		return;
+	}
+	object = fb_get_json_object(parser, &error);
+	
+	if (error)
+	{
+		purple_debug_error("facebook", "sent im error: %s\n", error);
+		/* there was an error, either report it or retry */
+		if (msg->retry_count++ < FB_MAX_MSG_RETRY)
+		{
+			msg->resend_timer = purple_timeout_add_seconds(1, (GSourceFunc)fb_resend_im_fom, msg);
+			fba->resending_messages = g_slist_prepend(fba->resending_messages, msg);
+			json_parser_free(parser);
+			return;
+		}
+		else
+		{
+			conv = purple_conversation_new(PURPLE_CONV_TYPE_IM,
+					fba->account, msg->who);
+			purple_conversation_write(conv, NULL, error,
+					PURPLE_MESSAGE_ERROR, msg->time.tv_sec);
+		}
+		
+		g_hash_table_remove(fba->sent_messages_hash, msg->message);
+	}
+
+	json_parser_free(parser);
+	fb_msg_destroy(msg);
+}
+
+static gboolean fb_send_im_fom(FacebookOutgoingMessage *msg)
+{
+	gchar *encoded_message;
+	gchar *postdata;
+	gchar *jstime;
+	
+	jstime = g_strdup_printf("%ld%ld", msg->time.tv_sec, (msg->time.tv_usec/1000));
+
+	encoded_message = g_strdup(purple_url_encode(msg->message));
+	postdata = g_strdup_printf("msg_text=%s&msg_id=%d&to=%s&client_time=%s&post_form_id=%s&fb_dtsg=%s",
+			encoded_message, msg->msg_id, msg->who, jstime,
+			msg->fba->post_form_id ? msg->fba->post_form_id : "0",
+			msg->fba->dtsg ? msg->fba->dtsg : "(null)");
+	g_free(encoded_message);
+	g_free(jstime);
+
+	fb_post_or_get(msg->fba, FB_METHOD_POST, NULL, "/ajax/chat/send.php?__a=1", postdata, fb_send_im_cb, msg, FALSE);
+	g_free(postdata);
+
+	return FALSE;
+}
+
+static gboolean fb_resend_im_fom(FacebookOutgoingMessage *msg)
+{
+	msg->fba->resending_messages = g_slist_remove(msg->fba->resending_messages, msg);
+
+	return fb_send_im_fom(msg);
+}
+
+int fb_send_im(PurpleConnection *pc, const gchar *who, const gchar *message, PurpleMessageFlags flags)
+{
+	FacebookOutgoingMessage *msg;
+	FacebookAccount *fba = pc->proto_data;
+
+	msg = fb_msg_create(fba);
+
+	/* convert html to plaintext, removing trailing spaces */
+	msg->message = purple_markup_strip_html(message);
+	if (strlen(msg->message) > 999)
+	{
+		fb_msg_destroy(msg);
+		return -E2BIG;
+	}
+
+	msg->msg_id = g_random_int();
+	msg->who = g_strdup(who);
+	g_get_current_time(&msg->time);
+	msg->retry_count = 0;
+
+	//save that we're sending the message
+	g_hash_table_insert(fba->sent_messages_hash, strdup(msg->message), NULL);
+
+	fb_send_im_fom(msg);
+
+	/* Return 1 so UI will display message */
+	return 1;
+}
+
+void got_reconnect_json(FacebookAccount *fba, const gchar *data, gsize data_len, gpointer userdata)
+{
+	JsonParser *parser;
+	JsonObject *objnode;
+	gchar *error_message;
+
+	parser = fb_get_parser(data, data_len);
+
+	if (!parser) {
+		purple_debug_error("facebook", "couldn't parse reconnect data\n");
+		purple_debug_info("facebook", "page content: %s\n", data);
+		purple_connection_error_reason(fba->pc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Chat service currently unavailable"));
+		return;
+	}
+
+	objnode = fb_get_json_object(parser, &error_message);
+	
+	if (error_message != NULL)
+	{
+		if (json_node_get_int(json_object_get_member(objnode, "error")) == 1356007)
+		{
+			//There'll normally be an error message if chat is down for maintenance
+			purple_connection_error_reason(fba->pc,
+				PURPLE_CONNECTION_ERROR_AUTHENTICATION_IMPOSSIBLE,
+				error_message);
+			g_free(error_message);
+			json_parser_free(parser);
+			return;
+		}
+	}
+
+	JsonObject *payload = json_node_get_object(json_object_get_member(objnode, "payload"));
+	
+	/* eg {"host":"channel01"} */
+	const gchar *new_channel_host = json_node_get_string(json_object_get_member(payload, "host"));
+
+	if (new_channel_host == NULL)
+	{
+		purple_debug_error("facebook", "couldn't find new channel number\n");
+		purple_debug_info("facebook", "page content: %s\n", data);
+		purple_connection_error_reason(fba->pc,
+				PURPLE_CONNECTION_ERROR_NETWORK_ERROR,
+				_("Error fetching channel; did you log in elsewhere?"));
+		json_parser_free(parser);
+		return;
+	}
+	
+	g_free(fba->channel_number);
+	fba->channel_number = g_strdup(new_channel_host);
+	
+	gint new_seq = json_node_get_int(json_object_get_member(payload, "seq"));
+	fba->message_fetch_sequence = new_seq;
+	
+	/*
+	 * Now that we have a channel number we can start looping and
+	 * waiting for messages
+	 */
+	fb_get_new_messages(fba);
+	json_parser_free(parser);
+}
+
+gboolean fb_reconnect(FacebookAccount *fba)
+{
+	gchar *url = g_strdup_printf("/ajax/presence/reconnect.php?__a=1&reason=7&post_form_id=%s&__a=1", fba->post_form_id);
+	fb_post_or_get(fba, FB_METHOD_GET, NULL, url, NULL, got_reconnect_json, NULL, FALSE);
+	g_free(url);
+	
+	return FALSE;
+}
+
+static void got_form_id_page(FacebookAccount *fba, const gchar *data, gsize data_len, gpointer userdata)
+{
+	const gchar *start_text = "id=\"post_form_id\" name=\"post_form_id\" value=\"";
+	const gchar *dtsg_start = "fb_dtsg:\"";
+	const gchar *channel_start = "js\", \"channel";
+	const gchar *channel_start2 = "js\",\"channel";
+	gchar *post_form_id;
+	gchar *channel = NULL;
+	gchar *tmp = NULL;
+	FacebookFunc callback;
+	
+	/* NULL data crashes on Windows */
+	if (data == NULL)
+		data = "(null)";
+	
+	tmp = g_strstr_len(data, data_len, start_text);
+	if (tmp == NULL)
+	{
+		purple_debug_error("facebook", "couldn't find post_form_id\n");
+		purple_debug_info("facebook", "page content: %s\n", data);
+		/* Maybe they changed their HTML slightly? */
+		purple_connection_error_reason(fba->pc,
+				PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
+				_("Error getting info from Facebook."));
+		return;
+	}
+	tmp += strlen(start_text);
+	post_form_id = g_strndup(tmp, strchr(tmp, '"') - tmp);
+	
+	g_free(fba->post_form_id);
+	fba->post_form_id = post_form_id;
+	
+	tmp = g_strstr_len(data, data_len, dtsg_start);
+	if (tmp != NULL)
+	{
+		tmp += strlen(dtsg_start);
+		g_free(fba->dtsg);
+		fba->dtsg = g_strndup(tmp, strchr(tmp, '"') - tmp);
+	}
+
+	tmp = g_strstr_len(data, data_len, channel_start);
+	if (tmp != NULL)
+	{
+		tmp += 6;
+	} else {
+		tmp = g_strstr_len(data, data_len, channel_start2);
+		if (tmp != NULL)
+			tmp += 5;
+	}
+	if (tmp != NULL)
+	{
+		channel = g_strndup(tmp, strchr(tmp, '"') - tmp);
+		g_free(fba->channel_number);
+		fba->channel_number = channel;
+	}
+	
+	if (userdata)
+	{
+		callback = userdata;
+		callback(fba);
+	}
+}
+
+gboolean fb_get_post_form_id(FacebookAccount *fba, FacebookFunc callback)
+{
+	fb_post_or_get(fba, FB_METHOD_GET, NULL, "/presence/popout.php", NULL, got_form_id_page, callback, FALSE);
+	return FALSE;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_messages.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_messages.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_messages.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_messages.h	2011-03-27 09:15:30.712552999 -0600
@@ -0,0 +1,35 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_MESSAGES_H
+#define FACEBOOK_MESSAGES_H
+
+#include "libfacebook.h"
+
+gboolean fb_get_post_form_id(FacebookAccount *fba, FacebookFunc callback);
+gboolean fb_reconnect(FacebookAccount *fba);
+int fb_send_im(PurpleConnection *pc, const gchar *who, const gchar *message,
+		PurpleMessageFlags flags);
+
+void fb_cancel_resending_messages(FacebookAccount *fba);
+
+gboolean fb_get_new_messages(FacebookAccount *fba);
+
+#endif /* FACEBOOK_MESSAGES_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_notifications.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_notifications.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_notifications.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_notifications.c	2011-03-27 09:15:30.868553000 -0600
@@ -0,0 +1,198 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_notifications.h"
+#include "fb_connection.h"
+
+static void fb_got_notifications_cb(FacebookAccount *fba, const gchar *url_text, gsize len, gpointer userdata)
+{
+	gchar *salvaged;
+	time_t last_fetch_time;
+	time_t time_of_message;
+	time_t newest_message = 0;
+	gchar *tmp;
+	gchar month_string[4], weekday[4];
+	guint year, month, day, hour, minute, second;
+	long timezone;
+	gchar *subject, *url;
+
+	month_string[3] = weekday[3] = '\0';
+	year = month = day = hour = minute = second = 0;
+
+	if (!url_text || !len)
+		return;
+
+	last_fetch_time = purple_account_get_int(fba->account, "facebook_notifications_last_fetch", 0);
+	/* purple_debug_info("facebook", "last fetch time: %zu\n", last_fetch_time); */
+
+	salvaged = purple_utf8_salvage(url_text);
+	xmlnode *rss_root = xmlnode_from_str(salvaged, -1);
+	g_free(salvaged);
+	if (rss_root == NULL)
+	{
+		purple_debug_error("facebook", "Could not load RSS file\n");
+		return;
+	}
+	xmlnode *channel = xmlnode_get_child(rss_root, "channel");
+	if (channel == NULL)
+	{
+		purple_debug_warning("facebook", "Invalid RSS feed\n");
+		xmlnode_free(rss_root);
+		return;
+	}
+	xmlnode *item = xmlnode_get_child(channel, "item");
+	if (item == NULL)
+	{
+		purple_debug_info("facebook", "No new notifications\n");
+	}
+	for (; item != NULL; item = xmlnode_get_next_twin(item))
+	{
+		xmlnode *pubDate = xmlnode_get_child(item, "pubDate");
+		if (!pubDate)
+			continue;
+		tmp = xmlnode_get_data_unescaped(pubDate);
+		/* rss times are in Thu, 19 Jun 2008 15:51:25 -1100 format */
+		sscanf(tmp, "%3s, %2u %3s %4u %2u:%2u:%2u %5ld", (char*)&weekday, &day, (char*)&month_string, &year, &hour, &minute, &second, &timezone);
+		if (g_str_equal(month_string, "Jan")) month = 0;
+		else if (g_str_equal(month_string, "Feb")) month = 1;
+		else if (g_str_equal(month_string, "Mar")) month = 2;
+		else if (g_str_equal(month_string, "Apr")) month = 3;
+		else if (g_str_equal(month_string, "May")) month = 4;
+		else if (g_str_equal(month_string, "Jun")) month = 5;
+		else if (g_str_equal(month_string, "Jul")) month = 6;
+		else if (g_str_equal(month_string, "Aug")) month = 7;
+		else if (g_str_equal(month_string, "Sep")) month = 8;
+		else if (g_str_equal(month_string, "Oct")) month = 9;
+		else if (g_str_equal(month_string, "Nov")) month = 10;
+		else if (g_str_equal(month_string, "Dec")) month = 11;
+		g_free(tmp);
+
+		/* try using pidgin's functions */
+		tmp = g_strdup_printf("%04u%02u%02uT%02u%02u%02u%05ld", year, month, day, hour, minute, second, timezone);
+		time_of_message = purple_str_to_time(tmp, FALSE, NULL, NULL, NULL);
+		g_free(tmp);
+
+		if (time_of_message <= 0)
+		{
+			/* there's no cross-platform, portable way of converting string to time
+			   which doesn't need a new version of glib, so just cheat */
+			time_of_message = second + 60*minute + 3600*hour + 86400*day + 2592000*month + 31536000*(year-1970);
+		}
+
+		if (time_of_message > newest_message)
+		{
+			/* we'll keep the newest message to save */
+			newest_message = time_of_message;
+		}
+
+		if (time_of_message <= last_fetch_time)
+		{
+			/* fortunatly, rss messages are ordered from newest to oldest */
+			/* so if this message is older than the last one, ignore rest */
+			break;
+		}
+		
+		xmlnode *link = xmlnode_get_child(item, "link");
+		if (link)
+		{
+			url = xmlnode_get_data_unescaped(link);
+		} else {
+			url = g_strdup("");
+		}
+		
+		xmlnode *title = xmlnode_get_child(item, "title");
+		if (title)
+		{
+			subject = xmlnode_get_data_unescaped(title);
+		} else {
+			subject = g_strdup("");
+		}
+		
+		purple_notify_email(fba->pc, subject, NULL, fba->account->username, url, NULL, NULL);
+		g_free(subject);
+		g_free(url);
+	}
+	xmlnode_free(rss_root);
+
+	if (newest_message > last_fetch_time)
+	{
+		/* update the last fetched time if we had newer messages */
+		purple_account_set_int(fba->account, "facebook_notifications_last_fetch", newest_message);
+	}
+}
+
+static void find_feed_url_cb(FacebookAccount *fba, const gchar *data, gsize data_len, gpointer userdata)
+{
+	const gchar *search_string = "/feeds/notifications.php";
+	gchar *feed_url;
+	gchar *stripped;
+
+	purple_debug_info("facebook", "find_feed_url_cb\n");
+
+	if (!data)
+		data = "(null)";
+
+	feed_url = g_strstr_len(data, data_len, search_string);
+	if (!feed_url)
+	{
+		purple_debug_error("facebook", "received data, but could not find url on page\n");
+		return;
+	}
+
+	feed_url = g_strndup(feed_url, strchr(feed_url, '"') - feed_url);
+
+	/* convert &amp; to & */
+	stripped = purple_unescape_html(feed_url);
+	g_free(feed_url);
+	feed_url = stripped;
+	
+	purple_debug_info("facebook", "parsed feed url %s\n", feed_url);
+
+	if (feed_url && *feed_url)
+	{
+		purple_account_set_string(fba->account, "notifications_feed_url", feed_url);
+		fb_get_notifications_feed(fba);
+	}
+}
+
+static void fb_find_feed_url(FacebookAccount *fba)
+{
+	fb_post_or_get(fba, FB_METHOD_GET, NULL, "/notifications.php", NULL,
+			find_feed_url_cb, NULL, FALSE);
+}
+
+gboolean fb_get_notifications_feed(FacebookAccount *fba)
+{
+	const gchar *feed_url;
+
+	if (purple_account_get_bool(fba->account, "facebook_get_notifications", TRUE)) {
+		feed_url = purple_account_get_string(fba->account, "notifications_feed_url", NULL);
+		if (!feed_url)
+		{
+			purple_debug_info("facebook", "no notifications feed url available, searching for it\n");
+			fb_find_feed_url(fba);
+			return TRUE;
+		}
+
+		fb_post_or_get(fba, FB_METHOD_GET, NULL, feed_url, NULL, fb_got_notifications_cb, NULL, FALSE);
+	}
+
+	return TRUE;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_notifications.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_notifications.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_notifications.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_notifications.h	2011-03-27 09:15:30.868553000 -0600
@@ -0,0 +1,28 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_NOTIFICATIONS_H
+#define FACEBOOK_NOTIFICATIONS_H
+
+#include "libfacebook.h"
+
+gboolean fb_get_notifications_feed(FacebookAccount *fba);
+
+#endif /* FACEBOOK_NOTIFICATIONS_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_search.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_search.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_search.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_search.c	2011-03-27 09:15:30.720552999 -0600
@@ -0,0 +1,200 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "libfacebook.h"
+#include "fb_connection.h"
+#include "fb_info.h"
+#include "fb_search.h"
+
+static void fb_searchresults_add_buddy(PurpleConnection *pc, GList *row,
+		void *user_data)
+{
+	PurpleAccount *account = purple_connection_get_account(pc);
+
+	if (!purple_find_buddy(account, g_list_nth_data(row, 0)))
+		purple_blist_request_add_buddy(account,
+				g_list_nth_data(row, 0), NULL, NULL);
+}
+
+static void fb_searchresults_info_buddy(PurpleConnection *pc, GList *row,
+		void *user_data)
+{
+	/* PurpleAccount *account = purple_connection_get_account(pc); */
+
+	/* if (purple_find_buddy(account, g_list_nth_data(row, 0))) */
+		fb_get_info(pc, g_list_nth_data(row, 0));
+}
+
+static void fb_found_friends(FacebookAccount *fba, const gchar *data,
+		gsize data_len, gpointer user_data)
+{
+	PurpleNotifySearchResults *results;
+	PurpleNotifySearchColumn *column;
+	gchar *id, *tmp, *stripped;
+	const gchar *id_pos = data, *last_id_pos = 0;
+	gchar *search_term = user_data;
+	const gchar *id_search_term =
+			"facebook.com/inbox/?compose&amp;id="; /* " */
+	const gchar *name_search_term = "class=\"url fn\""; /* < */
+	const gchar *network_search_term = "class=\"result_network\">"; /* < */
+
+	if (!g_strstr_len(data, data_len, id_search_term))
+	{
+		/* there's no friends found; notify as such */
+		tmp = g_strdup_printf(_("No results found for %s"),
+				search_term);
+		purple_notify_error(fba->pc, NULL, tmp, NULL);
+		g_free(tmp);
+		g_free(search_term);
+		return;
+	}
+
+	results = purple_notify_searchresults_new();
+	if (results == NULL)
+	{
+		g_free(search_term);
+		return;
+	}
+
+	/* columns: Facebook ID, Name, Network */
+	column = purple_notify_searchresults_column_new(_("ID"));
+	purple_notify_searchresults_column_add(results, column);
+	column = purple_notify_searchresults_column_new(_("Name"));
+	purple_notify_searchresults_column_add(results, column);
+	column = purple_notify_searchresults_column_new(_("Network"));
+	purple_notify_searchresults_column_add(results, column);
+	column = purple_notify_searchresults_column_new(_("In List?"));
+	purple_notify_searchresults_column_add(results, column);
+
+	if (purple_account_get_bool(fba->account, "facebook_manage_friends",
+				FALSE)) {
+		purple_notify_searchresults_button_add(results,
+				PURPLE_NOTIFY_BUTTON_ADD,
+				fb_searchresults_add_buddy);
+	}
+	purple_notify_searchresults_button_add(results,
+			PURPLE_NOTIFY_BUTTON_INFO,
+			fb_searchresults_info_buddy);
+
+	purple_debug_info("facebook", "found_friends\n");
+	while ((id_pos = strstr(id_pos, id_search_term)))
+	{
+		/* the row in the search results table */
+		/* prepend to it backwards then reverse to speed up adds */
+		GList *row = NULL;
+
+		/* grab id */
+		id_pos += strlen(id_search_term);
+		if (strchr(id_pos, '&') < strchr(id_pos, '"'))
+		{
+			/* new layout repeats the id */
+			continue;
+		}
+		id = g_strndup(id_pos, strchr(id_pos, '"')-id_pos);
+		purple_debug_info("facebook", "Found user with id: %s\n", id);
+		row = g_list_prepend(row, id);
+
+		/* look for name */
+		tmp = g_strrstr_len(data, id_pos-data, name_search_term);
+		if (tmp && tmp > last_id_pos)
+		{
+			tmp += strlen(name_search_term);
+			tmp = strchr(tmp, '>') + 1;
+			tmp = g_strndup(tmp, strchr(tmp, '<')-tmp);
+			stripped = purple_unescape_html(tmp);
+			g_free(tmp);
+			purple_debug_info("facebook", "With name: %s\n",
+					stripped);
+			row = g_list_prepend(row, stripped);
+		} else {
+			row = g_list_prepend(row, NULL);
+		}
+
+		/* look for network */
+		tmp = g_strrstr_len(data, id_pos-data, network_search_term);
+		if (tmp && tmp > last_id_pos)
+		{
+			tmp += strlen(network_search_term);
+			tmp = g_strndup(tmp, strchr(tmp, '<')-tmp);
+			stripped = purple_unescape_html(tmp);
+			g_free(tmp);
+			purple_debug_info("facebook", "With network: %s\n",
+					stripped);
+			row = g_list_prepend(row, stripped);
+		} else {
+			row = g_list_prepend(row, NULL);
+		}
+
+		if (purple_find_buddy(fba->account, id))
+			row = g_list_prepend(row, g_strdup(_("Yes")));
+		else
+			row = g_list_prepend(row, g_strdup(_("No")));
+
+		row = g_list_reverse(row);
+		purple_notify_searchresults_row_add(results, row);
+
+		last_id_pos = id_pos;
+	}
+	purple_debug_info("facebook", "dumping search results\n");
+	purple_notify_searchresults(fba->pc, NULL, search_term, NULL,
+			results, NULL, NULL);
+
+	g_free(search_term);
+}
+
+static void fb_search_users_search_cb(gpointer connection,
+		const gchar *search_text)
+{
+	PurpleConnection *pc = connection;
+	FacebookAccount *fba = pc->proto_data;
+	gchar *search_url;
+	gchar *search_tmp;
+	gchar *sid_cookie_value;
+
+	if (!search_text || !*search_text)
+		return;
+
+	search_tmp = g_strdup(purple_url_encode(search_text));
+	sid_cookie_value = g_hash_table_lookup(fba->cookie_table, "sid");
+	if (sid_cookie_value == NULL)
+		sid_cookie_value = "1";
+	search_url = g_strdup_printf("/s.php?q=%s&init=q&sid=%s",
+			search_tmp, sid_cookie_value);
+	g_free(search_tmp);
+
+	fb_post_or_get(fba, FB_METHOD_GET, NULL, search_url, NULL,
+			fb_found_friends, g_strdup(search_text), FALSE);
+
+	g_free(search_url);
+}
+
+void fb_search_users(PurplePluginAction *action)
+{
+	PurpleConnection *pc = (PurpleConnection *) action->context;
+
+	purple_request_input(pc, _("Search for Friends"),
+			_("Search for Facebook Friends"),
+			_("Type the full name or e-mail address of the friend you are searching for."),
+			NULL, FALSE, FALSE, NULL,
+			_("_Search"), G_CALLBACK(fb_search_users_search_cb),
+			_("_Cancel"), NULL,
+			purple_connection_get_account(pc), NULL, NULL,
+			pc);
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_search.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_search.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_search.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_search.h	2011-03-27 09:15:30.744552999 -0600
@@ -0,0 +1,28 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_SEARCH_H
+#define FACEBOOK_SEARCH_H
+
+#include "libfacebook.h"
+
+void fb_search_users(PurplePluginAction *action);
+
+#endif /* FACEBOOK_SEARCH_H */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_util.c pidgin-2.7.7-new//libpurple/protocols/facebook/fb_util.c
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_util.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_util.c	2011-03-27 09:15:30.744552999 -0600
@@ -0,0 +1,301 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "fb_util.h"
+
+/*****************************************************************************
+ * UTILITY CODE                                                              *
+ *****************************************************************************/
+
+gchar *fb_convert_unicode(const gchar *input)
+{
+	/* \u00e9t\u00e9 should be t */
+
+	gunichar unicode_char;
+	gchar unicode_char_str[6];
+	gint unicode_char_len;
+	gchar *next_pos;
+	gchar *input_string;
+	gchar *output_string;
+
+	if (input == NULL)
+		return NULL;
+
+	next_pos = input_string = g_strdup(input);
+
+	/* purple_debug_info("facebook", "unicode convert: in: %s\n", input); */
+	while ((next_pos = strstr(next_pos, "\\u")))
+	{
+		/* grab the unicode */
+		sscanf(next_pos, "\\u%4x", &unicode_char);
+		/* turn it to a char* */
+		unicode_char_len = g_unichar_to_utf8(unicode_char, unicode_char_str);
+		/* shove it back into the string */
+		g_memmove(next_pos, unicode_char_str, unicode_char_len);
+		/* move all the data after the \u0000 along */
+		g_stpcpy(next_pos + unicode_char_len, next_pos + 6);
+	}
+
+	/* purple_debug_info("facebook", "unicode convert: out: %s\n", input); */
+	output_string = g_strcompress(input_string);
+	g_free(input_string);
+
+	return output_string;
+}
+
+/* Like purple_strdup_withhtml, but escapes htmlentities too */
+gchar *fb_strdup_withhtml(const gchar *src)
+{
+	gulong destsize, i, j;
+	gchar *dest;
+
+	g_return_val_if_fail(src != NULL, NULL);
+
+	/* New length is (length of src) + (number of \n's * 3) + (number of &'s * 5) +
+		(number of <'s * 4) + (number of >'s *4) + (number of "'s * 6) -
+		(number of \r's) + 1 */
+	destsize = 1;
+	for (i = 0; src[i] != '\0'; i++)
+	{
+		if (src[i] == '\n' || src[i] == '<' || src[i] == '>')
+			destsize += 4;
+		else if (src[i] == '&')
+			destsize += 5;
+		else if (src[i] == '"')
+			destsize += 6;
+		else if (src[i] != '\r')
+			destsize++;
+	}
+
+	dest = g_malloc(destsize);
+
+	/* Copy stuff, ignoring \r's, because they are dumb */
+	for (i = 0, j = 0; src[i] != '\0'; i++) {
+		if (src[i] == '\n') {
+			strcpy(&dest[j], "<BR>");
+			j += 4;
+		} else if (src[i] == '<') {
+			strcpy(&dest[j], "&lt;");
+			j += 4;
+		} else if (src[i] == '>') {
+			strcpy(&dest[j], "&gt;");
+			j += 4;
+		} else if (src[i] == '&') {
+			strcpy(&dest[j], "&amp;");
+			j += 5;
+		} else if (src[i] == '"') {
+			strcpy(&dest[j], "&quot;");
+			j += 6;
+		} else if (src[i] != '\r')
+			dest[j++] = src[i];
+	}
+
+	dest[destsize-1] = '\0';
+
+	return dest;
+}
+
+static gboolean is_json_64bit_safe()
+{
+	//Cache the result to try make this function quick
+	static gint result = -1;
+	gint64 largeint = G_MAXINT64;
+	
+	if (result == 1)
+		return TRUE;
+	if (result == 0)
+		return FALSE;
+	
+	if (sizeof(gint) >= sizeof(gint64))
+	{
+		result = 1;
+		return TRUE;
+	}
+
+#ifndef USE_JSONC
+	JsonNode *node;
+
+	node = json_node_new(JSON_NODE_VALUE);
+	json_node_set_int(node, largeint);
+	if(json_node_get_int(node) == largeint)
+	{
+		result = 1;
+	} else {
+		result = 0;
+	}
+	json_node_free(node);
+	return result ? TRUE : FALSE;
+	
+#endif /* !USE_JSONC */
+	
+	result = 0;
+	return FALSE;
+}
+
+gint64 fb_time_kludge(gint64 initial_time)
+{
+	if (is_json_64bit_safe())
+		return initial_time;
+	
+	gint64 now_millis = (gint64) time(NULL);
+	now_millis *= 1000;
+	now_millis &= 0xFFFFFFFF00000000LL;
+	gint64 final_time = now_millis | ((guint)initial_time);
+
+	return final_time;
+}
+
+JsonParser *fb_get_parser(const gchar *data, gsize data_len)
+{
+	JsonParser *parser;
+
+	if (data == NULL) {
+		return NULL;
+	}
+
+	data = g_strstr_len(data, data_len, "for (;;);");
+	if (!data) {
+		return NULL;
+	} else {
+		data += strlen("for (;;);");
+	}
+
+	parser = json_parser_new();
+	if (!json_parser_load_from_data(parser, data, -1, NULL)) {
+		json_parser_free(parser);
+		return NULL;
+	}
+
+	return parser;
+}
+
+JsonObject *fb_get_json_object(JsonParser *parser, char **error_message)
+{
+	JsonNode *root;
+	root = json_parser_get_root(parser);
+	JsonObject *objnode;
+	objnode = json_node_get_object(root);
+
+	/* Sample error messages */
+	/* for (;;);{"error":1357001,"errorSummary":"Not Logged In",
+		"errorDescription":"You must be logged in to do that.",
+		"payload":null,"bootload":[{"name":"js\/common.js.pkg.php",
+		"type":"js","src":"http:\/\/static.ak.fbcdn.net\/rsrc.php\/pkg\/59\
+		/98561\/js\/common.js.pkg.php"}]} */
+	if (json_object_has_member(objnode, "error"))
+	{
+		guint32 error_number;
+		const char *summary;
+		const char *description;
+
+		error_number = json_node_get_int(
+			json_object_get_member(objnode, "error"));
+		summary = json_node_get_string(
+			json_object_get_member(objnode, "errorSummary"));
+		description = json_node_get_string(
+			json_object_get_member(objnode, "errorDescription"));
+
+		if (error_number)
+		{
+			purple_debug_error("facebook",
+				"got error from facebook of %s (%s)\n",
+				summary, description);
+			// Pass error message to calling function if they asked for it.
+			if (error_message) {
+				*error_message = g_strdup(description);
+			}
+		}
+	}
+
+	return objnode;
+}
+
+/* Converts *text* into <b>text</b>  and _text_ into <i>text</i> */
+gchar *fb_replace_styled_text(const gchar *text)
+{
+#ifdef __ARM_EABI__
+	return g_strdup(text);
+#else /*__ARM_EABI__*/
+#if GLIB_MAJOR_VERSION >= 2 && GLIB_MINOR_VERSION >= 14
+	if (glib_check_version(2, 14, 0))
+	{
+		return g_strdup(text);
+	} else {
+		static GRegex *underline_regex = NULL;
+		static GRegex *bold_regex = NULL;
+		gchar *dup_text;
+		gchar *midway_string;
+		gchar *output_string;
+		
+		if (underline_regex == NULL)
+		{
+			underline_regex = g_regex_new(
+				"\\b_([^_\\*]+)_\\b", G_REGEX_OPTIMIZE,
+				0, NULL);
+		}
+		if (bold_regex == NULL)
+		{
+			bold_regex = g_regex_new(
+				"(\\s|^)\\*([^_\\*]+)\\*(?=$|\\s)",
+				G_REGEX_OPTIMIZE, 0, NULL);
+		}
+		
+		dup_text = g_strdup(text);
+		midway_string = g_regex_replace(underline_regex, dup_text,
+			strlen(dup_text), 0, "<u>\\1</u>", 0, NULL);
+		if (midway_string == NULL)
+		{
+			purple_debug_warning("facebook", "regex failed for underline\n");
+			return dup_text;
+		}
+		g_free(dup_text);
+		output_string = g_regex_replace(bold_regex, midway_string,
+			strlen(midway_string), 0, "\\1<b>\\2</b>", 0, NULL);
+		if (output_string == NULL)
+		{
+			purple_debug_warning("facebook", "regex failed for bold\n");
+			return midway_string;
+		}
+		g_free(midway_string);
+		
+		return output_string;
+	}
+#else /* GLIB check */
+	return g_strdup(text);
+#endif /* GLIB check */
+#endif /*__ARM_EABI__*/
+}
+
+gchar *fb_md5_encode(const gchar *string)
+{
+	PurpleCipher *cipher;
+	PurpleCipherContext *context;
+	gchar md5Hash[33];
+	
+	cipher = purple_ciphers_find_cipher("md5");
+	context = purple_cipher_context_new(cipher, NULL);
+
+	purple_cipher_context_append(context, (guchar *)string, strlen(string));
+	purple_cipher_context_digest_to_str(context, sizeof(md5Hash), md5Hash, NULL);
+	purple_cipher_context_destroy(context);
+	
+	return g_strdup(md5Hash);
+}
+
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/fb_util.h pidgin-2.7.7-new//libpurple/protocols/facebook/fb_util.h
--- pidgin-2.7.7/libpurple/protocols/facebook/fb_util.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/fb_util.h	2011-03-27 09:15:30.844553000 -0600
@@ -0,0 +1,39 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef FACEBOOK_UTIL_H
+#define FACEBOOK_UTIL_H
+
+#include "libfacebook.h"
+#include "fb_json.h"
+
+#include <cipher.h>
+
+JsonParser *fb_get_parser(const gchar *data, gsize data_len);
+JsonObject *fb_get_json_object(JsonParser *parser, char **error_message);
+
+gchar *fb_replace_styled_text(const gchar *text);
+gchar *fb_strdup_withhtml(const gchar *src);
+gchar *fb_convert_unicode(const gchar *input);
+gint64 fb_time_kludge(gint64 initial_time);
+gchar *fb_md5_encode(const gchar *string);
+
+#endif /* FACEBOOK_UTIL_H */
+
Binary files pidgin-2.7.7/libpurple/protocols/facebook/i686/libjson-glib-1.0.so and pidgin-2.7.7-new//libpurple/protocols/facebook/i686/libjson-glib-1.0.so differ
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-array.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-array.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-array.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-array.c	2011-03-27 09:15:30.760552999 -0600
@@ -0,0 +1,714 @@
+/* json-array.c - JSON array implementation
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "json-types-private.h"
+
+/**
+ * SECTION:json-array
+ * @short_description: a JSON array representation
+ *
+ * #JsonArray is the representation of the array type inside JSON. It contains
+ * #JsonNode<!-- -->s, which may contain fundamental types, other arrays or
+ * objects.
+ *
+ * Since arrays can be expensive, they are reference counted. You can control
+ * the lifetime of a #JsonArray using json_array_ref() and json_array_unref().
+ *
+ * To append an element, use json_array_add_element().
+ * To extract an element at a given index, use json_array_get_element().
+ * To retrieve the entire array in list form, use json_array_get_elements().
+ * To retrieve the length of the array, use json_array_get_length().
+ */
+
+G_DEFINE_BOXED_TYPE (JsonArray, json_array, json_array_ref, json_array_unref);
+
+/**
+ * json_array_new:
+ *
+ * Creates a new #JsonArray.
+ *
+ * Return value: the newly created #JsonArray
+ */
+JsonArray *
+json_array_new (void)
+{
+  JsonArray *array;
+
+  array = g_slice_new (JsonArray);
+
+  array->ref_count = 1;
+  array->elements = g_ptr_array_new ();
+
+  return array;
+}
+
+/**
+ * json_array_sized_new:
+ * @n_elements: number of slots to pre-allocate
+ *
+ * Creates a new #JsonArray with @n_elements slots already allocated.
+ *
+ * Return value: the newly created #JsonArray
+ */
+JsonArray *
+json_array_sized_new (guint n_elements)
+{
+  JsonArray *array;
+
+  array = g_slice_new (JsonArray);
+  
+  array->ref_count = 1;
+  array->elements = g_ptr_array_sized_new (n_elements);
+
+  return array;
+}
+
+/**
+ * json_array_ref:
+ * @array: a #JsonArray
+ *
+ * Increase by one the reference count of a #JsonArray.
+ *
+ * Return value: the passed #JsonArray, with the reference count
+ *   increased by one.
+ */
+JsonArray *
+json_array_ref (JsonArray *array)
+{
+  g_return_val_if_fail (array != NULL, NULL);
+  g_return_val_if_fail (array->ref_count > 0, NULL);
+
+  g_atomic_int_exchange_and_add (&array->ref_count, 1);
+
+  return array;
+}
+
+/**
+ * json_array_unref:
+ * @array: a #JsonArray
+ *
+ * Decreases by one the reference count of a #JsonArray. If the
+ * reference count reaches zero, the array is destroyed and all
+ * its allocated resources are freed.
+ */
+void
+json_array_unref (JsonArray *array)
+{
+  gint old_ref;
+
+  g_return_if_fail (array != NULL);
+  g_return_if_fail (array->ref_count > 0);
+
+  old_ref = g_atomic_int_get (&array->ref_count);
+  if (old_ref > 1)
+    g_atomic_int_compare_and_exchange (&array->ref_count, old_ref, old_ref - 1);
+  else
+    {
+      guint i;
+
+      for (i = 0; i < array->elements->len; i++)
+        json_node_free (g_ptr_array_index (array->elements, i));
+
+      g_ptr_array_free (array->elements, TRUE);
+      array->elements = NULL;
+
+      g_slice_free (JsonArray, array);
+    }
+}
+
+/**
+ * json_array_get_elements:
+ * @array: a #JsonArray
+ *
+ * Gets the elements of a #JsonArray as a list of #JsonNode<!-- -->s.
+ *
+ * Return value: (element-type JsonNode) (transfer container): a #GList
+ *   containing the elements of the array. The contents of the list are
+ *   owned by the array and should never be modified or freed. Use
+ *   g_list_free() on the returned list when done using it
+ */
+GList *
+json_array_get_elements (JsonArray *array)
+{
+  GList *retval;
+  guint i;
+
+  g_return_val_if_fail (array != NULL, NULL);
+
+  retval = NULL;
+  for (i = 0; i < array->elements->len; i++)
+    retval = g_list_prepend (retval,
+                             g_ptr_array_index (array->elements, i));
+
+  return g_list_reverse (retval);
+}
+
+/**
+ * json_array_dup_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ *
+ * Retrieves a copy of the #JsonNode containing the value of the
+ * element at @index_ inside a #JsonArray
+ *
+ * Return value: (transfer full): a copy of the #JsonNode at the requested
+ *   index. Use json_node_free() when done.
+ *
+ * Since: 0.6
+ */
+JsonNode *
+json_array_dup_element (JsonArray *array,
+                        guint      index_)
+{
+  JsonNode *retval;
+
+  g_return_val_if_fail (array != NULL, NULL);
+  g_return_val_if_fail (index_ < array->elements->len, NULL);
+
+  retval = json_array_get_element (array, index_);
+  if (!retval)
+    return NULL;
+
+  return json_node_copy (retval);
+}
+
+/**
+ * json_array_get_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ * 
+ * Retrieves the #JsonNode containing the value of the element at @index_
+ * inside a #JsonArray.
+ *
+ * Return value: (transfer none): a pointer to the #JsonNode at the requested index
+ */
+JsonNode *
+json_array_get_element (JsonArray *array,
+                        guint      index_)
+{
+  g_return_val_if_fail (array != NULL, NULL);
+  g_return_val_if_fail (index_ < array->elements->len, NULL);
+
+  return g_ptr_array_index (array->elements, index_);
+}
+
+/**
+ * json_array_get_int_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ *
+ * Conveniently retrieves the integer value of the element at @index_
+ * inside @array
+ *
+ * See also: json_array_get_element(), json_node_get_int()
+ *
+ * Return value: the integer value
+ *
+ * Since: 0.8
+ */
+gint64
+json_array_get_int_element (JsonArray *array,
+                            guint      index_)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (array != NULL, 0);
+  g_return_val_if_fail (index_ < array->elements->len, 0);
+
+  node = g_ptr_array_index (array->elements, index_);
+  g_return_val_if_fail (node != NULL, 0);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE, 0);
+
+  return json_node_get_int (node);
+}
+
+/**
+ * json_array_get_double_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ *
+ * Conveniently retrieves the floating point value of the element at
+ * @index_ inside @array
+ *
+ * See also: json_array_get_element(), json_node_get_double()
+ *
+ * Return value: the floating point value
+ *
+ * Since: 0.8
+ */
+gdouble
+json_array_get_double_element (JsonArray *array,
+                               guint      index_)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (array != NULL, 0.0);
+  g_return_val_if_fail (index_ < array->elements->len, 0.0);
+
+  node = g_ptr_array_index (array->elements, index_);
+  g_return_val_if_fail (node != NULL, 0.0);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE, 0.0);
+
+  return json_node_get_double (node);
+}
+
+/**
+ * json_array_get_boolean_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ *
+ * Conveniently retrieves the boolean value of the element at @index_
+ * inside @array
+ *
+ * See also: json_array_get_element(), json_node_get_boolean()
+ *
+ * Return value: the integer value
+ *
+ * Since: 0.8
+ */
+gboolean
+json_array_get_boolean_element (JsonArray *array,
+                                guint      index_)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (array != NULL, FALSE);
+  g_return_val_if_fail (index_ < array->elements->len, FALSE);
+
+  node = g_ptr_array_index (array->elements, index_);
+  g_return_val_if_fail (node != NULL, FALSE);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE, FALSE);
+
+  return json_node_get_boolean (node);
+}
+
+/**
+ * json_array_get_string_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ *
+ * Conveniently retrieves the string value of the element at @index_
+ * inside @array
+ *
+ * See also: json_array_get_element(), json_node_get_string()
+ *
+ * Return value: the string value; the returned string is owned by
+ *   the #JsonArray and should not be modified or freed
+ *
+ * Since: 0.8
+ */
+G_CONST_RETURN gchar *
+json_array_get_string_element (JsonArray *array,
+                               guint      index_)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (array != NULL, NULL);
+  g_return_val_if_fail (index_ < array->elements->len, NULL);
+
+  node = g_ptr_array_index (array->elements, index_);
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_HOLDS_VALUE (node) || JSON_NODE_HOLDS_NULL (node), NULL);
+
+  if (JSON_NODE_HOLDS_NULL (node))
+    return NULL;
+
+  return json_node_get_string (node);
+}
+
+/**
+ * json_array_get_null_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ *
+ * Conveniently retrieves whether the element at @index_ is set to null
+ *
+ * See also: json_array_get_element(), JSON_NODE_TYPE(), %JSON_NODE_NULL
+ *
+ * Return value: %TRUE if the element is null
+ *
+ * Since: 0.8
+ */
+gboolean
+json_array_get_null_element (JsonArray *array,
+                             guint      index_)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (array != NULL, FALSE);
+  g_return_val_if_fail (index_ < array->elements->len, FALSE);
+
+  node = g_ptr_array_index (array->elements, index_);
+  g_return_val_if_fail (node != NULL, FALSE);
+
+  return JSON_NODE_TYPE (node) == JSON_NODE_NULL;
+}
+
+/**
+ * json_array_get_array_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ *
+ * Conveniently retrieves the array from the element at @index_
+ * inside @array
+ *
+ * See also: json_array_get_element(), json_node_get_array()
+ *
+ * Return value: (transfer none): the array
+ *
+ * Since: 0.8
+ */
+JsonArray *
+json_array_get_array_element (JsonArray *array,
+                              guint      index_)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (array != NULL, NULL);
+  g_return_val_if_fail (index_ < array->elements->len, NULL);
+
+  node = g_ptr_array_index (array->elements, index_);
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_HOLDS_ARRAY (node) || JSON_NODE_HOLDS_NULL (node), NULL);
+
+  if (JSON_NODE_HOLDS_NULL (node))
+    return NULL;
+
+  return json_node_get_array (node);
+}
+
+/**
+ * json_array_get_object_element:
+ * @array: a #JsonArray
+ * @index_: the index of the element to retrieve
+ *
+ * Conveniently retrieves the object from the element at @index_
+ * inside @array
+ *
+ * See also: json_array_get_element(), json_node_get_object()
+ *
+ * Return value: (transfer none): the object
+ *
+ * Since: 0.8
+ */
+JsonObject *
+json_array_get_object_element (JsonArray *array,
+                               guint      index_)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (array != NULL, NULL);
+  g_return_val_if_fail (index_ < array->elements->len, NULL);
+
+  node = g_ptr_array_index (array->elements, index_);
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_HOLDS_OBJECT (node) || JSON_NODE_HOLDS_NULL (node), NULL);
+
+  if (JSON_NODE_HOLDS_NULL (node))
+    return NULL;
+
+  return json_node_get_object (node);
+}
+
+/**
+ * json_array_get_length:
+ * @array: a #JsonArray
+ *
+ * Retrieves the length of a #JsonArray
+ *
+ * Return value: the length of the array
+ */
+guint
+json_array_get_length (JsonArray *array)
+{
+  g_return_val_if_fail (array != NULL, 0);
+
+  return array->elements->len;
+}
+
+/**
+ * json_array_add_element:
+ * @array: a #JsonArray
+ * @node: (transfer full): a #JsonNode
+ *
+ * Appends @node inside @array. The array will take ownership of the
+ * #JsonNode.
+ */
+void
+json_array_add_element (JsonArray *array,
+                        JsonNode  *node)
+{
+  g_return_if_fail (array != NULL);
+  g_return_if_fail (node != NULL);
+
+  g_ptr_array_add (array->elements, node);
+}
+
+/**
+ * json_array_add_int_element:
+ * @array: a #JsonArray
+ * @value: an integer value
+ *
+ * Conveniently adds an integer @value into @array
+ *
+ * See also: json_array_add_element(), json_node_set_int()
+ *
+ * Since: 0.8
+ */
+void
+json_array_add_int_element (JsonArray *array,
+                            gint64     value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (array != NULL);
+
+  node = json_node_new (JSON_NODE_VALUE);
+  json_node_set_int (node, value);
+
+  g_ptr_array_add (array->elements, node);
+}
+
+/**
+ * json_array_add_double_element:
+ * @array: a #JsonArray
+ * @value: a floating point value
+ *
+ * Conveniently adds a floating point @value into @array
+ *
+ * See also: json_array_add_element(), json_node_set_double()
+ *
+ * Since: 0.8
+ */
+void
+json_array_add_double_element (JsonArray *array,
+                               gdouble    value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (array != NULL);
+
+  node = json_node_new (JSON_NODE_VALUE);
+  json_node_set_double (node, value);
+
+  g_ptr_array_add (array->elements, node);
+}
+
+/**
+ * json_array_add_boolean_element:
+ * @array: a #JsonArray
+ * @value: a boolean value
+ *
+ * Conveniently adds a boolean @value into @array
+ *
+ * See also: json_array_add_element(), json_node_set_boolean()
+ *
+ * Since: 0.8
+ */
+void
+json_array_add_boolean_element (JsonArray *array,
+                                gboolean   value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (array != NULL);
+
+  node = json_node_new (JSON_NODE_VALUE);
+  json_node_set_boolean (node, value);
+
+  g_ptr_array_add (array->elements, node);
+}
+
+/**
+ * json_array_add_string_element:
+ * @array: a #JsonArray
+ * @value: a string value
+ *
+ * Conveniently adds a string @value into @array
+ *
+ * See also: json_array_add_element(), json_node_set_string()
+ *
+ * Since: 0.8
+ */
+void
+json_array_add_string_element (JsonArray   *array,
+                               const gchar *value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (array != NULL);
+  g_return_if_fail (value != NULL);
+
+  if (value != NULL)
+    {
+      node = json_node_new (JSON_NODE_VALUE);
+      json_node_set_string (node, value);
+    }
+  else
+    node = json_node_new (JSON_NODE_NULL);
+
+  g_ptr_array_add (array->elements, node);
+}
+
+/**
+ * json_array_add_null_element:
+ * @array: a #JsonArray
+ *
+ * Conveniently adds a null element into @array
+ *
+ * See also: json_array_add_element(), %JSON_NODE_NULL
+ *
+ * Since: 0.8
+ */
+void
+json_array_add_null_element (JsonArray *array)
+{
+  JsonNode *node;
+
+  g_return_if_fail (array != NULL);
+
+  node = json_node_new (JSON_NODE_NULL);
+
+  g_ptr_array_add (array->elements, node);
+}
+
+/**
+ * json_array_add_array_element:
+ * @array: a #JsonArray
+ * @value: (transfer full): a #JsonArray
+ *
+ * Conveniently adds an array into @array. The @array takes ownership
+ * of the newly added #JsonArray
+ *
+ * See also: json_array_add_element(), json_node_take_array()
+ *
+ * Since: 0.8
+ */
+void
+json_array_add_array_element (JsonArray *array,
+                              JsonArray *value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (array != NULL);
+  g_return_if_fail (value != NULL);
+
+  if (value != NULL)
+    {
+      node = json_node_new (JSON_NODE_ARRAY);
+      json_node_take_array (node, value);
+    }
+  else
+    node = json_node_new (JSON_NODE_NULL);
+
+  g_ptr_array_add (array->elements, node);
+}
+
+/**
+ * json_array_add_object_element:
+ * @array: a #JsonArray
+ * @value: (transfer full): a #JsonObject
+ *
+ * Conveniently adds an object into @array. The @array takes ownership
+ * of the newly added #JsonObject
+ *
+ * See also: json_array_add_element(), json_node_take_object()
+ *
+ * Since: 0.8
+ */
+void
+json_array_add_object_element (JsonArray  *array,
+                               JsonObject *value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (array != NULL);
+  g_return_if_fail (value != NULL);
+
+  if (value != NULL)
+    {
+      node = json_node_new (JSON_NODE_OBJECT);
+      json_node_take_object (node, value);
+    }
+  else
+    node = json_node_new (JSON_NODE_NULL);
+
+  g_ptr_array_add (array->elements, node);
+}
+
+/**
+ * json_array_remove_element:
+ * @array: a #JsonArray
+ * @index_: the position of the element to be removed
+ *
+ * Removes the #JsonNode inside @array at @index_ freeing its allocated
+ * resources.
+ */
+void
+json_array_remove_element (JsonArray *array,
+                           guint      index_)
+{
+  g_return_if_fail (array != NULL);
+  g_return_if_fail (index_ < array->elements->len);
+
+  json_node_free (g_ptr_array_remove_index (array->elements, index_));
+}
+
+/**
+ * json_array_foreach_element:
+ * @array: a #JsonArray
+ * @func: (scope call): the function to be called on each element
+ * @data: (closure): data to be passed to the function
+ *
+ * Iterates over all elements of @array and calls @func on
+ * each one of them.
+ *
+ * It is safe to change the value of a #JsonNode of the @array
+ * from within the iterator @func, but it is not safe to add or
+ * remove elements from the @array.
+ *
+ * Since: 0.8
+ */
+void
+json_array_foreach_element (JsonArray        *array,
+                            JsonArrayForeach  func,
+                            gpointer          data)
+{
+  gint i;
+
+  g_return_if_fail (array != NULL);
+  g_return_if_fail (func != NULL);
+
+  for (i = 0; i < array->elements->len; i++)
+    {
+      JsonNode *element_node;
+
+      element_node = g_ptr_array_index (array->elements, i);
+
+      (* func) (array, i, element_node, data);
+    }
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-builder.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-builder.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-builder.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-builder.c	2011-03-27 09:15:30.772553000 -0600
@@ -0,0 +1,683 @@
+/* json-generator.c - JSON tree builder
+ *
+ * This file is part of JSON-GLib
+ * Copyright (C) 2010  Luca Bruno <lethalman88@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Luca Bruno  <lethalman88@gmail.com>
+ */
+
+/**
+ * SECTION:json-builder
+ * @Title: JsonBuilder
+ * @short_description: Generates JSON trees
+ * @See_Also: JsonGenerator
+ *
+ * #JsonBuilder provides an object for generating a JSON tree.
+ * You can generate only one tree with one #JsonBuilder instance.
+ *
+ * The root of the JSON tree can be either a #JsonObject or a #JsonArray.
+ * Thus the first call must necessarily be either
+ * json_builder_begin_object() or json_builder_begin_array().
+ *
+ * For convenience to language bindings, #JsonBuilder returns itself from
+ * most of functions, making it easy to chain function calls.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "json-types-private.h"
+
+#include "json-builder.h"
+
+#define JSON_BUILDER_GET_PRIVATE(obj) \
+        (G_TYPE_INSTANCE_GET_PRIVATE ((obj), JSON_TYPE_BUILDER, JsonBuilderPrivate))
+
+struct _JsonBuilderPrivate
+{
+  GQueue *stack;
+  JsonNode *root;
+};
+
+typedef enum
+{
+  JSON_BUILDER_MODE_OBJECT,
+  JSON_BUILDER_MODE_ARRAY,
+  JSON_BUILDER_MODE_MEMBER
+} JsonBuilderMode;
+
+typedef struct
+{
+  JsonBuilderMode mode;
+
+  union
+  {
+    JsonObject *object;
+    JsonArray *array;
+  } data;
+  gchar *member_name;
+} JsonBuilderState;
+
+static void
+json_builder_state_free (JsonBuilderState *state)
+{
+  if (G_LIKELY (state))
+    {
+      switch (state->mode)
+        {
+        case JSON_BUILDER_MODE_OBJECT:
+        case JSON_BUILDER_MODE_MEMBER:
+          json_object_unref (state->data.object);
+          g_free (state->member_name);
+          state->data.object = NULL;
+          state->member_name = NULL;
+          break;
+        case JSON_BUILDER_MODE_ARRAY:
+          json_array_unref (state->data.array);
+          state->data.array = NULL;
+          break;
+        default:
+          g_assert_not_reached ();
+        }
+
+      g_slice_free (JsonBuilderState, state);
+    }
+}
+
+G_DEFINE_TYPE (JsonBuilder, json_builder, G_TYPE_OBJECT);
+
+static void
+json_builder_free_all_state (JsonBuilder *builder)
+{
+  JsonBuilderState *state;
+
+  while (!g_queue_is_empty (builder->priv->stack))
+    {
+      state = g_queue_pop_head (builder->priv->stack);
+      json_builder_state_free (state);
+    }
+
+  if (builder->priv->root)
+    {
+      json_node_free (builder->priv->root);
+      builder->priv->root = NULL;
+    }
+}
+
+static void
+json_builder_finalize (GObject *gobject)
+{
+  JsonBuilderPrivate *priv = JSON_BUILDER_GET_PRIVATE (gobject);
+
+  json_builder_free_all_state (JSON_BUILDER (gobject));
+
+  g_queue_free (priv->stack);
+  priv->stack = NULL;
+
+  G_OBJECT_CLASS (json_builder_parent_class)->finalize (gobject);
+}
+
+static void
+json_builder_class_init (JsonBuilderClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (JsonBuilderPrivate));
+
+  gobject_class->finalize = json_builder_finalize;
+}
+
+static void
+json_builder_init (JsonBuilder *builder)
+{
+  JsonBuilderPrivate *priv;
+
+  builder->priv = priv = JSON_BUILDER_GET_PRIVATE (builder);
+
+  priv->stack = g_queue_new ();
+  priv->root = NULL;
+}
+
+static inline JsonBuilderMode
+json_builder_current_mode (JsonBuilder *builder)
+{
+  JsonBuilderState *state = g_queue_peek_head (builder->priv->stack);
+  return state->mode;
+}
+
+static inline gboolean
+json_builder_is_valid_add_mode (JsonBuilder *builder)
+{
+  JsonBuilderMode mode = json_builder_current_mode (builder);
+  return mode == JSON_BUILDER_MODE_MEMBER || mode == JSON_BUILDER_MODE_ARRAY;
+}
+
+/**
+ * json_builder_new:
+ *
+ * Creates a new #JsonBuilder. You can use this object to generate a
+ * JSON tree and obtain the root #JsonNode<!-- -->s.
+ *
+ * Return value: the newly created #JsonBuilder instance
+ */
+JsonBuilder *
+json_builder_new (void)
+{
+  return g_object_new (JSON_TYPE_BUILDER, NULL);
+}
+
+/**
+ * json_builder_get_root:
+ * @builder: a #JsonBuilder
+ *
+ * Returns the root of the current constructed tree, if the build is complete
+ * (ie: all opened objects, object members and arrays are being closed).
+ *
+ * Return value: (transfer full): the #JsonNode, or %NULL if the build is not complete.
+ *   Free the returned value with json_node_free().
+ */
+JsonNode *
+json_builder_get_root (JsonBuilder *builder)
+{
+  JsonNode *root = NULL;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+
+  if (builder->priv->root)
+    root = json_node_copy (builder->priv->root);
+
+  return root;
+}
+
+/**
+ * json_builder_reset:
+ * @builder: a #JsonBuilder
+ *
+ * Resets the state of the @builder back to its initial state.
+ */
+void
+json_builder_reset (JsonBuilder *builder)
+{
+  g_return_if_fail (JSON_IS_BUILDER (builder));
+
+  json_builder_free_all_state (builder);
+}
+
+/**
+ * json_builder_begin_object:
+ * @builder: a #JsonBuilder
+ *
+ * Opens a subobject inside the given @builder. When done adding members to
+ * the subobject, json_builder_end_object() must be called.
+ *
+ * Can be called for first or only if the call is associated to an object member
+ * or an array element.
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_begin_object (JsonBuilder *builder)
+{
+  JsonObject *object;
+  JsonBuilderState *state;
+  JsonBuilderState *cur_state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (builder->priv->root == NULL, NULL);
+  g_return_val_if_fail (g_queue_is_empty (builder->priv->stack) || json_builder_is_valid_add_mode (builder), NULL);
+
+  object = json_object_new ();
+  cur_state = g_queue_peek_head (builder->priv->stack);
+  if (cur_state)
+    {
+      switch (cur_state->mode)
+        {
+        case JSON_BUILDER_MODE_ARRAY:
+          json_array_add_object_element (cur_state->data.array, json_object_ref (object));
+          break;
+
+        case JSON_BUILDER_MODE_MEMBER:
+          json_object_set_object_member (cur_state->data.object, cur_state->member_name, json_object_ref (object));
+          g_free (cur_state->member_name);
+          cur_state->member_name = NULL;
+          cur_state->mode = JSON_BUILDER_MODE_OBJECT;
+          break;
+
+        default:
+          g_assert_not_reached ();
+        }
+    }
+
+  state = g_slice_new (JsonBuilderState);
+  state->data.object = object;
+  state->mode = JSON_BUILDER_MODE_OBJECT;
+  g_queue_push_head (builder->priv->stack, state);
+
+  return builder;
+}
+
+/**
+ * json_builder_end_object:
+ * @builder: a #JsonBuilder
+ *
+ * Closes the subobject inside the given @builder that was opened by the most
+ * recent call to json_builder_begin_object().
+ *
+ * Cannot be called after json_builder_set_member_name().
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_end_object (JsonBuilder *builder)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_current_mode (builder) == JSON_BUILDER_MODE_OBJECT, NULL);
+
+  state = g_queue_pop_head (builder->priv->stack);
+
+  if (g_queue_is_empty (builder->priv->stack))
+    {
+      builder->priv->root = json_node_new (JSON_NODE_OBJECT);
+      json_node_take_object (builder->priv->root, json_object_ref (state->data.object));
+    }
+
+  json_builder_state_free (state);
+
+  return builder;
+}
+
+/**
+ * json_builder_begin_array:
+ * @builder: a #JsonBuilder
+ *
+ * Opens a subarray inside the given @builder. When done adding members to
+ * the subarray, json_builder_end_array() must be called.
+ *
+ * Can be called for first or only if the call is associated to an object member
+ * or an array element.
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_begin_array (JsonBuilder *builder)
+{
+  JsonArray *array;
+  JsonBuilderState *state;
+  JsonBuilderState *cur_state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (builder->priv->root == NULL, NULL);
+  g_return_val_if_fail (g_queue_is_empty (builder->priv->stack) || json_builder_is_valid_add_mode (builder), NULL);
+
+  array = json_array_new ();
+  cur_state = g_queue_peek_head (builder->priv->stack);
+  if (cur_state)
+    {
+      switch (cur_state->mode)
+        {
+        case JSON_BUILDER_MODE_ARRAY:
+          json_array_add_array_element (cur_state->data.array, json_array_ref (array));
+          break;
+
+        case JSON_BUILDER_MODE_MEMBER:
+          json_object_set_array_member (cur_state->data.object, cur_state->member_name, json_array_ref (array));
+          g_free (cur_state->member_name);
+          cur_state->member_name = NULL;
+          cur_state->mode = JSON_BUILDER_MODE_OBJECT;
+          break;
+
+        default:
+          g_assert_not_reached ();
+        }
+    }
+
+  state = g_slice_new (JsonBuilderState);
+  state->data.array = array;
+  state->mode = JSON_BUILDER_MODE_ARRAY;
+  g_queue_push_head (builder->priv->stack, state);
+
+  return builder;
+}
+
+/**
+ * json_builder_end_array:
+ * @builder: a #JsonBuilder
+ *
+ * Closes the subarray inside the given @builder that was opened by the most
+ * recent call to json_builder_begin_array().
+ *
+ * Cannot be called after json_builder_set_member_name().
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_end_array (JsonBuilder *builder)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_current_mode (builder) == JSON_BUILDER_MODE_ARRAY, NULL);
+
+  state = g_queue_pop_head (builder->priv->stack);
+
+  if (g_queue_is_empty (builder->priv->stack))
+    {
+      builder->priv->root = json_node_new (JSON_NODE_ARRAY);
+      json_node_take_array (builder->priv->root, json_array_ref (state->data.array));
+    }
+
+  json_builder_state_free (state);
+
+  return builder;
+}
+
+/**
+ * json_builder_set_member_name:
+ * @builder: a #JsonBuilder
+ * @member_name: the name of the member
+ *
+ * Set the name of the next member in an object. The next call must add a value,
+ * open an object or an array.
+ *
+ * Can be called only if the call is associated to an object.
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_set_member_name (JsonBuilder *builder, const gchar *member_name)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (member_name != NULL, NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_current_mode (builder) == JSON_BUILDER_MODE_OBJECT, NULL);
+
+  state = g_queue_peek_head (builder->priv->stack);
+  state->member_name = g_strdup (member_name);
+  state->mode = JSON_BUILDER_MODE_MEMBER;
+
+  return builder;
+}
+
+/**
+ * json_builder_add_value:
+ * @builder: a #JsonBuilder
+ * @node: the value of the member or element
+ *
+ * If called after json_builder_set_member_name(), sets @node as member of the
+ * most recent opened object, otherwise @node is added as element of the most
+ * recent opened array.
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_add_value (JsonBuilder *builder, JsonNode *node)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_is_valid_add_mode (builder), NULL);
+
+  state = g_queue_peek_head (builder->priv->stack);
+  switch (state->mode)
+    {
+    case JSON_BUILDER_MODE_MEMBER:
+      json_object_set_member (state->data.object, state->member_name, node);
+      g_free (state->member_name);
+      state->member_name = NULL;
+      state->mode = JSON_BUILDER_MODE_OBJECT;
+      break;
+
+    case JSON_BUILDER_MODE_ARRAY:
+      json_array_add_element (state->data.array, node);
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  return builder;
+}
+
+/**
+ * json_builder_add_int_value:
+ * @builder: a #JsonBuilder
+ * @value: the value of the member or element
+ *
+ * If called after json_builder_set_member_name(), sets @value as member of the
+ * most recent opened object, otherwise @value is added as element of the most
+ * recent opened array.
+ *
+ * See also: json_builder_add_value()
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_add_int_value (JsonBuilder *builder, gint64 value)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_is_valid_add_mode (builder), NULL);
+
+  state = g_queue_peek_head (builder->priv->stack);
+  switch (state->mode)
+    {
+    case JSON_BUILDER_MODE_MEMBER:
+      json_object_set_int_member (state->data.object, state->member_name, value);
+      g_free (state->member_name);
+      state->member_name = NULL;
+      state->mode = JSON_BUILDER_MODE_OBJECT;
+      break;
+
+    case JSON_BUILDER_MODE_ARRAY:
+      json_array_add_int_element (state->data.array, value);
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  return builder;
+}
+
+/**
+ * json_builder_add_double_value:
+ * @builder: a #JsonBuilder
+ * @value: the value of the member or element
+ *
+ * If called after json_builder_set_member_name(), sets @value as member of the
+ * most recent opened object, otherwise @value is added as element of the most
+ * recent opened array.
+ *
+ * See also: json_builder_add_value()
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_add_double_value (JsonBuilder *builder, gdouble value)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_is_valid_add_mode (builder), NULL);
+
+  state = g_queue_peek_head (builder->priv->stack);
+
+  switch (state->mode)
+    {
+    case JSON_BUILDER_MODE_MEMBER:
+      json_object_set_double_member (state->data.object, state->member_name, value);
+      g_free (state->member_name);
+      state->member_name = NULL;
+      state->mode = JSON_BUILDER_MODE_OBJECT;
+      break;
+
+    case JSON_BUILDER_MODE_ARRAY:
+      json_array_add_double_element (state->data.array, value);
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  return builder;
+}
+
+/**
+ * json_builder_add_boolean_value:
+ * @builder: a #JsonBuilder
+ * @value: the value of the member or element
+ *
+ * If called after json_builder_set_member_name(), sets @value as member of the
+ * most recent opened object, otherwise @value is added as element of the most
+ * recent opened array.
+ *
+ * See also: json_builder_add_value()
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_add_boolean_value (JsonBuilder *builder, gboolean value)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_is_valid_add_mode (builder), NULL);
+
+  state = g_queue_peek_head (builder->priv->stack);
+
+  switch (state->mode)
+    {
+    case JSON_BUILDER_MODE_MEMBER:
+      json_object_set_boolean_member (state->data.object, state->member_name, value);
+      g_free (state->member_name);
+      state->member_name = NULL;
+      state->mode = JSON_BUILDER_MODE_OBJECT;
+      break;
+
+    case JSON_BUILDER_MODE_ARRAY:
+      json_array_add_boolean_element (state->data.array, value);
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  return builder;
+}
+
+/**
+ * json_builder_add_string_value:
+ * @builder: a #JsonBuilder
+ * @value: the value of the member or element
+ *
+ * If called after json_builder_set_member_name(), sets @value as member of the
+ * most recent opened object, otherwise @value is added as element of the most
+ * recent opened array.
+ *
+ * See also: json_builder_add_value()
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_add_string_value (JsonBuilder *builder, const gchar *value)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_is_valid_add_mode (builder), NULL);
+
+  state = g_queue_peek_head (builder->priv->stack);
+
+  switch (state->mode)
+    {
+    case JSON_BUILDER_MODE_MEMBER:
+      json_object_set_string_member (state->data.object, state->member_name, value);
+      g_free (state->member_name);
+      state->member_name = NULL;
+      state->mode = JSON_BUILDER_MODE_OBJECT;
+      break;
+
+    case JSON_BUILDER_MODE_ARRAY:
+      json_array_add_string_element (state->data.array, value);
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  return builder;
+}
+
+/**
+ * json_builder_add_null_value:
+ * @builder: a #JsonBuilder
+ *
+ * If called after json_builder_set_member_name(), sets null as member of the
+ * most recent opened object, otherwise null is added as element of the most
+ * recent opened array.
+ *
+ * See also: json_builder_add_value()
+ *
+ * Return value: (transfer none): the #JsonBuilder, or %NULL if the call was inconsistent
+ */
+JsonBuilder *
+json_builder_add_null_value (JsonBuilder *builder)
+{
+  JsonBuilderState *state;
+
+  g_return_val_if_fail (JSON_IS_BUILDER (builder), NULL);
+  g_return_val_if_fail (!g_queue_is_empty (builder->priv->stack), NULL);
+  g_return_val_if_fail (json_builder_is_valid_add_mode (builder), NULL);
+
+  state = g_queue_peek_head (builder->priv->stack);
+
+  switch (state->mode)
+    {
+    case JSON_BUILDER_MODE_MEMBER:
+      json_object_set_null_member (state->data.object, state->member_name);
+      g_free (state->member_name);
+      state->member_name = NULL;
+      state->mode = JSON_BUILDER_MODE_OBJECT;
+      break;
+
+    case JSON_BUILDER_MODE_ARRAY:
+      json_array_add_null_element (state->data.array);
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  return builder;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-builder.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-builder.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-builder.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-builder.h	2011-03-27 09:15:30.776552999 -0600
@@ -0,0 +1,106 @@
+/* json-builder.h: JSON tree builder
+ *
+ * This file is part of JSON-GLib
+ * Copyright (C) 2010  Luca Bruno <lethalman88@gmail.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Luca Bruno  <lethalman88@gmail.com>
+ */
+
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_BUILDER_H__
+#define __JSON_BUILDER_H__
+
+#include <json-glib/json-types.h>
+
+G_BEGIN_DECLS
+
+#define JSON_TYPE_BUILDER             (json_builder_get_type ())
+#define JSON_BUILDER(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), JSON_TYPE_BUILDER, JsonBuilder))
+#define JSON_IS_BUILDER(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JSON_TYPE_BUILDER))
+#define JSON_BUILDER_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), JSON_TYPE_BUILDER, JsonBuilderClass))
+#define JSON_IS_BUILDER_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), JSON_TYPE_BUILDER))
+#define JSON_BUILDER_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), JSON_TYPE_BUILDER, JsonBuilderClass))
+
+typedef struct _JsonBuilder           JsonBuilder;
+typedef struct _JsonBuilderPrivate    JsonBuilderPrivate;
+typedef struct _JsonBuilderClass      JsonBuilderClass;
+
+/**
+ * JsonBuilder:
+ *
+ * The <structname>JsonBuilder</structname> structure contains only
+ * private data and shouls be accessed using the provided API
+ *
+ * Since: 0.12
+ */
+struct _JsonBuilder
+{
+  /*< private >*/
+  GObject parent_instance;
+
+  JsonBuilderPrivate *priv;
+};
+
+/**
+ * JsonBuilderClass:
+ *
+ * The <structname>JsonBuilder</structname> structure contains only
+ * private data
+ *
+ * Since: 0.12
+ */
+struct _JsonBuilderClass
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  /* padding, for future expansion */
+  void (* _json_reserved1) (void);
+  void (* _json_reserved2) (void);
+};
+
+GType json_builder_get_type (void) G_GNUC_CONST;
+
+JsonBuilder *json_builder_new                (void);
+JsonNode    *json_builder_get_root           (JsonBuilder  *builder);
+void         json_builder_reset              (JsonBuilder  *builder);
+
+JsonBuilder *json_builder_begin_array        (JsonBuilder  *builder);
+JsonBuilder *json_builder_end_array          (JsonBuilder  *builder);
+JsonBuilder *json_builder_begin_object       (JsonBuilder  *builder);
+JsonBuilder *json_builder_end_object         (JsonBuilder  *builder);
+
+JsonBuilder *json_builder_set_member_name    (JsonBuilder  *builder,
+                                              const gchar  *member_name);
+JsonBuilder *json_builder_add_value          (JsonBuilder  *builder,
+                                              JsonNode     *node);
+JsonBuilder *json_builder_add_int_value      (JsonBuilder  *builder,
+                                              gint64        value);
+JsonBuilder *json_builder_add_double_value   (JsonBuilder  *builder,
+                                              gdouble       value);
+JsonBuilder *json_builder_add_boolean_value  (JsonBuilder  *builder,
+                                              gboolean      value);
+JsonBuilder *json_builder_add_string_value   (JsonBuilder  *builder,
+                                              const gchar  *value);
+JsonBuilder *json_builder_add_null_value     (JsonBuilder  *builder);
+
+G_END_DECLS
+
+#endif /* __JSON_BUILDER_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-debug.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-debug.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-debug.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-debug.c	2011-03-27 09:15:30.768552999 -0600
@@ -0,0 +1,38 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include "json-debug.h"
+
+static unsigned int json_debug_flags     = 0;
+static gboolean     json_debug_flags_set = FALSE;
+
+#ifdef JSON_ENABLE_DEBUG
+static const GDebugKey json_debug_keys[] = {
+  { "parser", JSON_DEBUG_PARSER },
+  { "gobject", JSON_DEBUG_GOBJECT }
+};
+#endif /* JSON_ENABLE_DEBUG */
+
+JsonDebugFlags
+_json_get_debug_flags (void)
+{
+#ifdef JSON_ENABLE_DEBUG
+  const gchar *env_str;
+
+  if (json_debug_flags_set)
+    return json_debug_flags;
+
+  env_str = g_getenv ("JSON_DEBUG");
+  if (env_str != NULL && *env_str != '\0')
+    {
+      json_debug_flags |= g_parse_debug_string (env_str,
+                                                json_debug_keys,
+                                                G_N_ELEMENTS (json_debug_keys));
+    }
+
+  json_debug_flags_set = TRUE;
+#endif /* JSON_ENABLE_DEBUG */
+
+  return json_debug_flags;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-debug.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-debug.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-debug.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-debug.h	2011-03-27 09:15:30.820553000 -0600
@@ -0,0 +1,46 @@
+#ifndef __JSON_DEBUG_H__
+#define __JSON_DEBUG_H__
+
+#include <glib.h>
+
+G_BEGIN_DECLS
+
+typedef enum {
+  JSON_DEBUG_PARSER  = 1 << 0,
+  JSON_DEBUG_GOBJECT = 1 << 1
+} JsonDebugFlags;
+
+#ifdef JSON_ENABLE_DEBUG
+
+# ifdef __GNUC__
+
+# define JSON_NOTE(type,x,a...)                 G_STMT_START {  \
+        if (_json_get_debug_flags () & JSON_DEBUG_##type) {     \
+          g_message ("[" #type "] " G_STRLOC ": " x, ##a);      \
+        }                                       } G_STMT_END
+
+# else
+/* Try the C99 version; unfortunately, this does not allow us to pass
+ * empty arguments to the macro, which means we have to
+ * do an intemediate printf.
+ */
+# define JSON_NOTE(type,...)                    G_STMT_START {  \
+        if (_json_get_debug_flags () & JSON_DEBUG_##type) {     \
+            gchar * _fmt = g_strdup_printf (__VA_ARGS__);       \
+            g_message ("[" #type "] " G_STRLOC ": %s",_fmt);    \
+            g_free (_fmt);                                      \
+        }                                       } G_STMT_END
+
+# endif /* __GNUC__ */
+
+#else
+
+#define JSON_NOTE(type,...)         G_STMT_START { } G_STMT_END
+
+#endif /* JSON_ENABLE_DEBUG */
+
+JsonDebugFlags _json_get_debug_flags (void);
+
+G_END_DECLS
+
+#endif /* __JSON_DEBUG_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-enum-types.c.in pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-enum-types.c.in
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-enum-types.c.in	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-enum-types.c.in	2011-03-27 09:15:30.772553000 -0600
@@ -0,0 +1,39 @@
+/*** BEGIN file-header ***/
+#include "json-enum-types.h"
+/*** END file-header ***/
+
+/*** BEGIN file-production ***/
+
+/* enumerations from "@filename@" */
+#include "@filename@"
+
+/*** END file-production ***/
+
+/*** BEGIN value-header ***/
+GType
+@enum_name@_get_type(void) {
+  static volatile gsize g_enum_type_id__volatile = 0;
+
+  if (g_once_init_enter (&g_enum_type_id__volatile))
+    {
+      static const G@Type@Value values[] = {
+/*** END value-header ***/
+
+/*** BEGIN value-production ***/
+        { @VALUENAME@, "@VALUENAME@", "@valuenick@" },
+/*** END value-production ***/
+
+/*** BEGIN value-tail ***/
+        { 0, NULL, NULL }
+      };
+      GType g_enum_type_id;
+
+      g_enum_type_id =
+        g_@type@_register_static (g_intern_static_string ("@EnumName@"), values);
+
+      g_once_init_leave (&g_enum_type_id__volatile, g_enum_type_id);
+    }
+
+  return g_enum_type_id__volatile;
+}
+/*** END value-tail ***/
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-enum-types.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-enum-types.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-enum-types.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-enum-types.h	2011-03-27 09:15:30.764553000 -0600
@@ -0,0 +1,32 @@
+
+/* Generated data (by glib-mkenums) */
+
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_ENUM_TYPES_H__
+#define __JSON_ENUM_TYPES_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+/* enumerations from "json-parser.h" */
+GType json_parser_error_get_type (void) G_GNUC_CONST;
+#define JSON_TYPE_PARSER_ERROR (json_parser_error_get_type())
+
+/* enumerations from "json-reader.h" */
+GType json_reader_error_get_type (void) G_GNUC_CONST;
+#define JSON_TYPE_READER_ERROR (json_reader_error_get_type())
+
+/* enumerations from "json-types.h" */
+GType json_node_type_get_type (void) G_GNUC_CONST;
+#define JSON_TYPE_NODE_TYPE (json_node_type_get_type())
+
+G_END_DECLS
+
+#endif /* !__JSON_ENUM_TYPES_H__ */
+
+/* Generated data ends here */
+
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-enum-types.h.in pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-enum-types.h.in
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-enum-types.h.in	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-enum-types.h.in	2011-03-27 09:15:30.772553000 -0600
@@ -0,0 +1,30 @@
+/*** BEGIN file-header ***/
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_ENUM_TYPES_H__
+#define __JSON_ENUM_TYPES_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+/*** END file-header ***/
+
+/*** BEGIN file-production ***/
+/* enumerations from "@filename@" */
+/*** END file-production ***/
+
+/*** BEGIN file-tail ***/
+G_END_DECLS
+
+#endif /* !__JSON_ENUM_TYPES_H__ */
+/*** END file-tail ***/
+
+/*** BEGIN value-header ***/
+GType @enum_name@_get_type (void) G_GNUC_CONST;
+#define JSON_TYPE_@ENUMSHORT@ (@enum_name@_get_type())
+
+/*** END value-header ***/
+
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gboxed.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gboxed.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gboxed.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gboxed.c	2011-03-27 09:15:30.764553000 -0600
@@ -0,0 +1,354 @@
+/* json-gboxed.c - JSON GBoxed integration
+ * 
+ * This file is part of JSON-GLib
+ *
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+/**
+ * SECTION:json-gboxed
+ * @short_description: Serialize and deserialize GBoxed types
+ *
+ * GLib's #GBoxed type is a generic wrapper for arbitrary C structures.
+ *
+ * JSON-GLib allows serialization and deserialization of a #GBoxed type
+ * by registering functions mapping a #JsonNodeType to a specific
+ * #GType.
+ *
+ * When registering a #GBoxed type you should also register the
+ * corresponding transformation functions, e.g.:
+ *
+ * |[
+ *   GType
+ *   my_struct_get_type (void)
+ *   {
+ *     static GType boxed_type = 0;
+ *
+ *     if (boxed_type == 0)
+ *       {
+ *         boxed_type =
+ *           g_boxed_type_register_static (g_intern_static_string ("MyStruct"),
+ *                                         (GBoxedCopyFunc) my_struct_copy,
+ *                                         (GBoxedFreeFunc) my_struct_free);
+ *
+ *         json_boxed_register_serialize_func (boxed_type, JSON_NODE_OBJECT,
+ *                                             my_struct_serialize);
+ *         json_boxed_register_deserialize_func (boxed_type, JSON_NODE_OBJECT,
+ *                                               my_struct_deserialize);
+ *       }
+ *
+ *     return boxed_type;
+ *   }
+ * ]|
+ *
+ * The serialization function will be invoked by json_boxed_serialize():
+ * it will be passed a pointer to the C structure and it must return a
+ * #JsonNode. The deserialization function will be invoked by
+ * json_boxed_deserialize(): it will be passed a #JsonNode for the
+ * declared type and it must return a newly allocated C structure.
+ *
+ * It is possible to check whether a #GBoxed type can be deserialized
+ * from a specific #JsonNodeType, and whether a #GBoxed can be serialized
+ * and to which specific #JsonNodeType.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "json-types-private.h"
+#include "json-gobject.h"
+
+typedef struct _BoxedTransform  BoxedTransform;
+
+struct _BoxedTransform
+{
+  GType boxed_type;
+  gint node_type;
+
+  JsonBoxedSerializeFunc serialize;
+  JsonBoxedDeserializeFunc deserialize;
+};
+
+G_LOCK_DEFINE_STATIC (boxed_serialize);
+static GSList *boxed_serialize = NULL;
+
+G_LOCK_DEFINE_STATIC (boxed_deserialize);
+static GSList *boxed_deserialize = NULL;
+
+static gint
+boxed_transforms_cmp (gconstpointer a,
+                      gconstpointer b)
+{
+  const BoxedTransform *ta = a;
+  const BoxedTransform *tb = b;
+
+  return tb->boxed_type - ta->boxed_type;
+}
+
+static gint
+boxed_transforms_find (gconstpointer a,
+                       gconstpointer b)
+{
+  const BoxedTransform *haystack = a;
+  const BoxedTransform *needle = b;
+
+  if (needle->node_type != -1)
+    return (haystack->boxed_type == needle->boxed_type &&
+            haystack->node_type == needle->node_type) ? 0 : 1;
+  else
+    return (haystack->boxed_type == needle->boxed_type) ? 0 : 1;
+}
+
+static BoxedTransform *
+lookup_boxed_transform (GSList       *transforms,
+                        GType         gboxed_type,
+                        JsonNodeType  node_type)
+{
+  BoxedTransform lookup;
+  GSList *t;
+
+  lookup.boxed_type = gboxed_type;
+  lookup.node_type = node_type;
+
+  t = g_slist_find_custom (transforms, &lookup, boxed_transforms_find);
+  if (t == NULL)
+    return NULL;
+
+  return t->data;
+}
+
+/**
+ * json_boxed_register_serialize_func: (skip)
+ * @gboxed_type: a boxed type
+ * @node_type: a node type
+ * @serialize_func: serialization function for @boxed_type into
+ *   a #JsonNode of type @node_type
+ *
+ * Registers a serialization function for a #GBoxed of type @gboxed_type
+ * to a #JsonNode of type @node_type
+ *
+ * Since: 0.10
+ */
+void
+json_boxed_register_serialize_func (GType                  gboxed_type,
+                                    JsonNodeType           node_type,
+                                    JsonBoxedSerializeFunc serialize_func)
+{
+  BoxedTransform *t;
+
+  g_return_if_fail (G_TYPE_IS_BOXED (gboxed_type));
+  g_return_if_fail (G_TYPE_IS_ABSTRACT (gboxed_type) == FALSE);
+
+  G_LOCK (boxed_serialize);
+
+  t = lookup_boxed_transform (boxed_serialize, gboxed_type, node_type);
+  if (t == NULL)
+    {
+      t = g_slice_new (BoxedTransform);
+
+      t->boxed_type = gboxed_type;
+      t->node_type = node_type;
+      t->serialize = serialize_func;
+
+      boxed_serialize = g_slist_insert_sorted (boxed_serialize, t,
+                                               boxed_transforms_cmp);
+    }
+  else
+    g_warning ("A serialization function for the boxed type %s into "
+               "JSON nodes of type %s already exists",
+               g_type_name (gboxed_type),
+               json_node_type_get_name (node_type));
+
+  G_UNLOCK (boxed_serialize);
+}
+
+/**
+ * json_boxed_register_deserialize_func: (skip)
+ * @gboxed_type: a boxed type
+ * @node_type: a node type
+ * @deserialize_func: deserialization function for @boxed_type from
+ *   a #JsonNode of type @node_type
+ *
+ * Registers a deserialization function for a #GBoxed of type @gboxed_type
+ * from a #JsonNode of type @node_type
+ *
+ * Since: 0.10
+ */
+void
+json_boxed_register_deserialize_func (GType                    gboxed_type,
+                                      JsonNodeType             node_type,
+                                      JsonBoxedDeserializeFunc deserialize_func)
+{
+  BoxedTransform *t;
+
+  g_return_if_fail (G_TYPE_IS_BOXED (gboxed_type));
+  g_return_if_fail (G_TYPE_IS_ABSTRACT (gboxed_type) == FALSE);
+
+  G_LOCK (boxed_deserialize);
+
+  t = lookup_boxed_transform (boxed_deserialize, gboxed_type, node_type);
+  if (t == NULL)
+    {
+      t = g_slice_new (BoxedTransform);
+
+      t->boxed_type = gboxed_type;
+      t->node_type = node_type;
+      t->deserialize = deserialize_func;
+
+      boxed_deserialize = g_slist_insert_sorted (boxed_deserialize, t,
+                                                 boxed_transforms_cmp);
+    }
+  else
+    g_warning ("A deserialization function for the boxed type %s from "
+               "JSON nodes of type %s already exists",
+               g_type_name (gboxed_type),
+               json_node_type_get_name (node_type));
+
+  G_UNLOCK (boxed_deserialize);
+}
+
+/**
+ * json_boxed_can_serialize:
+ * @gboxed_type: a boxed type
+ * @node_type: (out): the #JsonNode type to which the boxed type can be
+ *   serialized into
+ *
+ * Checks whether it is possible to serialize a #GBoxed of
+ * type @gboxed_type into a #JsonNode. The type of the
+ * #JsonNode is placed inside @node_type if the function
+ * returns %TRUE and it's undefined otherwise.
+ *
+ * Return value: %TRUE if the type can be serialized,
+ *   and %FALSE otherwise.
+ *
+ * Since: 0.10
+ */
+gboolean
+json_boxed_can_serialize (GType         gboxed_type,
+                          JsonNodeType *node_type)
+{
+  BoxedTransform *t;
+
+  g_return_val_if_fail (G_TYPE_IS_BOXED (gboxed_type), FALSE);
+  g_return_val_if_fail (G_TYPE_IS_ABSTRACT (gboxed_type) == FALSE, FALSE);
+
+  t = lookup_boxed_transform (boxed_serialize, gboxed_type, -1);
+  if (t != NULL)
+    {
+      if (node_type)
+        *node_type = t->node_type;
+
+      return TRUE;
+    }
+
+  return FALSE;
+}
+
+/**
+ * json_boxed_can_deserialize:
+ * @gboxed_type: a boxed type
+ * @node_type: a #JsonNode type
+ *
+ * Checks whether it is possible to deserialize a #GBoxed of
+ * type @gboxed_type from a #JsonNode of type @node_type
+ *
+ * Return value: %TRUE if the type can be deserialized, %FALSE otherwise
+ *
+ * Since: 0.10
+ */
+gboolean
+json_boxed_can_deserialize (GType        gboxed_type,
+                            JsonNodeType node_type)
+{
+  BoxedTransform *t;
+
+  g_return_val_if_fail (G_TYPE_IS_BOXED (gboxed_type), FALSE);
+  g_return_val_if_fail (G_TYPE_IS_ABSTRACT (gboxed_type) == FALSE, FALSE);
+
+  t = lookup_boxed_transform (boxed_deserialize, gboxed_type, node_type);
+  if (t != NULL)
+    return TRUE;
+
+  return FALSE;
+}
+
+/**
+ * json_boxed_serialize:
+ * @gboxed_type: a boxed type
+ * @boxed: a pointer to a #GBoxed of type @gboxed_type
+ *
+ * Serializes @boxed, a pointer to a #GBoxed of type @gboxed_type,
+ * into a #JsonNode
+ *
+ * Return value: (transfer full): a #JsonNode with the serialization of the
+ *   boxed type, or %NULL if serialization either failed or was not possible
+ *
+ * Since: 0.10
+ */
+JsonNode *
+json_boxed_serialize (GType         gboxed_type,
+                      gconstpointer boxed)
+{
+  BoxedTransform *t;
+
+  g_return_val_if_fail (G_TYPE_IS_BOXED (gboxed_type), NULL);
+  g_return_val_if_fail (G_TYPE_IS_ABSTRACT (gboxed_type) == FALSE, NULL);
+  g_return_val_if_fail (boxed != NULL, NULL);
+
+  t = lookup_boxed_transform (boxed_serialize, gboxed_type, -1);
+  if (t != NULL && t->serialize != NULL)
+    return t->serialize (boxed);
+
+  return NULL;
+}
+
+/**
+ * json_boxed_deserialize:
+ * @gboxed_type: a boxed type
+ * @node: a #JsonNode
+ *
+ * Deserializes @node into a #GBoxed of @gboxed_type
+ *
+ * Return value: (transfer full): the newly allocated #GBoxed. Use
+ *   g_boxed_free() to release the resources allocated by this
+ *   function
+ *
+ * Since: 0.10
+ */
+gpointer
+json_boxed_deserialize (GType     gboxed_type,
+                        JsonNode *node)
+{
+  JsonNodeType node_type;
+  BoxedTransform *t;
+
+  g_return_val_if_fail (G_TYPE_IS_BOXED (gboxed_type), NULL);
+  g_return_val_if_fail (G_TYPE_IS_ABSTRACT (gboxed_type) == FALSE, NULL);
+  g_return_val_if_fail (node != NULL, NULL);
+
+  node_type = json_node_get_node_type (node);
+
+  t = lookup_boxed_transform (boxed_deserialize, gboxed_type, node_type);
+  if (t != NULL && t->deserialize != NULL)
+    return t->deserialize (node);
+
+  return NULL;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-generator.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-generator.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-generator.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-generator.c	2011-03-27 09:15:30.776552999 -0600
@@ -0,0 +1,870 @@
+/* json-generator.c - JSON streams generator
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+/**
+ * SECTION:json-generator
+ * @short_description: Generates JSON data streams
+ *
+ * #JsonGenerator provides an object for generating a JSON data stream and
+ * put it into a buffer or a file.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <string.h>
+
+#include "json-types-private.h"
+
+#include "json-marshal.h"
+#include "json-generator.h"
+
+#define JSON_GENERATOR_GET_PRIVATE(obj) \
+        (G_TYPE_INSTANCE_GET_PRIVATE ((obj), JSON_TYPE_GENERATOR, JsonGeneratorPrivate))
+
+struct _JsonGeneratorPrivate
+{
+  JsonNode *root;
+
+  guint indent;
+  gunichar indent_char;
+
+  guint pretty : 1;
+};
+
+enum
+{
+  PROP_0,
+
+  PROP_PRETTY,
+  PROP_INDENT,
+  PROP_ROOT,
+  PROP_INDENT_CHAR,
+
+  PROP_LAST
+};
+
+static gchar *dump_value  (JsonGenerator *generator,
+                           gint           level,
+                           const gchar   *name,
+                           JsonNode      *node,
+                           gsize         *length);
+static gchar *dump_array  (JsonGenerator *generator,
+                           gint           level,
+                           const gchar   *name,
+                           JsonArray     *array,
+                           gsize         *length);
+static gchar *dump_object (JsonGenerator *generator,
+                           gint           level,
+                           const gchar   *name,
+                           JsonObject    *object,
+                           gsize         *length);
+
+/* non-ASCII characters can't be escaped, otherwise UTF-8
+ * chars will break, so we just pregenerate this table of
+ * high characters and then we feed it to g_strescape()
+ */
+static const char json_exceptions[] = {
+  0x7f,  0x80,  0x81,  0x82,  0x83,  0x84,  0x85,  0x86,
+  0x87,  0x88,  0x89,  0x8a,  0x8b,  0x8c,  0x8d,  0x8e,
+  0x8f,  0x90,  0x91,  0x92,  0x93,  0x94,  0x95,  0x96,
+  0x97,  0x98,  0x99,  0x9a,  0x9b,  0x9c,  0x9d,  0x9e,
+  0x9f,  0xa0,  0xa1,  0xa2,  0xa3,  0xa4,  0xa5,  0xa6,
+  0xa7,  0xa8,  0xa9,  0xaa,  0xab,  0xac,  0xad,  0xae,
+  0xaf,  0xb0,  0xb1,  0xb2,  0xb3,  0xb4,  0xb5,  0xb6,
+  0xb7,  0xb8,  0xb9,  0xba,  0xbb,  0xbc,  0xbd,  0xbe,
+  0xbf,  0xc0,  0xc1,  0xc2,  0xc3,  0xc4,  0xc5,  0xc6,
+  0xc7,  0xc8,  0xc9,  0xca,  0xcb,  0xcc,  0xcd,  0xce,
+  0xcf,  0xd0,  0xd1,  0xd2,  0xd3,  0xd4,  0xd5,  0xd6,
+  0xd7,  0xd8,  0xd9,  0xda,  0xdb,  0xdc,  0xdd,  0xde,
+  0xdf,  0xe0,  0xe1,  0xe2,  0xe3,  0xe4,  0xe5,  0xe6,
+  0xe7,  0xe8,  0xe9,  0xea,  0xeb,  0xec,  0xed,  0xee,
+  0xef,  0xf0,  0xf1,  0xf2,  0xf3,  0xf4,  0xf5,  0xf6,
+  0xf7,  0xf8,  0xf9,  0xfa,  0xfb,  0xfc,  0xfd,  0xfe,
+  0xff,
+  '\0'   /* g_strescape() expects a NUL-terminated string */
+};
+
+static GParamSpec *generator_props[PROP_LAST] = { NULL, };
+
+G_DEFINE_TYPE (JsonGenerator, json_generator, G_TYPE_OBJECT);
+
+static gchar *
+json_strescape (const gchar *str)
+{
+  return g_strescape (str, json_exceptions);
+}
+
+static void
+json_generator_finalize (GObject *gobject)
+{
+  JsonGeneratorPrivate *priv = JSON_GENERATOR_GET_PRIVATE (gobject);
+
+  if (priv->root)
+    json_node_free (priv->root);
+
+  G_OBJECT_CLASS (json_generator_parent_class)->finalize (gobject);
+}
+
+static void
+json_generator_set_property (GObject      *gobject,
+                             guint         prop_id,
+                             const GValue *value,
+                             GParamSpec   *pspec)
+{
+  JsonGenerator *generator = JSON_GENERATOR (gobject);
+
+  switch (prop_id)
+    {
+    case PROP_PRETTY:
+      json_generator_set_pretty (generator, g_value_get_boolean (value));
+      break;
+
+    case PROP_INDENT:
+      json_generator_set_indent (generator, g_value_get_uint (value));
+      break;
+
+    case PROP_INDENT_CHAR:
+      json_generator_set_indent_char (generator, g_value_get_uint (value));
+      break;
+
+    case PROP_ROOT:
+      json_generator_set_root (generator, g_value_get_boxed (value));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+json_generator_get_property (GObject    *gobject,
+                             guint       prop_id,
+                             GValue     *value,
+                             GParamSpec *pspec)
+{
+  JsonGeneratorPrivate *priv = JSON_GENERATOR (gobject)->priv;
+
+  switch (prop_id)
+    {
+    case PROP_PRETTY:
+      g_value_set_boolean (value, priv->pretty);
+      break;
+    case PROP_INDENT:
+      g_value_set_uint (value, priv->indent);
+      break;
+    case PROP_INDENT_CHAR:
+      g_value_set_uint (value, priv->indent_char);
+      break;
+    case PROP_ROOT:
+      g_value_set_boxed (value, priv->root);
+      break;
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+json_generator_class_init (JsonGeneratorClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (JsonGeneratorPrivate));
+
+  /**
+   * JsonGenerator:pretty:
+   *
+   * Whether the output should be "pretty-printed", with indentation and
+   * newlines. The indentation level can be controlled by using the
+   * JsonGenerator:indent property
+   */
+  generator_props[PROP_PRETTY] =
+    g_param_spec_boolean ("pretty",
+                          "Pretty",
+                          "Pretty-print the output",
+                          FALSE,
+                          G_PARAM_READWRITE);
+
+  /**
+   * JsonGenerator:indent:
+   *
+   * Number of spaces to be used to indent when pretty printing.
+   */
+  generator_props[PROP_INDENT] =
+    g_param_spec_uint ("indent",
+                       "Indent",
+                       "Number of indentation spaces",
+                       0, G_MAXUINT,
+                       2,
+                       G_PARAM_READWRITE);
+
+  /**
+   * JsonGenerator:root:
+   *
+   * The root #JsonNode to be used when constructing a JSON data
+   * stream.
+   *
+   * Since: 0.4
+   */
+  generator_props[PROP_ROOT] =
+    g_param_spec_boxed ("root",
+                        "Root",
+                        "Root of the JSON data tree",
+                        JSON_TYPE_NODE,
+                        G_PARAM_READWRITE);
+
+  /**
+   * JsonGenerator:indent-char:
+   *
+   * The character that should be used when indenting in pretty print.
+   *
+   * Since: 0.6
+   */
+  generator_props[PROP_INDENT_CHAR] =
+    g_param_spec_unichar ("indent-char",
+                          "Indent Char",
+                          "Character that should be used when indenting",
+                          ' ',
+                          G_PARAM_READWRITE);
+
+  gobject_class->set_property = json_generator_set_property;
+  gobject_class->get_property = json_generator_get_property;
+  gobject_class->finalize = json_generator_finalize;
+  g_object_class_install_properties (gobject_class, PROP_LAST, generator_props);
+}
+
+static void
+json_generator_init (JsonGenerator *generator)
+{
+  JsonGeneratorPrivate *priv;
+
+  generator->priv = priv = JSON_GENERATOR_GET_PRIVATE (generator);
+
+  priv->pretty = FALSE;
+  priv->indent = 2;
+  priv->indent_char = ' ';
+}
+
+static gchar *
+dump_value (JsonGenerator *generator,
+            gint           level,
+            const gchar   *name,
+            JsonNode      *node,
+            gsize         *length)
+{
+  JsonGeneratorPrivate *priv = generator->priv;
+  gboolean pretty = priv->pretty;
+  guint indent = priv->indent;
+  GValue value = { 0, };
+  GString *buffer;
+
+  buffer = g_string_new ("");
+
+  if (pretty)
+    {
+      guint i;
+
+      for (i = 0; i < (level * indent); i++)
+        g_string_append_c (buffer, priv->indent_char);
+    }
+
+  if (name && name[0] != '\0')
+    {
+      if (pretty)
+        g_string_append_printf (buffer, "\"%s\" : ", name);
+      else
+        g_string_append_printf (buffer, "\"%s\":", name);
+    }
+
+  json_node_get_value (node, &value);
+
+  switch (G_VALUE_TYPE (&value))
+    {
+    case G_TYPE_INT64:
+      g_string_append_printf (buffer, "%" G_GINT64_FORMAT, g_value_get_int64 (&value));
+      break;
+
+    case G_TYPE_STRING:
+      {
+        gchar *tmp;
+
+        tmp = json_strescape (g_value_get_string (&value));
+        g_string_append_printf (buffer, "\"%s\"", tmp);
+
+        g_free (tmp);
+      }
+      break;
+
+    case G_TYPE_DOUBLE:
+      {
+        gchar buf[G_ASCII_DTOSTR_BUF_SIZE];
+
+        g_string_append (buffer,
+                         g_ascii_dtostr (buf, sizeof (buf),
+                                         g_value_get_double (&value)));
+      }
+      break;
+
+    case G_TYPE_BOOLEAN:
+      g_string_append_printf (buffer, "%s",
+                              g_value_get_boolean (&value) ? "true" : "false");
+      break;
+
+    default:
+      break;
+    }
+
+  g_value_unset (&value);
+
+  if (length)
+    *length = buffer->len;
+
+  return g_string_free (buffer, FALSE);
+}
+
+static gchar *
+dump_array (JsonGenerator *generator,
+            gint           level,
+            const gchar   *name,
+            JsonArray     *array,
+            gsize         *length)
+{
+  JsonGeneratorPrivate *priv = generator->priv;
+  guint array_len = json_array_get_length (array);
+  guint i;
+  GString *buffer;
+  gboolean pretty = priv->pretty;
+  guint indent = priv->indent;
+
+  buffer = g_string_new ("");
+
+  if (pretty)
+    {
+      for (i = 0; i < (level * indent); i++)
+        g_string_append_c (buffer, priv->indent_char);
+    }
+
+  if (name && name[0] != '\0')
+    {
+      if (pretty)
+        g_string_append_printf (buffer, "\"%s\" : ", name);
+      else
+        g_string_append_printf (buffer, "\"%s\":", name);
+    }
+
+  g_string_append_c (buffer, '[');
+
+  if (pretty)
+    g_string_append_c (buffer, '\n');
+
+  for (i = 0; i < array_len; i++)
+    {
+      JsonNode *cur = json_array_get_element (array, i);
+      guint sub_level = level + 1;
+      guint j;
+      gchar *value; 
+
+      switch (JSON_NODE_TYPE (cur))
+        {
+        case JSON_NODE_NULL:
+          if (pretty)
+            {
+              for (j = 0; j < (sub_level * indent); j++)
+                g_string_append_c (buffer, priv->indent_char);
+            }
+          g_string_append (buffer, "null");
+          break;
+
+        case JSON_NODE_VALUE:
+          value = dump_value (generator, sub_level, NULL, cur, NULL);
+          g_string_append (buffer, value);
+          g_free (value);
+          break;
+
+        case JSON_NODE_ARRAY:
+          value = dump_array (generator, sub_level, NULL, json_node_get_array (cur), NULL);
+          g_string_append (buffer, value);
+          g_free (value);
+          break;
+
+        case JSON_NODE_OBJECT:
+          value = dump_object (generator, sub_level, NULL, json_node_get_object (cur), NULL);
+          g_string_append (buffer, value);
+          g_free (value);
+          break;
+        }
+
+      if ((i + 1) != array_len)
+        g_string_append_c (buffer, ',');
+
+      if (pretty)
+        g_string_append_c (buffer, '\n');
+    }
+
+  if (pretty)
+    {
+      for (i = 0; i < (level * indent); i++)
+        g_string_append_c (buffer, priv->indent_char);
+    }
+
+  g_string_append_c (buffer, ']');
+
+  if (length)
+    *length = buffer->len;
+
+  return g_string_free (buffer, FALSE);
+}
+
+static gchar *
+dump_object (JsonGenerator *generator,
+             gint           level,
+             const gchar   *name,
+             JsonObject    *object,
+             gsize         *length)
+{
+  JsonGeneratorPrivate *priv = generator->priv;
+  GList *members, *l;
+  GString *buffer;
+  gboolean pretty = priv->pretty;
+  guint indent = priv->indent;
+  guint i;
+
+  buffer = g_string_new ("");
+
+  if (pretty)
+    {
+      for (i = 0; i < (level * indent); i++)
+        g_string_append_c (buffer, priv->indent_char);
+    }
+
+  if (name && name[0] != '\0')
+    {
+      if (pretty)
+        g_string_append_printf (buffer, "\"%s\" : ", name);
+      else
+        g_string_append_printf (buffer, "\"%s\":", name);
+    }
+
+  g_string_append_c (buffer, '{');
+
+  if (pretty)
+    g_string_append_c (buffer, '\n');
+
+  members = json_object_get_members (object);
+
+  for (l = members; l != NULL; l = l->next)
+    {
+      const gchar *member_name = l->data;
+      JsonNode *cur = json_object_get_member (object, member_name);
+      guint sub_level = level + 1;
+      guint j;
+      gchar *value;
+
+      switch (JSON_NODE_TYPE (cur))
+        {
+        case JSON_NODE_NULL:
+          if (pretty)
+            {
+              for (j = 0; j < (sub_level * indent); j++)
+                g_string_append_c (buffer, priv->indent_char);
+              g_string_append_printf (buffer, "\"%s\" : null", member_name);
+            }
+          else
+            {
+              g_string_append_printf (buffer, "\"%s\":null", member_name);
+            }
+          break;
+
+        case JSON_NODE_VALUE:
+          value = dump_value (generator, sub_level, member_name, cur, NULL);
+          g_string_append (buffer, value);
+          g_free (value);
+          break;
+
+        case JSON_NODE_ARRAY:
+          value = dump_array (generator, sub_level, member_name,
+                              json_node_get_array (cur), NULL);
+          g_string_append (buffer, value);
+          g_free (value);
+          break;
+
+        case JSON_NODE_OBJECT:
+          value = dump_object (generator, sub_level, member_name,
+                               json_node_get_object (cur), NULL);
+          g_string_append (buffer, value);
+          g_free (value);
+          break;
+        }
+
+      if (l->next != NULL)
+        g_string_append_c (buffer, ',');
+
+      if (pretty)
+        g_string_append_c (buffer, '\n');
+    }
+
+  g_list_free (members);
+
+  if (pretty)
+    {
+      for (i = 0; i < (level * indent); i++)
+        g_string_append_c (buffer, priv->indent_char);
+    }
+
+  g_string_append_c (buffer, '}');
+
+  if (length)
+    *length = buffer->len;
+
+  return g_string_free (buffer, FALSE);
+}
+
+/**
+ * json_generator_new:
+ * 
+ * Creates a new #JsonGenerator. You can use this object to generate a
+ * JSON data stream starting from a data object model composed by
+ * #JsonNode<!-- -->s.
+ *
+ * Return value: the newly created #JsonGenerator instance
+ */
+JsonGenerator *
+json_generator_new (void)
+{
+  return g_object_new (JSON_TYPE_GENERATOR, NULL);
+}
+
+/**
+ * json_generator_to_data:
+ * @generator: a #JsonGenerator
+ * @length: (out): return location for the length of the returned
+ *   buffer, or %NULL
+ *
+ * Generates a JSON data stream from @generator and returns it as a
+ * buffer.
+ *
+ * Return value: a newly allocated buffer holding a JSON data stream.
+ *   Use g_free() to free the allocated resources.
+ */
+gchar *
+json_generator_to_data (JsonGenerator *generator,
+                        gsize         *length)
+{
+  JsonNode *root;
+  gchar *retval = NULL;
+
+  g_return_val_if_fail (JSON_IS_GENERATOR (generator), NULL);
+
+  root = generator->priv->root;
+  if (!root)
+    {
+      if (length)
+        *length = 0;
+
+      return NULL;
+    }
+
+  switch (JSON_NODE_TYPE (root))
+    {
+    case JSON_NODE_ARRAY:
+      retval = dump_array (generator, 0, NULL, json_node_get_array (root), length);
+      break;
+
+    case JSON_NODE_OBJECT:
+      retval = dump_object (generator, 0, NULL, json_node_get_object (root), length);
+      break;
+
+    case JSON_NODE_NULL:
+      retval = g_strdup ("null");
+      if (length)
+        *length = 4;
+      break;
+
+    case JSON_NODE_VALUE:
+      retval = dump_value (generator, 0, NULL, root, length);
+      break;
+    }
+
+  return retval;
+}
+
+/**
+ * json_generator_to_file:
+ * @generator: a #JsonGenerator
+ * @filename: path to the target file
+ * @error: return location for a #GError, or %NULL
+ *
+ * Creates a JSON data stream and puts it inside @filename, overwriting the
+ * current file contents. This operation is atomic.
+ *
+ * Return value: %TRUE if saving was successful.
+ */
+gboolean
+json_generator_to_file (JsonGenerator  *generator,
+                        const gchar    *filename,
+                        GError        **error)
+{
+  gchar *buffer;
+  gsize len;
+  gboolean retval;
+
+  g_return_val_if_fail (JSON_IS_GENERATOR (generator), FALSE);
+  g_return_val_if_fail (filename != NULL, FALSE);
+
+  buffer = json_generator_to_data (generator, &len);
+  retval = g_file_set_contents (filename, buffer, len, error);
+  g_free (buffer);
+
+  return retval;
+}
+
+/**
+ * json_generator_to_stream:
+ * @generator: a #JsonGenerator
+ * @stream: a #GOutputStream
+ * @cancellable: (allow-none): a #GCancellable, or %NULL
+ * @error: return location for a #GError, or %NULL
+ *
+ * Outputs JSON data and streams it (synchronously) to @stream.
+ *
+ * Return value: %TRUE if the write operation was successful, and %FALSE
+ *   on failure. In case of error, the #GError will be filled accordingly
+ *
+ * Since: 0.12
+ */
+gboolean
+json_generator_to_stream (JsonGenerator  *generator,
+                          GOutputStream  *stream,
+                          GCancellable   *cancellable,
+                          GError        **error)
+{
+  gboolean retval;
+  gchar *buffer;
+  gsize len;
+
+  g_return_val_if_fail (JSON_IS_GENERATOR (generator), FALSE);
+  g_return_val_if_fail (G_IS_OUTPUT_STREAM (stream), FALSE);
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return FALSE;
+
+  buffer = json_generator_to_data (generator, &len);
+  retval = g_output_stream_write (stream, buffer, len, cancellable, error);
+  g_free (buffer);
+
+  return retval;
+}
+
+/**
+ * json_generator_set_root:
+ * @generator: a #JsonGenerator
+ * @node: a #JsonNode
+ *
+ * Sets @node as the root of the JSON data stream to be serialized by
+ * the #JsonGenerator.
+ *
+ * <note>The node is copied by the generator object, so it can be safely
+ * freed after calling this function.</note>
+ */
+void
+json_generator_set_root (JsonGenerator *generator,
+                         JsonNode      *node)
+{
+  g_return_if_fail (JSON_IS_GENERATOR (generator));
+
+  if (generator->priv->root != NULL)
+    {
+      json_node_free (generator->priv->root);
+      generator->priv->root = NULL;
+    }
+
+  if (node != NULL)
+    generator->priv->root = json_node_copy (node);
+
+  g_object_notify_by_pspec (G_OBJECT (generator), generator_props[PROP_ROOT]);
+}
+
+/**
+ * json_generator_get_root:
+ * @generator: a #JsonGenerator
+ *
+ * Retrieves a pointer to the root #JsonNode set using
+ * json_generator_set_root().
+ *
+ * Return value: (transfer none): a #JsonNode, or %NULL. The returned node
+ *   is owned by the #JsonGenerator and it should not be freed
+ *
+ * Since: 0.14
+ */
+JsonNode *
+json_generator_get_root (JsonGenerator *generator)
+{
+  g_return_val_if_fail (JSON_IS_GENERATOR (generator), NULL);
+
+  return generator->priv->root;
+}
+
+/**
+ * json_generator_set_pretty:
+ * @generator: a #JsonGenerator
+ * @is_pretty: whether the generated string should be pretty printed
+ *
+ * Sets whether the generated JSON should be pretty printed, using the
+ * indentation character specified in the #JsonGenerator:indent-char
+ * property and the spacing specified in #JsonGenerator:indent property.
+ *
+ * Since: 0.14
+ */
+void
+json_generator_set_pretty (JsonGenerator *generator,
+                           gboolean       is_pretty)
+{
+  JsonGeneratorPrivate *priv;
+
+  g_return_if_fail (JSON_IS_GENERATOR (generator));
+
+  priv = generator->priv;
+
+  is_pretty = !!is_pretty;
+
+  if (priv->pretty != is_pretty)
+    {
+      priv->pretty = is_pretty;
+
+      g_object_notify_by_pspec (G_OBJECT (generator), generator_props[PROP_PRETTY]);
+    }
+}
+
+/**
+ * json_generator_get_pretty:
+ * @generator: a #JsonGenerator
+ *
+ * Retrieves the value set using json_generator_set_pretty().
+ *
+ * Return value: %TRUE if the generated JSON should be pretty-printed, and
+ *   %FALSE otherwise
+ *
+ * Since: 0.14
+ */
+gboolean
+json_generator_get_pretty (JsonGenerator *generator)
+{
+  g_return_val_if_fail (JSON_IS_GENERATOR (generator), FALSE);
+
+  return generator->priv->pretty;
+}
+
+/**
+ * json_generator_set_indent:
+ * @generator: a #JsonGenerator
+ * @indent_level: the number of repetitions of the indentation character
+ *   that should be applied when pretty printing
+ *
+ * Sets the number of repetitions for each indentation level.
+ *
+ * Since: 0.14
+ */
+void
+json_generator_set_indent (JsonGenerator *generator,
+                           guint          indent_level)
+{
+  JsonGeneratorPrivate *priv;
+
+  g_return_if_fail (JSON_IS_GENERATOR (generator));
+
+  priv = generator->priv;
+
+  if (priv->indent != indent_level)
+    {
+      priv->indent = indent_level;
+
+      g_object_notify_by_pspec (G_OBJECT (generator), generator_props[PROP_INDENT]);
+    }
+}
+
+/**
+ * json_generator_get_indent:
+ * @generator: a #JsonGenerator
+ *
+ * Retrieves the value set using json_generator_set_indent().
+ *
+ * Return value: the number of repetitions per indentation level
+ *
+ * Since: 0.14
+ */
+guint
+json_generator_get_indent (JsonGenerator *generator)
+{
+  g_return_val_if_fail (JSON_IS_GENERATOR (generator), FALSE);
+
+  return generator->priv->indent;
+}
+
+/**
+ * json_generator_set_indent_char:
+ * @generator: a #JsonGenerator
+ * @indent_char: a Unicode character to be used when indenting
+ *
+ * Sets the character to be used when indenting
+ *
+ * Since: 0.14
+ */
+void
+json_generator_set_indent_char (JsonGenerator *generator,
+                                gunichar       indent_char)
+{
+  JsonGeneratorPrivate *priv;
+
+  g_return_if_fail (JSON_IS_GENERATOR (generator));
+
+  priv = generator->priv;
+
+  if (priv->indent_char != indent_char)
+    {
+      priv->indent_char = indent_char;
+
+      g_object_notify_by_pspec (G_OBJECT (generator), generator_props[PROP_INDENT_CHAR]);
+    }
+}
+
+/**
+ * json_generator_get_indent_char:
+ * @generator: a #JsonGenerator
+ *
+ * Retrieves the value set using json_generator_set_indent_char().
+ *
+ * Return value: the character to be used when indenting
+ *
+ * Since: 0.14
+ */
+gunichar
+json_generator_get_indent_char (JsonGenerator *generator)
+{
+  g_return_val_if_fail (JSON_IS_GENERATOR (generator), FALSE);
+
+  return generator->priv->indent_char;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-generator.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-generator.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-generator.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-generator.h	2011-03-27 09:15:30.772553000 -0600
@@ -0,0 +1,107 @@
+/* json-generator.h - JSON streams generator
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_GENERATOR_H__
+#define __JSON_GENERATOR_H__
+
+#include <json-glib/json-types.h>
+#include <gio/gio.h>
+
+G_BEGIN_DECLS
+
+#define JSON_TYPE_GENERATOR             (json_generator_get_type ())
+#define JSON_GENERATOR(obj)             (G_TYPE_CHECK_INSTANCE_CAST ((obj), JSON_TYPE_GENERATOR, JsonGenerator))
+#define JSON_IS_GENERATOR(obj)          (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JSON_TYPE_GENERATOR))
+#define JSON_GENERATOR_CLASS(klass)     (G_TYPE_CHECK_CLASS_CAST ((klass), JSON_TYPE_GENERATOR, JsonGeneratorClass))
+#define JSON_IS_GENERATOR_CLASS(klass)  (G_TYPE_CHECK_CLASS_TYPE ((klass), JSON_TYPE_GENERATOR))
+#define JSON_GENERATOR_GET_CLASS(obj)   (G_TYPE_INSTANCE_GET_CLASS ((obj), JSON_TYPE_GENERATOR, JsonGeneratorClass))
+
+typedef struct _JsonGenerator           JsonGenerator;
+typedef struct _JsonGeneratorPrivate    JsonGeneratorPrivate;
+typedef struct _JsonGeneratorClass      JsonGeneratorClass;
+
+/**
+ * JsonGenerator:
+ *
+ * JSON data streams generator. The contents of the #JsonGenerator structure
+ * are private and should only be accessed via the provided API.
+ */
+struct _JsonGenerator
+{
+  /*< private >*/
+  GObject parent_instance;
+
+  JsonGeneratorPrivate *priv;
+};
+
+/**
+ * JsonGeneratorClass:
+ *
+ * #JsonGenerator class
+ */
+struct _JsonGeneratorClass
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  /* padding, for future expansion */
+  void (* _json_reserved1) (void);
+  void (* _json_reserved2) (void);
+  void (* _json_reserved3) (void);
+  void (* _json_reserved4) (void);
+};
+
+GType json_generator_get_type (void) G_GNUC_CONST;
+
+JsonGenerator * json_generator_new              (void);
+
+void            json_generator_set_pretty       (JsonGenerator  *generator,
+                                                 gboolean        is_pretty);
+gboolean        json_generator_get_pretty       (JsonGenerator  *generator);
+void            json_generator_set_indent       (JsonGenerator  *generator,
+                                                 guint           indent_level);
+guint           json_generator_get_indent       (JsonGenerator  *generator);
+void            json_generator_set_indent_char  (JsonGenerator  *generator,
+                                                 gunichar        indent_char);
+gunichar        json_generator_get_indent_char  (JsonGenerator  *generator);
+void            json_generator_set_root         (JsonGenerator  *generator,
+                                                 JsonNode       *node);
+JsonNode *      json_generator_get_root         (JsonGenerator  *generator);
+
+gchar *         json_generator_to_data          (JsonGenerator  *generator,
+                                                 gsize          *length);
+gboolean        json_generator_to_file          (JsonGenerator  *generator,
+                                                 const gchar    *filename,
+                                                 GError        **error);
+gboolean        json_generator_to_stream        (JsonGenerator  *generator,
+                                                 GOutputStream  *stream,
+                                                 GCancellable   *cancellable,
+                                                 GError        **error);
+
+G_END_DECLS
+
+#endif /* __JSON_GENERATOR_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-glib.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-glib.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-glib.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-glib.h	2011-03-27 09:15:30.768552999 -0600
@@ -0,0 +1,45 @@
+/* json-glib.h: Main header
+ *
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#ifndef __JSON_GLIB_H__
+#define __JSON_GLIB_H__
+
+#define __JSON_GLIB_INSIDE__
+
+#include <json-glib/json-types.h>
+
+#include <json-glib/json-builder.h>
+#include <json-glib/json-generator.h>
+#include <json-glib/json-parser.h>
+#include <json-glib/json-reader.h>
+#include <json-glib/json-version.h>
+
+#include <json-glib/json-enum-types.h>
+
+#include <json-glib/json-gobject.h>
+
+#include <json-glib/json-gvariant.h>
+
+#undef __JSON_GLIB_INSIDE__
+
+#endif /* __JSON_GLIB_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-glib.symbols pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-glib.symbols
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-glib.symbols	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-glib.symbols	2011-03-27 09:15:30.772553000 -0600
@@ -0,0 +1,165 @@
+
+json_array_add_array_element
+json_array_add_boolean_element
+json_array_add_double_element
+json_array_add_element
+json_array_add_int_element
+json_array_add_null_element
+json_array_add_object_element
+json_array_add_string_element
+json_array_dup_element
+json_array_foreach_element
+json_array_get_array_element
+json_array_get_boolean_element
+json_array_get_double_element
+json_array_get_element
+json_array_get_elements
+json_array_get_int_element
+json_array_get_length
+json_array_get_null_element
+json_array_get_object_element
+json_array_get_string_element
+json_array_get_type
+json_array_new
+json_array_ref
+json_array_remove_element
+json_array_sized_new
+json_array_unref
+json_boxed_can_deserialize
+json_boxed_can_serialize
+json_boxed_deserialize
+json_boxed_register_deserialize_func
+json_boxed_register_serialize_func
+json_boxed_serialize
+json_builder_add_boolean_value
+json_builder_add_double_value
+json_builder_add_int_value
+json_builder_add_null_value
+json_builder_add_string_value
+json_builder_add_value
+json_builder_begin_array
+json_builder_begin_object
+json_builder_end_array
+json_builder_end_object
+json_builder_get_root
+json_builder_get_type
+json_builder_new
+json_builder_reset
+json_builder_set_member_name
+#ifndef JSON_DISABLE_DEPRECATED
+json_construct_gobject
+#endif
+json_generator_get_type
+json_generator_new
+json_generator_set_root
+json_generator_to_data
+json_generator_to_file
+json_generator_to_stream
+json_gobject_deserialize
+json_gobject_from_data
+json_gobject_serialize
+json_gobject_to_data
+json_node_copy
+json_node_dup_array
+json_node_dup_object
+json_node_dup_string
+json_node_free
+json_node_get_array
+json_node_get_boolean
+json_node_get_double
+json_node_get_int
+json_node_get_node_type
+json_node_get_object
+json_node_get_parent
+json_node_get_string
+json_node_get_type
+json_node_get_value
+json_node_get_value_type
+json_node_is_null
+json_node_new
+json_node_set_array
+json_node_set_boolean
+json_node_set_double
+json_node_set_int
+json_node_set_object
+json_node_set_parent
+json_node_set_string
+json_node_set_value
+json_node_take_array
+json_node_take_object
+json_node_type_get_type
+json_node_type_name
+#ifndef JSON_DISABLE_DEPRECATED
+json_object_add_member
+#endif
+json_object_dup_member
+json_object_foreach_member
+json_object_get_array_member
+json_object_get_boolean_member
+json_object_get_double_member
+json_object_get_int_member
+json_object_get_member
+json_object_get_members
+json_object_get_null_member
+json_object_get_object_member
+json_object_get_size
+json_object_get_string_member
+json_object_get_type
+json_object_get_values
+json_object_has_member
+json_object_new
+json_object_ref
+json_object_remove_member
+json_object_set_array_member
+json_object_set_boolean_member
+json_object_set_double_member
+json_object_set_int_member
+json_object_set_member
+json_object_set_null_member
+json_object_set_object_member
+json_object_set_string_member
+json_object_unref
+json_parser_error_get_type
+json_parser_error_quark
+json_parser_get_current_line
+json_parser_get_current_pos
+json_parser_get_root
+json_parser_get_type
+json_parser_has_assignment
+json_parser_load_from_data
+json_parser_load_from_file
+json_parser_load_from_stream
+json_parser_load_from_stream_async
+json_parser_load_from_stream_finish
+json_parser_new
+json_reader_count_elements
+json_reader_count_members
+json_reader_end_element
+json_reader_end_member
+json_reader_error_get_type
+json_reader_error_quark
+json_reader_get_boolean_value
+json_reader_get_double_value
+json_reader_get_error
+json_reader_get_int_value
+json_reader_get_member_name
+json_reader_get_null_value
+json_reader_get_string_value
+json_reader_get_type
+json_reader_get_value
+json_reader_list_members
+json_reader_is_array
+json_reader_is_object
+json_reader_is_value
+json_reader_new
+json_reader_read_element
+json_reader_read_member
+json_reader_set_root
+json_serializable_default_deserialize_property
+json_serializable_default_serialize_property
+json_serializable_deserialize_property
+json_serializable_get_type
+#ifndef JSON_DISABLE_DEPRECATED
+json_serialize_gobject
+#endif
+json_serializable_serialize_property
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gobject.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gobject.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gobject.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gobject.c	2011-03-27 09:15:30.772553000 -0600
@@ -0,0 +1,918 @@
+/* json-gobject.c - JSON GObject integration
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@openedhand.com>
+ */
+
+/**
+ * SECTION:json-gobject
+ * @short_description: Serialize and deserialize GObjects
+ *
+ * JSON-GLib provides API for serializing and deserializing #GObject<!-- -->s
+ * to and from JSON data streams.
+ *
+ * Simple #GObject classes can be (de)serialized into JSON objects, if the
+ * properties have compatible types with the native JSON types (integers,
+ * booleans, strings, string vectors). If the class to be (de)serialized has
+ * complex data types for properties (like boxed types or other objects)
+ * then the class should implement the provided #JsonSerializable interface
+ * and its virtual functions.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "json-types-private.h"
+#include "json-gobject-private.h"
+
+#include "json-debug.h"
+#include "json-parser.h"
+#include "json-generator.h"
+
+static gboolean
+enum_from_string (GType        type,
+                  const gchar *string,
+                  gint        *enum_value)
+{
+  GEnumClass *eclass;
+  GEnumValue *ev;
+  gchar *endptr;
+  gint value;
+  gboolean retval = TRUE;
+
+  g_return_val_if_fail (G_TYPE_IS_ENUM (type), 0);
+  g_return_val_if_fail (string != NULL, 0);
+
+  value = strtoul (string, &endptr, 0);
+  if (endptr != string) /* parsed a number */
+    *enum_value = value;
+  else
+    {
+      eclass = g_type_class_ref (type);
+      ev = g_enum_get_value_by_name (eclass, string);
+      if (!ev)
+	ev = g_enum_get_value_by_nick (eclass, string);
+
+      if (ev)
+	*enum_value = ev->value;
+      else
+        retval = FALSE;
+
+      g_type_class_unref (eclass);
+    }
+
+  return retval;
+}
+
+static gboolean
+flags_from_string (GType        type,
+                   const gchar *string,
+                   gint        *flags_value)
+{
+  GFlagsClass *fclass;
+  gchar *endptr, *prevptr;
+  guint i, j, ret, value;
+  gchar *flagstr;
+  GFlagsValue *fv;
+  const gchar *flag;
+  gunichar ch;
+  gboolean eos;
+
+  g_return_val_if_fail (G_TYPE_IS_FLAGS (type), 0);
+  g_return_val_if_fail (string != 0, 0);
+
+  ret = TRUE;
+
+  value = strtoul (string, &endptr, 0);
+  if (endptr != string) /* parsed a number */
+    *flags_value = value;
+  else
+    {
+      fclass = g_type_class_ref (type);
+
+      flagstr = g_strdup (string);
+      for (value = i = j = 0; ; i++)
+	{
+	  eos = flagstr[i] == '\0';
+
+	  if (!eos && flagstr[i] != '|')
+	    continue;
+
+	  flag = &flagstr[j];
+	  endptr = &flagstr[i];
+
+	  if (!eos)
+	    {
+	      flagstr[i++] = '\0';
+	      j = i;
+	    }
+
+	  /* trim spaces */
+	  for (;;)
+	    {
+	      ch = g_utf8_get_char (flag);
+	      if (!g_unichar_isspace (ch))
+		break;
+	      flag = g_utf8_next_char (flag);
+	    }
+
+	  while (endptr > flag)
+	    {
+	      prevptr = g_utf8_prev_char (endptr);
+	      ch = g_utf8_get_char (prevptr);
+	      if (!g_unichar_isspace (ch))
+		break;
+	      endptr = prevptr;
+	    }
+
+	  if (endptr > flag)
+	    {
+	      *endptr = '\0';
+	      fv = g_flags_get_value_by_name (fclass, flag);
+
+	      if (!fv)
+		fv = g_flags_get_value_by_nick (fclass, flag);
+
+	      if (fv)
+		value |= fv->value;
+	      else
+		{
+		  ret = FALSE;
+		  break;
+		}
+	    }
+
+	  if (eos)
+	    {
+	      *flags_value = value;
+	      break;
+	    }
+	}
+
+      g_free (flagstr);
+
+      g_type_class_unref (fclass);
+    }
+
+  return ret;
+}
+
+static GObject *
+json_gobject_new (GType       gtype,
+                  JsonObject *object)
+{
+  JsonSerializableIface *iface = NULL;
+  JsonSerializable *serializable = NULL;
+  gboolean deserialize_property;
+  GList *members, *members_left, *l;
+  guint n_members;
+  GObjectClass *klass;
+  GObject *retval;
+  GArray *construct_params;
+  gint i;
+
+  klass = g_type_class_ref (gtype);
+
+  n_members = json_object_get_size (object);
+  members = json_object_get_members (object);
+  members_left = NULL;
+
+  /* first pass: construct and construct-only properties; here
+   * we cannot use Serializable because we don't have an
+   * instance yet; we use the default implementation of
+   * json_deserialize_pspec() to deserialize known types
+   *
+   * FIXME - find a way to allow deserialization for these
+   * properties
+   */
+  construct_params = g_array_sized_new (FALSE, FALSE, sizeof (GParameter), n_members);
+
+  for (l = members; l != NULL; l = l->next)
+    {
+      const gchar *member_name = l->data;
+      GParamSpec *pspec;
+      GParameter param = { NULL, };
+      JsonNode *val;
+      gboolean res = FALSE;
+
+      pspec = g_object_class_find_property (klass, member_name);
+      if (!pspec)
+        goto next_member;
+
+      /* we only apply construct-only properties here */
+      if ((pspec->flags & G_PARAM_CONSTRUCT_ONLY) == 0)
+        goto next_member;
+
+      if (!(pspec->flags & G_PARAM_WRITABLE))
+        goto next_member;
+
+      g_value_init (&param.value, G_PARAM_SPEC_VALUE_TYPE (pspec));
+
+      val = json_object_get_member (object, member_name);
+      res = json_deserialize_pspec (&param.value, pspec, val);
+      if (!res)
+        g_value_unset (&param.value);
+      else
+        {
+          param.name = g_strdup (pspec->name);
+
+          g_array_append_val (construct_params, param);
+
+          continue;
+        }
+
+    next_member:
+      members_left = g_list_prepend (members_left, l->data);
+    }
+
+  retval = g_object_newv (gtype,
+                          construct_params->len,
+                          (GParameter *) construct_params->data);
+
+  /* free the contents of the GArray */
+  for (i = 0; i < construct_params->len; i++)
+    {
+      GParameter *param = &g_array_index (construct_params, GParameter, i);
+
+      g_free ((gchar *) param->name);
+      g_value_unset (&param->value);
+    }
+
+  g_array_free (construct_params, TRUE);
+  g_list_free (members);
+
+  /* we use g_list_prepend() above, but we want to maintain
+   * the ordering of json_object_get_members() here
+   */
+  members = g_list_reverse (members_left);
+
+  /* do the Serializable type check once */
+  if (g_type_is_a (gtype, JSON_TYPE_SERIALIZABLE))
+    {
+      serializable = JSON_SERIALIZABLE (retval);
+      iface = JSON_SERIALIZABLE_GET_IFACE (serializable);
+      deserialize_property = (iface->deserialize_property != NULL);
+    }
+  else
+    deserialize_property = FALSE;
+
+  g_object_freeze_notify (retval);
+
+  for (l = members; l != NULL; l = l->next)
+    {
+      const gchar *member_name = l->data;
+      GParamSpec *pspec;
+      JsonNode *val;
+      GValue value = { 0, };
+      gboolean res = FALSE;
+
+      pspec = g_object_class_find_property (klass, member_name);
+      if (!pspec)
+        continue;
+
+      /* we should have dealt with these above */
+      if ((pspec->flags & G_PARAM_CONSTRUCT_ONLY) ||
+          (pspec->flags & G_PARAM_CONSTRUCT))
+        continue;
+
+      if (!(pspec->flags & G_PARAM_WRITABLE))
+        continue;
+
+      g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (pspec));
+
+      val = json_object_get_member (object, member_name);
+
+      if (deserialize_property)
+        {
+          JSON_NOTE (GOBJECT, "Using JsonSerializable for property '%s'", pspec->name);
+          res = iface->deserialize_property (serializable, pspec->name,
+                                             &value,
+                                             pspec,
+                                             val);
+        }
+
+      if (!res)
+        {
+          JSON_NOTE (GOBJECT, "Using json_deserialize_pspec for property '%s'", pspec->name);
+          res = json_deserialize_pspec (&value, pspec, val);
+        }
+
+      /* FIXME - we probably want to be able to have a custom
+       * set_property() for Serializable implementations
+       */
+      if (res)
+        {
+          JSON_NOTE (GOBJECT, "Calling set_property('%s', '%s')",
+                     pspec->name,
+                     g_type_name (G_VALUE_TYPE (&value)));
+          g_object_set_property (retval, pspec->name, &value);
+        }
+
+      g_value_unset (&value);
+    }
+
+  g_list_free (members);
+
+  g_object_thaw_notify (retval);
+
+  g_type_class_unref (klass);
+
+  return retval;
+}
+
+static JsonObject *
+json_gobject_dump (GObject *gobject)
+{
+  JsonSerializableIface *iface = NULL;
+  JsonSerializable *serializable = NULL;
+  gboolean serialize_property = FALSE;
+  JsonObject *object;
+  GParamSpec **pspecs;
+  guint n_pspecs, i;
+
+  if (JSON_IS_SERIALIZABLE (gobject))
+    {
+      serializable = JSON_SERIALIZABLE (gobject);
+      iface = JSON_SERIALIZABLE_GET_IFACE (gobject);
+      serialize_property = (iface->serialize_property != NULL);
+    }
+
+  object = json_object_new ();
+
+  pspecs = g_object_class_list_properties (G_OBJECT_GET_CLASS (gobject), &n_pspecs);
+  for (i = 0; i < n_pspecs; i++)
+    {
+      GParamSpec *pspec = pspecs[i];
+      GValue value = { 0, };
+      JsonNode *node = NULL;
+
+      /* read only what we can */
+      if (!(pspec->flags & G_PARAM_READABLE))
+        continue;
+
+      g_value_init (&value, G_PARAM_SPEC_VALUE_TYPE (pspec));
+      g_object_get_property (gobject, pspec->name, &value);
+
+      /* if there is a serialization vfunc, then it is completely responsible
+       * for serializing the property, possibly by calling the implementation
+       * of the default JsonSerializable interface through chaining up
+       */
+      if (serialize_property)
+        {
+          node = iface->serialize_property (serializable, pspec->name,
+                                            &value,
+                                            pspec);
+        }
+      else
+        node = json_serialize_pspec (&value, pspec);
+
+      if (node)
+        json_object_set_member (object, pspec->name, node);
+
+      g_value_unset (&value);
+    }
+
+  g_free (pspecs);
+
+  return object;
+}
+
+gboolean
+json_deserialize_pspec (GValue     *value,
+                        GParamSpec *pspec,
+                        JsonNode   *node)
+{
+  GValue node_value = { 0, };
+  gboolean retval = FALSE;
+
+  if (G_TYPE_FUNDAMENTAL (G_VALUE_TYPE (value)) == G_TYPE_BOXED)
+    {
+      JsonNodeType node_type = json_node_get_node_type (node);
+      GType boxed_type = G_VALUE_TYPE (value);
+
+      if (json_boxed_can_deserialize (boxed_type, node_type))
+        {
+          gpointer boxed = json_boxed_deserialize (boxed_type, node);
+
+          g_value_take_boxed (value, boxed);
+
+          return TRUE;
+        }
+    }
+
+  switch (JSON_NODE_TYPE (node))
+    {
+    case JSON_NODE_OBJECT:
+      if (g_type_is_a (G_VALUE_TYPE (value), G_TYPE_OBJECT))
+        {
+          GObject *object;
+
+          object = json_gobject_new (G_VALUE_TYPE (value), json_node_get_object (node));
+          if (object != NULL)
+            g_value_take_object (value, object);
+          else
+            g_value_set_object (value, NULL);
+
+          retval = TRUE;
+        }
+      break;
+
+    case JSON_NODE_ARRAY:
+      if (G_VALUE_HOLDS (value, G_TYPE_STRV))
+        {
+          JsonArray *array = json_node_get_array (node);
+          guint i, array_len = json_array_get_length (array);
+          GPtrArray *str_array = g_ptr_array_sized_new (array_len + 1);
+
+          for (i = 0; i < array_len; i++)
+            {
+              JsonNode *val = json_array_get_element (array, i);
+
+              if (JSON_NODE_TYPE (val) != JSON_NODE_VALUE)
+                continue;
+
+              if (json_node_get_string (val) != NULL)
+                g_ptr_array_add (str_array, (gpointer) json_node_get_string (val));
+            }
+
+          g_ptr_array_add (str_array, NULL);
+
+          g_value_set_boxed (value, str_array->pdata);
+
+          g_ptr_array_free (str_array, TRUE);
+
+          retval = TRUE;
+        }
+      break;
+
+    case JSON_NODE_VALUE:
+      json_node_get_value (node, &node_value);
+#if 0
+      {
+        gchar *node_str = g_strdup_value_contents (&node_value);
+        g_debug ("%s: value type '%s' := node value type '%s' -> '%s'",
+                 G_STRLOC,
+                 g_type_name (G_VALUE_TYPE (value)),
+                 g_type_name (G_VALUE_TYPE (&node_value)),
+                 node_str);
+        g_free (node_str);
+      }
+#endif
+
+      switch (G_TYPE_FUNDAMENTAL (G_VALUE_TYPE (value)))
+        {
+        case G_TYPE_BOOLEAN:
+        case G_TYPE_INT64:
+        case G_TYPE_DOUBLE:
+        case G_TYPE_STRING:
+          g_value_copy (&node_value, value);
+          retval = TRUE;
+          break;
+
+        case G_TYPE_INT:
+          g_value_set_int (value, (gint) g_value_get_int64 (&node_value));
+          retval = TRUE;
+          break;
+
+        case G_TYPE_CHAR:
+          g_value_set_char (value, (gchar) g_value_get_int64 (&node_value));
+          retval = TRUE;
+          break;
+
+        case G_TYPE_UINT:
+          g_value_set_uint (value, (guint) g_value_get_int64 (&node_value));
+          retval = TRUE;
+          break;
+
+        case G_TYPE_UCHAR:
+          g_value_set_uchar (value, (guchar) g_value_get_int64 (&node_value));
+          retval = TRUE;
+          break;
+
+        case G_TYPE_FLOAT:
+          g_value_set_float (value, (gfloat) g_value_get_double (&node_value));
+          retval = TRUE;
+          break;
+
+        case G_TYPE_ENUM:
+          {
+            gint enum_value = 0;
+
+            if (G_VALUE_HOLDS (&node_value, G_TYPE_INT64))
+              {
+                enum_value = g_value_get_int64 (&node_value);
+                retval = TRUE;
+              }
+            else if (G_VALUE_HOLDS (&node_value, G_TYPE_STRING))
+              {
+                retval = enum_from_string (G_VALUE_TYPE (value),
+                                           g_value_get_string (&node_value),
+                                           &enum_value);
+              }
+
+            if (retval)
+              g_value_set_enum (value, enum_value);
+          }
+          break;
+
+        case G_TYPE_FLAGS:
+          {
+            gint flags_value = 0;
+
+            if (G_VALUE_HOLDS (&node_value, G_TYPE_INT64))
+              {
+                flags_value = g_value_get_int64 (&node_value);
+                retval = TRUE;
+              }
+            else if (G_VALUE_HOLDS (&node_value, G_TYPE_STRING))
+              {
+                retval = flags_from_string (G_VALUE_TYPE (value),
+                                            g_value_get_string (&node_value),
+                                            &flags_value);
+              }
+
+            if (retval)
+              g_value_set_flags (value, flags_value);
+          }
+          break;
+
+        default:
+          retval = FALSE;
+          break;
+        }
+
+      g_value_unset (&node_value);
+      break;
+
+    case JSON_NODE_NULL:
+      retval = FALSE;
+      break;
+    }
+
+  return retval;
+}
+
+JsonNode *
+json_serialize_pspec (const GValue *real_value,
+                      GParamSpec   *pspec)
+{
+  JsonNode *retval = NULL;
+  GValue value = { 0, };
+  JsonNodeType node_type;
+
+  switch (G_TYPE_FUNDAMENTAL (G_VALUE_TYPE (real_value)))
+    {
+    case G_TYPE_INT64:
+    case G_TYPE_BOOLEAN:
+    case G_TYPE_DOUBLE:
+      /* JSON native types */
+      retval = json_node_new (JSON_NODE_VALUE);
+      g_value_init (&value, G_VALUE_TYPE (real_value));
+      g_value_copy (real_value, &value);
+      json_node_set_value (retval, &value);
+      g_value_unset (&value);
+      break;
+
+    case G_TYPE_STRING:
+      /* strings might be NULL, so we handle it differently */
+      if (!g_value_get_string (real_value))
+        retval = json_node_new (JSON_NODE_NULL);
+      else
+        {
+          retval = json_node_new (JSON_NODE_VALUE);
+          json_node_set_string (retval, g_value_get_string (real_value));
+          break;
+        }
+      break;
+
+    case G_TYPE_INT:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_int (retval, g_value_get_int (real_value));
+      break;
+
+    case G_TYPE_FLOAT:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_double (retval, g_value_get_float (real_value));
+      break;
+
+    case G_TYPE_BOXED:
+      if (G_VALUE_HOLDS (real_value, G_TYPE_STRV))
+        {
+          gchar **strv = g_value_get_boxed (real_value);
+          gint i, strv_len;
+          JsonArray *array;
+
+          strv_len = g_strv_length (strv);
+          array = json_array_sized_new (strv_len);
+
+          for (i = 0; i < strv_len; i++)
+            {
+              JsonNode *str = json_node_new (JSON_NODE_VALUE);
+
+              json_node_set_string (str, strv[i]);
+              json_array_add_element (array, str);
+            }
+
+          retval = json_node_new (JSON_NODE_ARRAY);
+          json_node_take_array (retval, array);
+        }
+      else if (json_boxed_can_serialize (G_VALUE_TYPE (real_value), &node_type))
+        {
+          gpointer boxed = g_value_get_boxed (real_value);
+
+          retval = json_boxed_serialize (G_VALUE_TYPE (real_value), boxed);
+        }
+      else
+        g_warning ("Boxed type '%s' is not handled by JSON-GLib",
+                   g_type_name (G_VALUE_TYPE (real_value)));
+      break;
+
+    case G_TYPE_UINT:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_int (retval, g_value_get_uint (real_value));
+      break;
+
+    case G_TYPE_LONG:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_int (retval, g_value_get_long (real_value));
+      break;
+
+    case G_TYPE_ULONG:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_int (retval, g_value_get_long (real_value));
+      break;
+
+    case G_TYPE_CHAR:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_int (retval, g_value_get_char (real_value));
+      break;
+
+    case G_TYPE_UCHAR:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_int (retval, g_value_get_uchar (real_value));
+      break;
+
+    case G_TYPE_ENUM:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_int (retval, g_value_get_enum (real_value));
+      break;
+
+    case G_TYPE_FLAGS:
+      retval = json_node_new (JSON_NODE_VALUE);
+      json_node_set_int (retval, g_value_get_flags (real_value));
+      break;
+
+    case G_TYPE_OBJECT:
+      {
+        GObject *object = g_value_get_object (real_value);
+
+        if (object != NULL)
+          {
+            retval = json_node_new (JSON_NODE_OBJECT);
+            json_node_take_object (retval, json_gobject_dump (object));
+          }
+        else
+          retval = json_node_new (JSON_NODE_NULL);
+      }
+      break;
+
+    case G_TYPE_NONE:
+      retval = json_node_new (JSON_NODE_NULL);
+      break;
+
+    default:
+      g_warning ("Unsupported type `%s'", g_type_name (G_VALUE_TYPE (real_value)));
+      break;
+    }
+
+  return retval;
+}
+
+/**
+ * json_gobject_deserialize:
+ * @gtype: the type of the #GObject to create
+ * @node: a #JsonNode of type %JSON_NODE_OBJECT describing the
+ *   instance of type @gtype
+ *
+ * Creates a new #GObject of type @gtype, and constructs it
+ * using the members of the passed #JsonObject
+ *
+ * Return value: (transfer full): The newly created #GObject
+ *   instance. Use g_object_unref() to free the resources
+ *   allocated by this function
+ *
+ * Since: 0.10
+ */
+GObject *
+json_gobject_deserialize (GType     gtype,
+                          JsonNode *node)
+{
+  g_return_val_if_fail (g_type_is_a (gtype, G_TYPE_OBJECT), NULL);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_OBJECT, NULL);
+
+  return json_gobject_new (gtype, json_node_get_object (node));
+}
+
+/**
+ * json_gobject_serialize:
+ * @gobject: a #GObject
+ *
+ * Creates a #JsonNode representing the passed #GObject
+ * instance. Each member of the returned JSON object will
+ * map to a property of the #GObject
+ *
+ * Return value: (transfer full): the newly created #JsonNode
+ *   of type %JSON_NODE_OBJECT. Use json_node_free() to free
+ *   the resources allocated by this function
+ *
+ * Since: 0.10
+ */
+JsonNode *
+json_gobject_serialize (GObject *gobject)
+{
+  JsonNode *retval;
+
+  g_return_val_if_fail (G_IS_OBJECT (gobject), NULL);
+
+  retval = json_node_new (JSON_NODE_OBJECT);
+  json_node_take_object (retval, json_gobject_dump (gobject));
+
+  return retval;
+}
+
+/**
+ * json_construct_gobject:
+ * @gtype: the #GType of object to construct
+ * @data: a JSON data stream
+ * @length: length of the data stream
+ * @error: return location for a #GError, or %NULL
+ *
+ * Deserializes a JSON data stream and creates the corresponding
+ * #GObject class. If @gtype implements the #JsonSerializableIface
+ * interface, it will be asked to deserialize all the JSON members
+ * into the respective properties; otherwise, the default implementation
+ * will be used to translate the compatible JSON native types.
+ *
+ * Note: the JSON data stream must be an object declaration.
+ *
+ * Return value: (transfer full): a #GObject or %NULL
+ *
+ * Since: 0.4
+ *
+ * Deprecated: 0.10: Use json_gobject_from_data() instead
+ */
+GObject *
+json_construct_gobject (GType         gtype,
+                        const gchar  *data,
+                        gsize         length,
+                        GError      **error)
+{
+  return json_gobject_from_data (gtype, data, strlen (data), error);
+}
+
+/**
+ * json_gobject_from_data:
+ * @gtype: the #GType of object to construct
+ * @data: a JSON data stream
+ * @length: length of the data stream, or -1 if it is NUL-terminated
+ * @error: return location for a #GError, or %NULL
+ *
+ * Deserializes a JSON data stream and creates the corresponding
+ * #GObject class. If @gtype implements the #JsonSerializableIface
+ * interface, it will be asked to deserialize all the JSON members
+ * into the respective properties; otherwise, the default implementation
+ * will be used to translate the compatible JSON native types.
+ *
+ * Note: the JSON data stream must be an object declaration.
+ *
+ * Return value: (transfer full): a #GObject or %NULL
+ *
+ * Since: 0.10
+ */
+GObject *
+json_gobject_from_data (GType         gtype,
+                        const gchar  *data,
+                        gssize        length,
+                        GError      **error)
+{
+  JsonParser *parser;
+  JsonNode *root;
+  GError *parse_error;
+  GObject *retval;
+
+  g_return_val_if_fail (gtype != G_TYPE_INVALID, NULL);
+  g_return_val_if_fail (data != NULL, NULL);
+
+  if (length < 0)
+    length = strlen (data);
+
+  parser = json_parser_new ();
+
+  parse_error = NULL;
+  json_parser_load_from_data (parser, data, length, &parse_error);
+  if (parse_error)
+    {
+      g_propagate_error (error, parse_error);
+      g_object_unref (parser);
+      return NULL;
+    }
+
+  root = json_parser_get_root (parser);
+  if (root == NULL || JSON_NODE_TYPE (root) != JSON_NODE_OBJECT)
+    {
+      g_set_error (error, JSON_PARSER_ERROR,
+                   JSON_PARSER_ERROR_PARSE,
+                   "Expecting a JSON object, but the root node "
+                   "is of type `%s'",
+                   json_node_type_name (root));
+      g_object_unref (parser);
+      return NULL;
+    }
+
+  retval = json_gobject_deserialize (gtype, root);
+
+  g_object_unref (parser);
+
+  return retval;
+}
+
+/**
+ * json_serialize_gobject:
+ * @gobject: a #GObject
+ * @length: (out): return value for the length of the buffer, or %NULL
+ *
+ * Serializes a #GObject into a JSON data stream. If @gobject implements
+ * the #JsonSerializableIface interface, it will be asked to serizalize all
+ * its properties; otherwise, the default implementation will be use to
+ * translate the compatible types into JSON native types.
+ *
+ * Return value: a JSON data stream representing the passed #GObject
+ *
+ * Deprecated: 0.10: Use json_gobject_to_data() instead
+ */
+gchar *
+json_serialize_gobject (GObject *gobject,
+                        gsize   *length)
+{
+  return json_gobject_to_data (gobject, length);
+}
+
+/**
+ * json_gobject_to_data:
+ * @gobject: a #GObject
+ * @length: (out): return value for the length of the buffer, or %NULL
+ *
+ * Serializes a #GObject into a JSON data stream, iterating recursively
+ * over each property.
+ *
+ * If @gobject implements the #JsonSerializableIface interface, it will
+ * be asked to serialize all its properties; otherwise, the default
+ * implementation will be use to translate the compatible types into
+ * JSON native types.
+ *
+ * Return value: a JSON data stream representing the passed #GObject
+ *
+ * Since: 0.10
+ */
+gchar *
+json_gobject_to_data (GObject *gobject,
+                      gsize   *length)
+{
+  JsonGenerator *gen;
+  JsonNode *root;
+  gchar *data;
+
+  g_return_val_if_fail (G_OBJECT (gobject), NULL);
+
+  root = json_gobject_serialize (gobject);
+
+  gen = g_object_new (JSON_TYPE_GENERATOR,
+                      "root", root,
+                      "pretty", TRUE,
+                      "indent", 2,
+                      NULL);
+
+  data = json_generator_to_data (gen, length);
+  g_object_unref (gen);
+
+  json_node_free (root);
+
+  return data;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gobject.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gobject.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gobject.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gobject.h	2011-03-27 09:15:30.820553000 -0600
@@ -0,0 +1,154 @@
+/* json-gobject.h - JSON GObject integration
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#ifndef __JSON_GOBJECT_H__
+#define __JSON_GOBJECT_H__
+
+#include <json-glib/json-types.h>
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+#define JSON_TYPE_SERIALIZABLE                  (json_serializable_get_type ())
+#define JSON_SERIALIZABLE(obj)                  (G_TYPE_CHECK_INSTANCE_CAST ((obj), JSON_TYPE_SERIALIZABLE, JsonSerializable))
+#define JSON_IS_SERIALIZABLE(obj)               (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JSON_TYPE_SERIALIZABLE))
+#define JSON_SERIALIZABLE_GET_IFACE(obj)        (G_TYPE_INSTANCE_GET_INTERFACE ((obj), JSON_TYPE_SERIALIZABLE, JsonSerializableIface))
+
+typedef struct _JsonSerializable        JsonSerializable; /* dummy */
+typedef struct _JsonSerializableIface   JsonSerializableIface;
+
+/**
+ * JsonSerializableIface:
+ * @serialize_property: virtual function for serializing a #GObject property
+ *   into a #JsonNode
+ * @deserialize_property: virtual function for deserializing a #JsonNode
+ *   into a #GObject property
+ *
+ * Interface that allows serializing and deserializing #GObject<!-- -->s
+ * with properties storing complex data types. The json_serialize_gobject()
+ * function will check if the passed #GObject implements this interface,
+ * so it can also be used to override the default property serialization
+ * sequence.
+ */
+struct _JsonSerializableIface
+{
+  /*< private >*/
+  GTypeInterface g_iface;
+
+  /*< public >*/
+  JsonNode *(* serialize_property)   (JsonSerializable *serializable,
+                                      const gchar      *property_name,
+                                      const GValue     *value,
+                                      GParamSpec       *pspec);
+  gboolean  (* deserialize_property) (JsonSerializable *serializable,
+                                      const gchar      *property_name,
+                                      GValue           *value,
+                                      GParamSpec       *pspec,
+                                      JsonNode         *property_node);
+};
+
+GType     json_serializable_get_type (void) G_GNUC_CONST;
+
+JsonNode *json_serializable_serialize_property           (JsonSerializable *serializable,
+                                                          const gchar      *property_name,
+                                                          const GValue     *value,
+                                                          GParamSpec       *pspec);
+gboolean  json_serializable_deserialize_property         (JsonSerializable *serializable,
+                                                          const gchar      *property_name,
+                                                          GValue           *value,
+                                                          GParamSpec       *pspec,
+                                                          JsonNode         *property_node);
+
+JsonNode *json_serializable_default_serialize_property   (JsonSerializable *serializable,
+                                                          const gchar      *property_name,
+                                                          const GValue     *value,
+                                                          GParamSpec       *pspec);
+gboolean  json_serializable_default_deserialize_property (JsonSerializable *serializable,
+                                                          const gchar      *property_name,
+                                                          GValue           *value,
+                                                          GParamSpec       *pspec,
+                                                          JsonNode         *property_node);
+
+/**
+ * JsonBoxedSerializeFunc:
+ * @boxed: a #GBoxed
+ *
+ * Serializes the passed #GBoxed and stores it inside a #JsonNode
+ *
+ * Return value: the newly created #JsonNode
+ *
+ * Since: 0.10
+ */
+typedef JsonNode *(* JsonBoxedSerializeFunc) (gconstpointer boxed);
+
+/**
+ * JsonBoxedDeserializeFunc:
+ * @node: a #JsonNode
+ *
+ * Deserializes the contents of the passed #JsonNode into a #GBoxed
+ *
+ * Return value: the newly created boxed type
+ *
+ * Since: 0.10
+ */
+typedef gpointer (* JsonBoxedDeserializeFunc) (JsonNode *node);
+
+void      json_boxed_register_serialize_func   (GType                    gboxed_type,
+                                                JsonNodeType             node_type,
+                                                JsonBoxedSerializeFunc   serialize_func);
+void      json_boxed_register_deserialize_func (GType                    gboxed_type,
+                                                JsonNodeType             node_type,
+                                                JsonBoxedDeserializeFunc deserialize_func);
+gboolean  json_boxed_can_serialize             (GType                    gboxed_type,
+                                                JsonNodeType            *node_type);
+gboolean  json_boxed_can_deserialize           (GType                    gboxed_type,
+                                                JsonNodeType             node_type);
+JsonNode *json_boxed_serialize                 (GType                    gboxed_type,
+                                                gconstpointer            boxed);
+gpointer  json_boxed_deserialize               (GType                    gboxed_type,
+                                                JsonNode                *node);
+
+JsonNode *json_gobject_serialize               (GObject                 *gobject);
+GObject * json_gobject_deserialize             (GType                    gtype,
+                                                JsonNode                *node);
+
+GObject * json_gobject_from_data               (GType                    gtype,
+                                                const gchar             *data,
+                                                gssize                   length,
+                                                GError                 **error);
+gchar *   json_gobject_to_data                 (GObject                 *gobject,
+                                                gsize                   *length);
+
+#ifndef JSON_DISABLE_DEPRECATED
+GObject * json_construct_gobject               (GType                    gtype,
+                                                const gchar             *data,
+                                                gsize                    length,
+                                                GError                 **error) G_GNUC_DEPRECATED;
+gchar *   json_serialize_gobject               (GObject                 *gobject,
+                                                gsize                   *length) G_GNUC_MALLOC G_GNUC_DEPRECATED;
+#endif /* JSON_DISABLE_DEPRECATED */
+
+
+G_END_DECLS
+
+#endif /* __JSON_GOBJECT_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gobject-private.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gobject-private.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gobject-private.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gobject-private.h	2011-03-27 09:15:30.776552999 -0600
@@ -0,0 +1,39 @@
+/* json-gobject-private.h - GObject private
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#ifndef __JSON_GOBJECT_PRIVATE_H__
+#define __JSON_GOBJECT_PRIVATE_H__
+
+#include "json-gobject.h"
+
+G_BEGIN_DECLS
+
+JsonNode *json_serialize_pspec   (const GValue *real_value,
+                                  GParamSpec   *pspec);
+gboolean  json_deserialize_pspec (GValue       *value,
+                                  GParamSpec   *pspec,
+                                  JsonNode     *node);
+
+G_END_DECLS
+
+#endif /* __JSON_GOBJECT_PRIVATE_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gvariant.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gvariant.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gvariant.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gvariant.c	2011-03-27 09:15:30.764553000 -0600
@@ -0,0 +1,1301 @@
+/* json-gvariant.c - JSON GVariant integration
+ *
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * Author:
+ *   Eduardo Lima Mitev  <elima@igalia.com>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <errno.h>
+
+#include "json-gvariant.h"
+
+/**
+ * SECTION:json-gvariant
+ * @short_description: Serialize and deserialize GVariant types
+ * @Title: JSON GVariant Integration
+ *
+ * Use json_gvariant_serialize() and json_gvariant_serialize_data() to
+ * convert from any #GVariant value to a #JsonNode tree or its string
+ * representation.
+ *
+ * Use json_gvariant_deserialize() and json_gvariant_deserialize_data() to
+ * obtain the #GVariant value from a #JsonNode tree or directly from a JSON
+ * string.
+ * Since many #GVariant data types cannot be directly represented as
+ * JSON, a #GVariant type string (signature) should be provided to these
+ * methods in order to obtain a correct, type-contrained result.
+ * If no signature is provided, conversion can still be done, but the
+ * resulting #GVariant value will be "guessed" from the JSON data types,
+ * according to the following table:
+ *
+ * <table frame='all'><title>Default JSON to GVariant conversion (without signature constrains)</title>
+ *  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
+ *   <thead>
+ *     <row>
+ *       <entry>JSON</entry>
+ *       <entry>GVariant</entry>
+ *     </row>
+ *   </thead>
+ *   <tfoot>
+ *    <row>
+ *     <entry>string</entry>
+ *     <entry>string (s)</entry>
+ *    </row>
+ *    <row>
+ *     <entry>int64</entry>
+ *     <entry>int64 (x)</entry>
+ *    </row>
+ *    <row>
+ *     <entry>boolean</entry>
+ *     <entry>boolean (b)</entry>
+ *    </row>
+ *    <row>
+ *     <entry>double</entry>
+ *     <entry>double (d)</entry>
+ *    </row>
+ *    <row>
+ *     <entry>array</entry>
+ *     <entry>array of variants (av)</entry>
+ *    </row>
+ *    <row>
+ *     <entry>object</entry>
+ *     <entry>dictionary of string-variant (a{sv})</entry>
+ *    </row>
+ *    <row>
+ *     <entry>null</entry>
+ *     <entry>maybe variant (mv)</entry>
+ *    </row>
+ *   </tfoot>
+ *  </tgroup>
+ * </table>
+ */
+
+/* custom extension to the GVariantClass enumeration to differentiate
+ * a single dictionary entry from an array of dictionary entries
+ */
+#define JSON_G_VARIANT_CLASS_DICTIONARY 'c'
+
+typedef void (* GVariantForeachFunc) (GVariant *variant_child,
+                                      gpointer  user_data);
+
+static GVariant * json_to_gvariant_recurse (JsonNode      *json_node,
+                                            const gchar  **signature,
+                                            GError       **error);
+
+/* ========================================================================== */
+/* GVariant to JSON */
+/* ========================================================================== */
+
+static void
+gvariant_foreach (GVariant            *variant,
+                  GVariantForeachFunc  func,
+                  gpointer             user_data)
+{
+  GVariantIter iter;
+  GVariant *variant_child;
+
+  g_variant_iter_init (&iter, variant);
+  while ((variant_child = g_variant_iter_next_value (&iter)) != NULL)
+    {
+      func (variant_child, user_data);
+      g_variant_unref (variant_child);
+    }
+}
+
+static void
+gvariant_to_json_array_foreach (GVariant *variant_child,
+                                gpointer  user_data)
+{
+  JsonArray *array = user_data;
+  JsonNode *json_child;
+
+  json_child = json_gvariant_serialize (variant_child);
+  json_array_add_element (array, json_child);
+}
+
+static JsonNode *
+gvariant_to_json_array (GVariant *variant)
+{
+  JsonArray *array;
+  JsonNode *json_node;
+
+  array = json_array_new ();
+  json_node = json_node_new (JSON_NODE_ARRAY);
+  json_node_set_array (json_node, array);
+  json_array_unref (array);
+
+  gvariant_foreach (variant,
+                    gvariant_to_json_array_foreach,
+                    array);
+
+  return json_node;
+}
+
+static gchar *
+gvariant_simple_to_string (GVariant *variant)
+{
+  GVariantClass class;
+  gchar *str;
+
+  class = g_variant_classify (variant);
+  switch (class)
+    {
+    case G_VARIANT_CLASS_BOOLEAN:
+      if (g_variant_get_boolean (variant))
+        str = g_strdup ("true");
+      else
+        str = g_strdup ("false");
+      break;
+
+    case G_VARIANT_CLASS_BYTE:
+      str = g_strdup_printf ("%u", g_variant_get_byte (variant));
+      break;
+    case G_VARIANT_CLASS_INT16:
+      str = g_strdup_printf ("%d", g_variant_get_int16 (variant));
+      break;
+    case G_VARIANT_CLASS_UINT16:
+      str = g_strdup_printf ("%u", g_variant_get_uint16 (variant));
+      break;
+    case G_VARIANT_CLASS_INT32:
+      str = g_strdup_printf ("%d", g_variant_get_int32 (variant));
+      break;
+    case G_VARIANT_CLASS_UINT32:
+      str = g_strdup_printf ("%u", g_variant_get_uint32 (variant));
+      break;
+    case G_VARIANT_CLASS_INT64:
+      str = g_strdup_printf ("%" G_GINT64_FORMAT,
+                             g_variant_get_int64 (variant));
+      break;
+    case G_VARIANT_CLASS_UINT64:
+      str = g_strdup_printf ("%" G_GUINT64_FORMAT,
+                             g_variant_get_uint64 (variant));
+      break;
+    case G_VARIANT_CLASS_HANDLE:
+      str = g_strdup_printf ("%d", g_variant_get_handle (variant));
+      break;
+
+    case G_VARIANT_CLASS_DOUBLE:
+      {
+        gchar buf[G_ASCII_DTOSTR_BUF_SIZE];
+
+        g_ascii_formatd (buf,
+                         G_ASCII_DTOSTR_BUF_SIZE,
+                         "%f",
+                         g_variant_get_double (variant));
+
+        str = g_strdup (buf);
+        break;
+      }
+
+    case G_VARIANT_CLASS_STRING:
+    case G_VARIANT_CLASS_OBJECT_PATH:
+    case G_VARIANT_CLASS_SIGNATURE:
+      str = g_strdup (g_variant_get_string (variant, NULL));
+      break;
+
+    default:
+      g_assert_not_reached ();
+      break;
+    }
+
+  return str;
+}
+
+static JsonNode *
+gvariant_dict_entry_to_json (GVariant  *variant, gchar **member_name)
+{
+  GVariant *member;
+  GVariant *value;
+  JsonNode *json_node;
+
+  member = g_variant_get_child_value (variant, 0);
+  *member_name = gvariant_simple_to_string (member);
+
+  value = g_variant_get_child_value (variant, 1);
+  json_node = json_gvariant_serialize (value);
+
+  g_variant_unref (member);
+  g_variant_unref (value);
+
+  return json_node;
+}
+
+static void
+gvariant_to_json_object_foreach (GVariant *variant_child, gpointer  user_data)
+{
+  gchar *member_name;
+  JsonNode *json_child;
+  JsonObject *object = (JsonObject *) user_data;
+
+  json_child = gvariant_dict_entry_to_json (variant_child, &member_name);
+  json_object_set_member (object, member_name, json_child);
+  g_free (member_name);
+}
+
+static JsonNode *
+gvariant_to_json_object (GVariant *variant)
+{
+  JsonNode *json_node;
+  JsonObject *object;
+
+  json_node = json_node_new (JSON_NODE_OBJECT);
+  object = json_object_new ();
+  json_node_set_object (json_node, object);
+  json_object_unref (object);
+
+  gvariant_foreach (variant,
+                    gvariant_to_json_object_foreach,
+                    object);
+
+  return json_node;
+}
+
+/**
+ * json_gvariant_serialize:
+ * @variant: A #GVariant to convert
+ *
+ * Converts @variant to a JSON tree.
+ *
+ * Return value: (transfer full): A #JsonNode representing the root of the
+ *   JSON data structure obtained from @variant
+ *
+ * Since: 0.14
+ */
+JsonNode *
+json_gvariant_serialize (GVariant *variant)
+{
+  JsonNode *json_node = NULL;
+  GVariantClass class;
+
+  g_return_val_if_fail (variant != NULL, NULL);
+
+  class = g_variant_classify (variant);
+
+  if (! g_variant_is_container (variant))
+    {
+      json_node = json_node_new (JSON_NODE_VALUE);
+
+      switch (class)
+        {
+        case G_VARIANT_CLASS_BOOLEAN:
+          json_node_set_boolean (json_node, g_variant_get_boolean (variant));
+          break;
+
+        case G_VARIANT_CLASS_BYTE:
+          json_node_set_int (json_node, g_variant_get_byte (variant));
+          break;
+        case G_VARIANT_CLASS_INT16:
+          json_node_set_int (json_node, g_variant_get_int16 (variant));
+          break;
+        case G_VARIANT_CLASS_UINT16:
+          json_node_set_int (json_node, g_variant_get_uint16 (variant));
+          break;
+        case G_VARIANT_CLASS_INT32:
+          json_node_set_int (json_node, g_variant_get_int32 (variant));
+          break;
+        case G_VARIANT_CLASS_UINT32:
+          json_node_set_int (json_node, g_variant_get_uint32 (variant));
+          break;
+        case G_VARIANT_CLASS_INT64:
+          json_node_set_int (json_node, g_variant_get_int64 (variant));
+          break;
+        case G_VARIANT_CLASS_UINT64:
+          json_node_set_int (json_node, g_variant_get_uint64 (variant));
+          break;
+        case G_VARIANT_CLASS_HANDLE:
+          json_node_set_int (json_node, g_variant_get_handle (variant));
+          break;
+
+        case G_VARIANT_CLASS_DOUBLE:
+          json_node_set_double (json_node, g_variant_get_double (variant));
+          break;
+
+        case G_VARIANT_CLASS_STRING:
+        case G_VARIANT_CLASS_OBJECT_PATH:
+        case G_VARIANT_CLASS_SIGNATURE:
+          json_node_set_string (json_node, g_variant_get_string (variant, NULL));
+          break;
+
+        default:
+          break;
+        }
+    }
+  else
+    {
+      switch (class)
+        {
+        case G_VARIANT_CLASS_MAYBE:
+          {
+            GVariant *value;
+
+            value = g_variant_get_maybe (variant);
+            if (value == NULL)
+              {
+                json_node = json_node_new (JSON_NODE_NULL);
+              }
+            else
+              {
+                json_node = json_gvariant_serialize (value);
+                g_variant_unref (value);
+              }
+
+            break;
+          }
+
+        case G_VARIANT_CLASS_VARIANT:
+          {
+            GVariant *value;
+
+            value = g_variant_get_variant (variant);
+            json_node = json_gvariant_serialize (value);
+            g_variant_unref (value);
+
+            break;
+          }
+
+        case G_VARIANT_CLASS_ARRAY:
+          {
+            const gchar *type;
+
+            type = g_variant_get_type_string (variant);
+
+            if (type[1] == G_VARIANT_CLASS_DICT_ENTRY)
+              {
+                /* array of dictionary entries => JsonObject */
+                json_node = gvariant_to_json_object (variant);
+              }
+            else
+              {
+                /* array of anything else => JsonArray */
+                json_node = gvariant_to_json_array (variant);
+              }
+
+            break;
+          }
+
+        case G_VARIANT_CLASS_DICT_ENTRY:
+          {
+            gchar *member_name;
+            JsonObject *object;
+            JsonNode *child;
+
+            /* a single dictionary entry => JsonObject */
+            json_node = json_node_new (JSON_NODE_OBJECT);
+            object = json_object_new ();
+            json_node_set_object (json_node, object);
+            json_object_unref (object);
+
+            child = gvariant_dict_entry_to_json (variant, &member_name);
+
+            json_object_set_member (object, member_name, child);
+            g_free (member_name);
+
+            break;
+          }
+
+        case G_VARIANT_CLASS_TUPLE:
+          json_node = gvariant_to_json_array (variant);
+          break;
+
+        default:
+          break;
+        }
+    }
+
+  return json_node;
+}
+
+/**
+ * json_gvariant_serialize_data:
+ * @variant: A #GVariant to convert
+ * @length: (out) (allow-none): Return location for the length of the returned
+ *   string, or %NULL
+ *
+ * Converts @variant to its JSON encoded string representation. This method
+ * is actually a helper function. It uses json_gvariant_serialize() to obtain the
+ * JSON tree, and then #JsonGenerator to stringify it.
+ *
+ * Return value: (transfer full): The JSON encoded string corresponding to
+ *   @variant
+ *
+ * Since: 0.14
+ */
+gchar *
+json_gvariant_serialize_data (GVariant *variant, gsize *length)
+{
+  JsonNode *json_node;
+  JsonGenerator *generator;
+  gchar *json;
+
+  json_node = json_gvariant_serialize (variant);
+
+  generator = json_generator_new ();
+
+  json_generator_set_root (generator, json_node);
+  json = json_generator_to_data (generator, length);
+
+  g_object_unref (generator);
+
+  json_node_free (json_node);
+
+  return json;
+}
+
+/* ========================================================================== */
+/* JSON to GVariant */
+/* ========================================================================== */
+
+static GVariantClass
+json_to_gvariant_get_next_class (JsonNode     *json_node,
+                                 const gchar **signature)
+{
+  if (signature == NULL)
+    {
+      GVariantClass class = 0;
+
+      switch (json_node_get_node_type (json_node))
+        {
+        case JSON_NODE_VALUE:
+          switch (json_node_get_value_type (json_node))
+            {
+            case G_TYPE_BOOLEAN:
+              class = G_VARIANT_CLASS_BOOLEAN;
+              break;
+
+            case G_TYPE_INT64:
+              class = G_VARIANT_CLASS_INT64;
+              break;
+
+            case G_TYPE_DOUBLE:
+              class = G_VARIANT_CLASS_DOUBLE;
+              break;
+
+            case G_TYPE_STRING:
+              class = G_VARIANT_CLASS_STRING;
+              break;
+            }
+
+          break;
+
+        case JSON_NODE_ARRAY:
+          class = G_VARIANT_CLASS_ARRAY;
+          break;
+
+        case JSON_NODE_OBJECT:
+          class = JSON_G_VARIANT_CLASS_DICTIONARY;
+          break;
+
+        case JSON_NODE_NULL:
+          class = G_VARIANT_CLASS_MAYBE;
+          break;
+        }
+
+      return class;
+    }
+  else
+    {
+      if ((*signature)[0] == G_VARIANT_CLASS_ARRAY &&
+          (*signature)[1] == G_VARIANT_CLASS_DICT_ENTRY)
+        return JSON_G_VARIANT_CLASS_DICTIONARY;
+      else
+        return (*signature)[0];
+    }
+}
+
+static gboolean
+json_node_assert_type (JsonNode       *json_node,
+                       JsonNodeType    type,
+                       GType           sub_type,
+                       GError        **error)
+{
+  if (JSON_NODE_TYPE (json_node) != type ||
+      (type == JSON_NODE_VALUE &&
+       (json_node_get_value_type (json_node) != sub_type)))
+    {
+      g_set_error_literal (error,
+                           G_IO_ERROR,
+                           G_IO_ERROR_INVALID_DATA,
+                           "Unexpected data-type in JSON node");
+      return FALSE;
+    }
+  else
+    {
+      return TRUE;
+    }
+}
+
+static void
+json_to_gvariant_foreach_add (gpointer data, gpointer user_data)
+{
+  GVariantBuilder *builder = (GVariantBuilder *) user_data;
+  GVariant *child = (GVariant *) data;
+
+  g_variant_builder_add_value (builder, child);
+}
+
+static void
+json_to_gvariant_foreach_free (gpointer data, gpointer user_data)
+{
+  GVariant *child = (GVariant *) data;
+
+  g_variant_unref (child);
+}
+
+static GVariant *
+json_to_gvariant_build_from_glist (GList *list, const gchar *signature)
+{
+  GVariantBuilder *builder;
+  GVariant *result;
+
+  builder = g_variant_builder_new (G_VARIANT_TYPE (signature));
+
+  g_list_foreach (list, json_to_gvariant_foreach_add, builder);
+  result = g_variant_builder_end (builder);
+
+  g_variant_builder_unref (builder);
+
+  return result;
+}
+
+static GVariant *
+json_to_gvariant_tuple (JsonNode     *json_node,
+                        const gchar **signature,
+                        GError      **error)
+{
+  GVariant *variant = NULL;
+  JsonArray *array;
+  gint i;
+  GList *children = NULL;
+  gboolean roll_back = FALSE;
+  const gchar *initial_signature;
+
+  array = json_node_get_array (json_node);
+
+  initial_signature = *signature;
+  (*signature)++;
+  i = 1;
+  while ((*signature)[0] != ')' && (*signature)[0] != '\0')
+    {
+      JsonNode *json_child;
+      GVariant *variant_child;
+
+      if (i - 1 >= json_array_get_length (array))
+        {
+          g_set_error_literal (error,
+                               G_IO_ERROR,
+                               G_IO_ERROR_INVALID_DATA,
+                               "Missing elements in JSON array to conform tuple");
+          roll_back = TRUE;
+          break;
+        }
+
+      json_child = json_array_get_element (array, i - 1);
+
+      variant_child = json_to_gvariant_recurse (json_child, signature, error);
+      if (variant_child != NULL)
+        {
+          children = g_list_append (children, variant_child);
+        }
+      else
+        {
+          roll_back = TRUE;
+          break;
+        }
+
+      i++;
+    }
+
+  if (! roll_back)
+    {
+      if ( (*signature)[0] != ')')
+        {
+          g_set_error_literal (error,
+                               G_IO_ERROR,
+                               G_IO_ERROR_INVALID_DATA,
+                               "Missing closing symbol ')' in GVariant tuple type");
+          roll_back = TRUE;
+        }
+      else if (json_array_get_length (array) >= i)
+        {
+          g_set_error_literal (error,
+                               G_IO_ERROR,
+                               G_IO_ERROR_INVALID_DATA,
+                               "Unexpected extra elements in JSON array");
+          roll_back = TRUE;
+        }
+      else
+        {
+          gchar *tuple_type;
+
+          tuple_type = g_strndup (initial_signature,
+                                  (*signature) - initial_signature + 1);
+
+          variant = json_to_gvariant_build_from_glist (children, tuple_type);
+
+          g_free (tuple_type);
+        }
+    }
+
+  if (roll_back)
+    g_list_foreach (children, json_to_gvariant_foreach_free, NULL);
+
+  g_list_free (children);
+
+  return variant;
+}
+
+static gchar *
+signature_get_next_complete_type (const gchar **signature)
+{
+  GVariantClass class;
+  const gchar *initial_signature;
+  gchar *result;
+
+  /* here it is assumed that 'signature' is a valid type string */
+
+  initial_signature = *signature;
+  class = (*signature)[0];
+
+  if (class == G_VARIANT_CLASS_TUPLE || class == G_VARIANT_CLASS_DICT_ENTRY)
+    {
+      gchar stack[256] = {0};
+      guint stack_len = 0;
+
+      do
+        {
+          if ( (*signature)[0] == G_VARIANT_CLASS_TUPLE)
+            {
+              stack[stack_len] = ')';
+              stack_len++;
+            }
+          else if ( (*signature)[0] == G_VARIANT_CLASS_DICT_ENTRY)
+            {
+              stack[stack_len] = '}';
+              stack_len++;
+            }
+
+          (*signature)++;
+
+          if ( (*signature)[0] == stack[stack_len - 1])
+            stack_len--;
+        }
+      while (stack_len > 0);
+
+      (*signature)++;
+    }
+  else if (class == G_VARIANT_CLASS_ARRAY || class == G_VARIANT_CLASS_MAYBE)
+    {
+      gchar *tmp_sig;
+
+      (*signature)++;
+      tmp_sig = signature_get_next_complete_type (signature);
+      g_free (tmp_sig);
+    }
+  else
+    {
+      (*signature)++;
+    }
+
+  result = g_strndup (initial_signature, (*signature) - initial_signature);
+
+  return result;
+}
+
+static GVariant *
+json_to_gvariant_maybe (JsonNode     *json_node,
+                        const gchar **signature,
+                        GError      **error)
+{
+  GVariant *variant = NULL;
+  GVariant *value;
+  gchar *maybe_signature;
+
+  if (signature)
+    {
+      (*signature)++;
+      maybe_signature = signature_get_next_complete_type (signature);
+    }
+  else
+    {
+      maybe_signature = g_strdup ("v");
+    }
+
+  if (json_node_get_node_type (json_node) == JSON_NODE_NULL)
+    {
+      variant = g_variant_new_maybe (G_VARIANT_TYPE (maybe_signature), NULL);
+    }
+  else
+    {
+      const gchar *tmp_signature;
+
+      tmp_signature = maybe_signature;
+      value = json_to_gvariant_recurse (json_node,
+                                        &tmp_signature,
+                                        error);
+
+      if (value != NULL)
+        variant = g_variant_new_maybe (G_VARIANT_TYPE (maybe_signature), value);
+    }
+
+  g_free (maybe_signature);
+
+  /* compensate the (*signature)++ call at the end of 'recurse()' */
+  if (signature)
+    (*signature)--;
+
+  return variant;
+}
+
+static GVariant *
+json_to_gvariant_array (JsonNode     *json_node,
+                        const gchar **signature,
+                        GError      **error)
+{
+  GVariant *variant = NULL;
+  JsonArray *array;
+  GList *children = NULL;
+  gboolean roll_back = FALSE;
+  const gchar *orig_signature;
+  gchar *child_signature;
+
+  array = json_node_get_array (json_node);
+
+  if (signature != NULL)
+    {
+      orig_signature = *signature;
+
+      (*signature)++;
+      child_signature = signature_get_next_complete_type (signature);
+    }
+  else
+    child_signature = g_strdup ("v");
+
+  if (json_array_get_length (array) > 0)
+    {
+      gint i;
+      guint len;
+
+      len = json_array_get_length (array);
+      for (i = 0; i < len; i++)
+        {
+          JsonNode *json_child;
+          GVariant *variant_child;
+          const gchar *tmp_signature;
+
+          json_child = json_array_get_element (array, i);
+
+          tmp_signature = child_signature;
+          variant_child = json_to_gvariant_recurse (json_child,
+                                                    &tmp_signature,
+                                                    error);
+          if (variant_child != NULL)
+            {
+              children = g_list_append (children, variant_child);
+            }
+          else
+            {
+              roll_back = TRUE;
+              break;
+            }
+        }
+    }
+
+  if (!roll_back)
+    {
+      gchar *array_signature;
+
+      if (signature)
+        array_signature = g_strndup (orig_signature, (*signature) - orig_signature);
+      else
+        array_signature = g_strdup ("av");
+
+      variant = json_to_gvariant_build_from_glist (children, array_signature);
+
+      g_free (array_signature);
+
+      /* compensate the (*signature)++ call at the end of 'recurse()' */
+      if (signature)
+        (*signature)--;
+    }
+  else
+    g_list_foreach (children, json_to_gvariant_foreach_free, NULL);
+
+  g_list_free (children);
+  g_free (child_signature);
+
+  return variant;
+}
+
+static GVariant *
+gvariant_simple_from_string (const gchar    *st,
+                             GVariantClass   class,
+                             GError        **error)
+{
+  GVariant *variant = NULL;
+  gchar *nptr = NULL;
+
+  errno = 0;
+
+  switch (class)
+    {
+    case G_VARIANT_CLASS_BOOLEAN:
+      if (g_strcmp0 (st, "true") == 0)
+        variant = g_variant_new_boolean (TRUE);
+      else if (g_strcmp0 (st, "false") == 0)
+        variant = g_variant_new_boolean (FALSE);
+      else
+        errno = 1;
+      break;
+
+    case G_VARIANT_CLASS_BYTE:
+      variant = g_variant_new_byte (g_ascii_strtoll (st, &nptr, 10));
+      break;
+
+    case G_VARIANT_CLASS_INT16:
+      variant = g_variant_new_int16 (g_ascii_strtoll (st, &nptr, 10));
+      break;
+
+    case G_VARIANT_CLASS_UINT16:
+      variant = g_variant_new_uint16 (g_ascii_strtoll (st, &nptr, 10));
+      break;
+
+    case G_VARIANT_CLASS_INT32:
+      variant = g_variant_new_int32 (g_ascii_strtoll (st, &nptr, 10));
+      break;
+
+    case G_VARIANT_CLASS_UINT32:
+      variant = g_variant_new_uint32 (g_ascii_strtoull (st, &nptr, 10));
+      break;
+
+    case G_VARIANT_CLASS_INT64:
+      variant = g_variant_new_int64 (g_ascii_strtoll (st, &nptr, 10));
+      break;
+
+    case G_VARIANT_CLASS_UINT64:
+      variant = g_variant_new_uint64 (g_ascii_strtoull (st, &nptr, 10));
+      break;
+
+    case G_VARIANT_CLASS_HANDLE:
+      variant = g_variant_new_handle (strtol (st, &nptr, 10));
+      break;
+
+    case G_VARIANT_CLASS_DOUBLE:
+      variant = g_variant_new_double (g_ascii_strtod (st, &nptr));
+      break;
+
+    case G_VARIANT_CLASS_STRING:
+    case G_VARIANT_CLASS_OBJECT_PATH:
+    case G_VARIANT_CLASS_SIGNATURE:
+      variant = g_variant_new_string (st);
+      break;
+
+    default:
+      g_assert_not_reached ();
+      break;
+    }
+
+  if (errno != 0 || nptr == st)
+    {
+      g_set_error_literal (error,
+                           G_IO_ERROR,
+                           G_IO_ERROR_INVALID_DATA,
+                           "Invalid string value converting to GVariant");
+      if (variant != NULL)
+        {
+          g_variant_unref (variant);
+          variant = NULL;
+        }
+    }
+
+  return variant;
+}
+
+static void
+parse_dict_entry_signature (const gchar **signature,
+                            gchar       **entry_signature,
+                            gchar       **key_signature,
+                            gchar       **value_signature)
+{
+  const gchar *tmp_sig;
+
+  if (signature != NULL)
+    *entry_signature = signature_get_next_complete_type (signature);
+  else
+    *entry_signature = g_strdup ("{sv}");
+
+  tmp_sig = (*entry_signature) + 1;
+  *key_signature = signature_get_next_complete_type (&tmp_sig);
+  *value_signature = signature_get_next_complete_type (&tmp_sig);
+}
+
+static GVariant *
+json_to_gvariant_dict_entry (JsonNode     *json_node,
+                             const gchar **signature,
+                             GError      **error)
+{
+  GVariant *variant = NULL;
+  JsonObject *obj;
+
+  gchar *entry_signature;
+  gchar *key_signature;
+  gchar *value_signature;
+  const gchar *tmp_signature;
+
+  GList *member;
+
+  const gchar *json_member;
+  JsonNode *json_value;
+  GVariant *variant_member;
+  GVariant *variant_value;
+
+  obj = json_node_get_object (json_node);
+
+  if (json_object_get_size (obj) != 1)
+    {
+      g_set_error_literal (error,
+                           G_IO_ERROR,
+                           G_IO_ERROR_INVALID_DATA,
+                           "GVariant dictionary entry expects JSON object with exactly one member");
+      return NULL;
+    }
+
+  parse_dict_entry_signature (signature,
+                              &entry_signature,
+                              &key_signature,
+                              &value_signature);
+
+  member = json_object_get_members (obj);
+
+  json_member = (const gchar *) member->data;
+  variant_member = gvariant_simple_from_string (json_member,
+                                                key_signature[0],
+                                                error);
+  if (variant_member != NULL)
+    {
+      json_value = json_object_get_member (obj, json_member);
+
+      tmp_signature = value_signature;
+      variant_value = json_to_gvariant_recurse (json_value,
+                                                &tmp_signature,
+                                                error);
+
+      if (variant_value != NULL)
+        {
+          GVariantBuilder *builder;
+
+          builder = g_variant_builder_new (G_VARIANT_TYPE (entry_signature));
+          g_variant_builder_add_value (builder, variant_member);
+          g_variant_builder_add_value (builder, variant_value);
+          variant = g_variant_builder_end (builder);
+
+          g_variant_builder_unref (builder);
+        }
+    }
+
+  g_list_free (member);
+  g_free (value_signature);
+  g_free (key_signature);
+  g_free (entry_signature);
+
+  /* compensate the (*signature)++ call at the end of 'recurse()' */
+  if (signature)
+    (*signature)--;
+
+  return variant;
+}
+
+static GVariant *
+json_to_gvariant_dictionary (JsonNode     *json_node,
+                             const gchar **signature,
+                             GError      **error)
+{
+  GVariant *variant = NULL;
+  JsonObject *obj;
+  gboolean roll_back = FALSE;
+
+  gchar *dict_signature;
+  gchar *entry_signature;
+  gchar *key_signature;
+  gchar *value_signature;
+  const gchar *tmp_signature;
+
+  GVariantBuilder *builder;
+  GList *members;
+  GList *member;
+
+  obj = json_node_get_object (json_node);
+
+  if (signature != NULL)
+    (*signature)++;
+
+  parse_dict_entry_signature (signature,
+                              &entry_signature,
+                              &key_signature,
+                              &value_signature);
+
+  dict_signature = g_strdup_printf ("a%s", entry_signature);
+
+  builder = g_variant_builder_new (G_VARIANT_TYPE (dict_signature));
+
+  members = json_object_get_members (obj);
+
+  member = members;
+  while (member != NULL)
+    {
+      const gchar *json_member;
+      JsonNode *json_value;
+      GVariant *variant_member;
+      GVariant *variant_value;
+
+      json_member = (const gchar *) member->data;
+      variant_member = gvariant_simple_from_string (json_member,
+                                                    key_signature[0],
+                                                    error);
+      if (variant_member == NULL)
+        {
+          roll_back = TRUE;
+          break;
+        }
+
+      json_value = json_object_get_member (obj, json_member);
+
+      tmp_signature = value_signature;
+      variant_value = json_to_gvariant_recurse (json_value,
+                                                &tmp_signature,
+                                                error);
+
+      if (variant_value != NULL)
+        {
+          g_variant_builder_open (builder, G_VARIANT_TYPE (entry_signature));
+          g_variant_builder_add_value (builder, variant_member);
+          g_variant_builder_add_value (builder, variant_value);
+          g_variant_builder_close (builder);
+        }
+      else
+        {
+          roll_back = TRUE;
+          break;
+        }
+
+      member = member->next;
+    }
+
+  if (! roll_back)
+    variant = g_variant_builder_end (builder);
+
+  g_variant_builder_unref (builder);
+  g_list_free (members);
+  g_free (value_signature);
+  g_free (key_signature);
+  g_free (entry_signature);
+  g_free (dict_signature);
+
+  /* compensate the (*signature)++ call at the end of 'recurse()' */
+  if (signature != NULL)
+    (*signature)--;
+
+  return variant;
+}
+
+static GVariant *
+json_to_gvariant_recurse (JsonNode      *json_node,
+                          const gchar  **signature,
+                          GError       **error)
+{
+  GVariant *variant = NULL;
+  GVariantClass class;
+  gchar class_type[2] = {0, 0};
+
+  class = json_to_gvariant_get_next_class (json_node, signature);
+  class_type[0] = class;
+
+  if (class == JSON_G_VARIANT_CLASS_DICTIONARY)
+    {
+      if (json_node_assert_type (json_node, JSON_NODE_OBJECT, 0, error))
+        variant = json_to_gvariant_dictionary (json_node, signature, error);
+
+      goto out;
+    }
+
+  switch (class)
+    {
+    case G_VARIANT_CLASS_BOOLEAN:
+      if (json_node_assert_type (json_node, JSON_NODE_VALUE, G_TYPE_BOOLEAN, error))
+        variant = g_variant_new (class_type, json_node_get_boolean (json_node));
+      break;
+
+    case G_VARIANT_CLASS_BYTE:
+    case G_VARIANT_CLASS_INT16:
+    case G_VARIANT_CLASS_UINT16:
+    case G_VARIANT_CLASS_INT32:
+    case G_VARIANT_CLASS_UINT32:
+    case G_VARIANT_CLASS_INT64:
+    case G_VARIANT_CLASS_UINT64:
+    case G_VARIANT_CLASS_HANDLE:
+      if (json_node_assert_type (json_node, JSON_NODE_VALUE, G_TYPE_INT64, error))
+        variant = g_variant_new (class_type, json_node_get_int (json_node));
+      break;
+
+    case G_VARIANT_CLASS_DOUBLE:
+      if (json_node_assert_type (json_node, JSON_NODE_VALUE, G_TYPE_DOUBLE, error))
+        variant = g_variant_new (class_type, json_node_get_double (json_node));
+      break;
+
+    case G_VARIANT_CLASS_STRING:
+    case G_VARIANT_CLASS_OBJECT_PATH:
+    case G_VARIANT_CLASS_SIGNATURE:
+      if (json_node_assert_type (json_node, JSON_NODE_VALUE, G_TYPE_STRING, error))
+        variant = g_variant_new (class_type, json_node_get_string (json_node));
+      break;
+
+    case G_VARIANT_CLASS_VARIANT:
+      variant = g_variant_new_variant (json_to_gvariant_recurse (json_node,
+                                                                 NULL,
+                                                                 error));
+      break;
+
+    case G_VARIANT_CLASS_MAYBE:
+      variant = json_to_gvariant_maybe (json_node, signature, error);
+      break;
+
+    case G_VARIANT_CLASS_ARRAY:
+      if (json_node_assert_type (json_node, JSON_NODE_ARRAY, 0, error))
+        variant = json_to_gvariant_array (json_node, signature, error);
+      break;
+
+    case G_VARIANT_CLASS_TUPLE:
+      if (json_node_assert_type (json_node, JSON_NODE_ARRAY, 0, error))
+        variant = json_to_gvariant_tuple (json_node, signature, error);
+      break;
+
+    case G_VARIANT_CLASS_DICT_ENTRY:
+      if (json_node_assert_type (json_node, JSON_NODE_OBJECT, 0, error))
+        variant = json_to_gvariant_dict_entry (json_node, signature, error);
+      break;
+
+    default:
+      {
+        gchar *err_msg;
+
+        err_msg = g_strdup_printf ("GVariant class '%c' not supported", class);
+        g_set_error_literal (error,
+                             G_IO_ERROR,
+                             G_IO_ERROR_INVALID_DATA,
+                             err_msg);
+        g_free (err_msg);
+        break;
+      }
+    }
+
+out:
+  if (signature)
+    (*signature)++;
+
+  return variant;
+}
+
+/**
+ * json_gvariant_deserialize:
+ * @json_node: A #JsonNode to convert
+ * @signature: A valid #GVariant type string, or %NULL
+ * @error: A pointer to a #GError
+ *
+ * Converts a JSON data structure to a GVariant value using @signature to
+ * resolve ambiguous data types. If no error occurs, the resulting #GVariant
+ * is guaranteed to conform to @signature.
+ *
+ * If @signature is not %NULL but does not represent a valid GVariant type
+ * string, %NULL is returned and error is set to %G_IO_ERROR_INVALID_ARGUMENT.
+ * If a @signature is provided but the JSON structure cannot be mapped to it,
+ * %NULL is returned and error is set to %G_IO_ERROR_INVALID_DATA.
+ * If @signature is %NULL, the conversion is done based strictly on the types
+ * in the JSON nodes.
+ *
+ * Return value: (transfer full): A newly created #GVariant compliant with
+ *   @signature, or %NULL on error
+ *
+ * Since: 0.14
+ */
+GVariant *
+json_gvariant_deserialize (JsonNode     *json_node,
+                           const gchar  *signature,
+                           GError      **error)
+{
+  g_return_val_if_fail (json_node != NULL, NULL);
+
+  if (signature != NULL && ! g_variant_type_string_is_valid (signature))
+    {
+      g_set_error_literal (error,
+                           G_IO_ERROR,
+                           G_IO_ERROR_INVALID_ARGUMENT,
+                           "Invalid GVariant type string");
+      return NULL;
+    }
+
+  return json_to_gvariant_recurse (json_node, &signature, error);
+}
+
+/**
+ * json_gvariant_deserialize_data:
+ * @json: A JSON data string
+ * @length: The length of @json, or -1 if %NULL-terminated
+ * @signature: A valid #GVariant type string, or %NULL
+ * @error: A pointer to a #GError
+ *
+ * Converts a JSON string to a #GVariant value. This method works exactly
+ * like json_gvariant_deserialize(), but takes a JSON encoded string instead.
+ * The string is first converted to a #JsonNode using #JsonParser, and then
+ * json_gvariant_deserialize() is called.
+ *
+ * Returns: (transfer full): A newly created #GVariant compliant with
+ *   @signature, or %NULL on error
+ *
+ * Since: 0.14
+ */
+GVariant *
+json_gvariant_deserialize_data (const gchar  *json,
+                                gssize        length,
+                                const gchar  *signature,
+                                GError      **error)
+{
+  JsonParser *parser;
+  GVariant *variant = NULL;
+  JsonNode *root;
+
+  parser = json_parser_new ();
+
+  if (! json_parser_load_from_data (parser, json, length, error))
+    return NULL;
+
+  root = json_parser_get_root (parser);
+  if (root == NULL)
+    {
+      g_set_error_literal (error,
+                           G_IO_ERROR,
+                           G_IO_ERROR_INVALID_DATA,
+                           "JSON data is empty");
+    }
+  else
+    {
+      variant =
+        json_gvariant_deserialize (json_parser_get_root (parser), signature, error);
+    }
+
+  g_object_unref (parser);
+
+  return variant;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gvariant.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gvariant.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-gvariant.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-gvariant.h	2011-03-27 09:15:30.820553000 -0600
@@ -0,0 +1,46 @@
+/* json-gvariant.h - JSON GVariant integration
+ *
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Eduardo Lima Mitev  <elima@igalia.com>
+ */
+
+#ifndef __JSON_GVARIANT_H__
+#define __JSON_GVARIANT_H__
+
+#include <glib.h>
+#include <json-glib/json-glib.h>
+
+G_BEGIN_DECLS
+
+JsonNode * json_gvariant_serialize        (GVariant *variant);
+gchar *    json_gvariant_serialize_data   (GVariant *variant,
+                                           gsize    *length);
+
+GVariant * json_gvariant_deserialize      (JsonNode     *json_node,
+                                           const gchar  *signature,
+                                           GError      **error);
+GVariant * json_gvariant_deserialize_data (const gchar  *json,
+                                           gssize        length,
+                                           const gchar  *signature,
+                                           GError      **error);
+
+G_END_DECLS
+
+#endif /* __JSON_GVARIANT_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-marshal.list pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-marshal.list
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-marshal.list	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-marshal.list	2011-03-27 09:15:30.764553000 -0600
@@ -0,0 +1,5 @@
+VOID:VOID
+VOID:BOXED
+VOID:BOXED,STRING
+VOID:BOXED,INT
+VOID:POINTER
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-node.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-node.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-node.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-node.c	2011-03-27 09:15:30.764553000 -0600
@@ -0,0 +1,800 @@
+/* json-node.c - JSON object model node
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <glib.h>
+
+#include "json-types-private.h"
+
+/**
+ * SECTION:json-node
+ * @short_description: Node in a JSON object model
+ *
+ * A #JsonNode is a generic container of elements inside a JSON stream.
+ * It can contain fundamental types (integers, booleans, floating point
+ * numbers, strings) and complex types (arrays and objects).
+ *
+ * When parsing a JSON data stream you extract the root node and walk
+ * the node tree by retrieving the type of data contained inside the
+ * node with the %JSON_NODE_TYPE macro. If the node contains a fundamental
+ * type you can retrieve a copy of the #GValue holding it with the
+ * json_node_get_value() function, and then use the #GValue API to extract
+ * the data; if the node contains a complex type you can retrieve the
+ * #JsonObject or the #JsonArray using json_node_get_object() or
+ * json_node_get_array() respectively, and then retrieve the nodes
+ * they contain.
+ */
+
+G_DEFINE_BOXED_TYPE (JsonNode, json_node, json_node_copy, json_node_free);
+
+/**
+ * json_node_get_value_type:
+ * @node: a #JsonNode
+ *
+ * Returns the #GType of the payload of the node.
+ *
+ * Return value: a #GType for the payload.
+ *
+ * Since: 0.4
+ */
+GType
+json_node_get_value_type (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, G_TYPE_INVALID);
+
+  switch (node->type)
+    {
+    case JSON_NODE_OBJECT:
+      return JSON_TYPE_OBJECT;
+
+    case JSON_NODE_ARRAY:
+      return JSON_TYPE_ARRAY;
+
+    case JSON_NODE_NULL:
+      return G_TYPE_INVALID;
+
+    case JSON_NODE_VALUE:
+      return G_VALUE_TYPE (&(node->data.value));
+
+    default:
+      g_assert_not_reached ();
+      return G_TYPE_INVALID;
+    }
+}
+
+/**
+ * json_node_new:
+ * @type: a #JsonNodeType
+ *
+ * Creates a new #JsonNode of @type.
+ *
+ * Return value: the newly created #JsonNode
+ */
+JsonNode *
+json_node_new (JsonNodeType type)
+{
+  JsonNode *data;
+
+  g_return_val_if_fail (type >= JSON_NODE_OBJECT &&
+                        type <= JSON_NODE_NULL, NULL);
+
+  data = g_slice_new0 (JsonNode);
+  data->type = type;
+
+  return data;
+}
+
+/**
+ * json_node_copy:
+ * @node: a #JsonNode
+ *
+ * Copies @node. If the node contains complex data types then the reference
+ * count of the objects is increased.
+ *
+ * Return value: (transfer full): the copied #JsonNode
+ */
+JsonNode *
+json_node_copy (JsonNode *node)
+{
+  JsonNode *copy;
+
+  g_return_val_if_fail (node != NULL, NULL);
+
+  copy = g_slice_new0 (JsonNode);
+  copy->type = node->type;
+
+  switch (copy->type)
+    {
+    case JSON_NODE_OBJECT:
+      if (node->data.object)
+        copy->data.object = json_object_ref (node->data.object);
+      break;
+
+    case JSON_NODE_ARRAY:
+      if (node->data.array)
+        copy->data.array = json_array_ref (node->data.array);
+      break;
+
+    case JSON_NODE_VALUE:
+      if (G_VALUE_TYPE (&(node->data.value)) != G_TYPE_INVALID)
+        {
+          g_value_init (&(copy->data.value), G_VALUE_TYPE (&(node->data.value)));
+          g_value_copy (&(node->data.value), &(copy->data.value));
+        }
+      break;
+
+    case JSON_NODE_NULL:
+      break;
+
+    default:
+      g_assert_not_reached ();
+    }
+
+  return copy;
+}
+
+/**
+ * json_node_set_object:
+ * @node: a #JsonNode
+ * @object: a #JsonObject
+ *
+ * Sets @objects inside @node. The reference count of @object is increased.
+ */
+void
+json_node_set_object (JsonNode   *node,
+                      JsonObject *object)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_OBJECT);
+
+  if (node->data.object)
+    json_object_unref (node->data.object);
+
+  if (object)
+    node->data.object = json_object_ref (object);
+  else
+    node->data.object = NULL;
+}
+
+/**
+ * json_node_take_object:
+ * @node: a #JsonNode
+ * @object: (transfer full): a #JsonObject
+ *
+ * Sets @object inside @node. The reference count of @object is not increased.
+ */
+void
+json_node_take_object (JsonNode   *node,
+                       JsonObject *object)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_OBJECT);
+
+  if (node->data.object)
+    {
+      json_object_unref (node->data.object);
+      node->data.object = NULL;
+    }
+
+  if (object)
+    node->data.object = object;
+}
+
+/**
+ * json_node_get_object:
+ * @node: a #JsonNode
+ *
+ * Retrieves the #JsonObject stored inside a #JsonNode
+ *
+ * Return value: (transfer none): the #JsonObject
+ */
+JsonObject *
+json_node_get_object (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_OBJECT, NULL);
+
+  return node->data.object;
+}
+
+/**
+ * json_node_dup_object:
+ * @node: a #JsonNode
+ *
+ * Retrieves the #JsonObject inside @node. The reference count of
+ * the returned object is increased.
+ *
+ * Return value: (transfer full): the #JsonObject
+ */
+JsonObject *
+json_node_dup_object (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_OBJECT, NULL);
+
+  if (node->data.object)
+    return json_object_ref (node->data.object);
+  
+  return NULL;
+}
+
+/**
+ * json_node_set_array:
+ * @node: a #JsonNode
+ * @array: a #JsonArray
+ *
+ * Sets @array inside @node and increases the #JsonArray reference count
+ */
+void
+json_node_set_array (JsonNode  *node,
+                     JsonArray *array)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_ARRAY);
+
+  if (node->data.array)
+    json_array_unref (node->data.array);
+
+  if (array)
+    node->data.array = json_array_ref (array);
+  else
+    node->data.array = NULL;
+}
+
+/**
+ * json_node_take_array:
+ * @node: a #JsonNode
+ * @array: (transfer full): a #JsonArray
+ *
+ * Sets @array into @node without increasing the #JsonArray reference count.
+ */
+void
+json_node_take_array (JsonNode  *node,
+                      JsonArray *array)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_ARRAY);
+
+  if (node->data.array)
+    {
+      json_array_unref (node->data.array);
+      node->data.array = NULL;
+    }
+
+  if (array)
+    node->data.array = array;
+}
+
+/**
+ * json_node_get_array:
+ * @node: a #JsonNode
+ *
+ * Retrieves the #JsonArray stored inside a #JsonNode
+ *
+ * Return value: (transfer none): the #JsonArray
+ */
+JsonArray *
+json_node_get_array (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_ARRAY, NULL);
+
+  return node->data.array;
+}
+
+/**
+ * json_node_dup_array
+ * @node: a #JsonNode
+ *
+ * Retrieves the #JsonArray stored inside a #JsonNode and returns it
+ * with its reference count increased by one.
+ *
+ * Return value: (transfer full): the #JsonArray with its reference
+ *   count increased.
+ */
+JsonArray *
+json_node_dup_array (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_ARRAY, NULL);
+
+  if (node->data.array)
+    return json_array_ref (node->data.array);
+
+  return NULL;
+}
+
+/**
+ * json_node_get_value:
+ * @node: a #JsonNode
+ * @value: (out caller-allocates): return location for an uninitialized value
+ *
+ * Retrieves a value from a #JsonNode and copies into @value. When done
+ * using it, call g_value_unset() on the #GValue.
+ */
+void
+json_node_get_value (JsonNode *node,
+                     GValue   *value)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE);
+
+  if (G_VALUE_TYPE (&(node->data.value)) != G_TYPE_INVALID)
+    {
+      g_value_init (value, G_VALUE_TYPE (&(node->data.value)));
+      g_value_copy (&(node->data.value), value);
+    }
+}
+
+static void inline
+node_value_unset (JsonNode *node)
+{
+  if (G_VALUE_TYPE (&(node->data.value)) != G_TYPE_INVALID)
+    g_value_unset (&(node->data.value));
+}
+
+/**
+ * json_node_set_value:
+ * @node: a #JsonNode
+ * @value: the #GValue to set
+ *
+ * Sets @value inside @node. The passed #GValue is copied into the #JsonNode
+ */
+void
+json_node_set_value (JsonNode     *node,
+                     const GValue *value)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE);
+  g_return_if_fail (G_VALUE_TYPE (value) != G_TYPE_INVALID);
+
+  switch (G_VALUE_TYPE (value))
+    {
+    /* direct copy for the types we use */
+    case G_TYPE_INT64:
+    case G_TYPE_BOOLEAN:
+    case G_TYPE_DOUBLE:
+    case G_TYPE_STRING:
+      node_value_unset (node);
+      g_value_init (&(node->data.value), G_VALUE_TYPE (value));
+      g_value_copy (value, &(node->data.value));
+      break;
+
+    /* auto-promote ints to long longs */
+    case G_TYPE_INT:
+      node_value_unset (node);
+      g_value_init (&(node->data.value), G_TYPE_INT64);
+      g_value_set_int64 (&(node->data.value),
+                         g_value_get_int (value));
+      break;
+
+    /* auto-promote single precision to double precision */
+    case G_TYPE_FLOAT:
+      node_value_unset (node);
+      g_value_init (&(node->data.value), G_TYPE_DOUBLE);
+      g_value_set_double (&(node->data.value),
+                          g_value_get_float (value));
+      break;
+
+    default:
+      g_warning ("Invalid value of type '%s'",
+                 g_type_name (G_VALUE_TYPE (value)));
+      return;
+    }
+
+}
+
+/**
+ * json_node_free:
+ * @node: a #JsonNode
+ *
+ * Frees the resources allocated by @node.
+ */
+void
+json_node_free (JsonNode *node)
+{
+  if (G_LIKELY (node))
+    {
+      switch (node->type)
+        {
+        case JSON_NODE_OBJECT:
+          if (node->data.object)
+            json_object_unref (node->data.object);
+          break;
+
+        case JSON_NODE_ARRAY:
+          if (node->data.array)
+            json_array_unref (node->data.array);
+          break;
+
+        case JSON_NODE_VALUE:
+          g_value_unset (&(node->data.value));
+          break;
+
+        case JSON_NODE_NULL:
+          break;
+        }
+
+      g_slice_free (JsonNode, node);
+    }
+}
+
+/**
+ * json_node_type_name:
+ * @node: a #JsonNode
+ *
+ * Retrieves the user readable name of the data type contained by @node.
+ *
+ * Return value: a string containing the name of the type. The returned string
+ *   is owned by the node and should never be modified or freed
+ */
+G_CONST_RETURN gchar *
+json_node_type_name (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, "(null)");
+
+  switch (node->type)
+    {
+    case JSON_NODE_OBJECT:
+    case JSON_NODE_ARRAY:
+    case JSON_NODE_NULL:
+      return json_node_type_get_name (node->type);
+
+    case JSON_NODE_VALUE:
+      return g_type_name (G_VALUE_TYPE (&(node->data.value)));
+    }
+
+  return "unknown";
+}
+
+G_CONST_RETURN gchar *
+json_node_type_get_name (JsonNodeType node_type)
+{
+  switch (node_type)
+    {
+    case JSON_NODE_OBJECT:
+      return "JsonObject";
+
+    case JSON_NODE_ARRAY:
+      return "JsonArray";
+
+    case JSON_NODE_NULL:
+      return "NULL";
+
+    case JSON_NODE_VALUE:
+      return "Value";
+
+    default:
+      g_assert_not_reached ();
+      break;
+    }
+
+  return "unknown";
+}
+
+/**
+ * json_node_set_parent:
+ * @node: a #JsonNode
+ * @parent: (transfer none): the parent #JsonNode of @node
+ *
+ * Sets the parent #JsonNode of @node
+ *
+ * Since: 0.8
+ */
+void
+json_node_set_parent (JsonNode *node,
+                      JsonNode *parent)
+{
+  g_return_if_fail (node != NULL);
+
+  node->parent = parent;
+}
+
+/**
+ * json_node_get_parent:
+ * @node: a #JsonNode
+ *
+ * Retrieves the parent #JsonNode of @node.
+ *
+ * Return value: (transfer none): the parent node, or %NULL if @node is
+ *   the root node
+ */
+JsonNode *
+json_node_get_parent (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, NULL);
+
+  return node->parent;
+}
+
+/**
+ * json_node_set_string:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ * @value: a string value
+ *
+ * Sets @value as the string content of the @node, replacing any existing
+ * content.
+ */
+void
+json_node_set_string (JsonNode    *node,
+                      const gchar *value)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE);
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_STRING)
+    g_value_set_string (&(node->data.value), value);
+  else
+    {
+      GValue copy = { 0, };
+
+      g_value_init (&copy, G_TYPE_STRING);
+      g_value_set_string (&copy, value);
+
+      json_node_set_value (node, &copy);
+
+      g_value_unset (&copy);
+    }
+}
+
+/**
+ * json_node_get_string:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ *
+ * Gets the string value stored inside a #JsonNode
+ *
+ * Return value: a string value.
+ */
+G_CONST_RETURN gchar *
+json_node_get_string (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, NULL);
+
+  if (JSON_NODE_TYPE (node) == JSON_NODE_NULL)
+    return NULL;
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_STRING)
+    return g_value_get_string (&(node->data.value));
+
+  return NULL;
+}
+
+/**
+ * json_node_dup_string:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ *
+ * Gets a copy of the string value stored inside a #JsonNode
+ *
+ * Return value: (transfer full): a newly allocated string containing a copy
+ *   of the #JsonNode contents. Use g_free() to free the allocated resources
+ */
+gchar *
+json_node_dup_string (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, NULL);
+
+  if (JSON_NODE_TYPE (node) == JSON_NODE_NULL)
+    return NULL;
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_STRING)
+    return g_value_dup_string (&(node->data.value));
+
+  return NULL;
+}
+
+/**
+ * json_node_set_int:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ * @value: an integer value
+ *
+ * Sets @value as the integer content of the @node, replacing any existing
+ * content.
+ */
+void
+json_node_set_int (JsonNode *node,
+                   gint64    value)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE);
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_INT64)
+    g_value_set_int64 (&(node->data.value), value);
+  else
+    {
+      GValue copy = { 0, };
+
+      g_value_init (&copy, G_TYPE_INT64);
+      g_value_set_int64 (&copy, value);
+
+      json_node_set_value (node, &copy);
+
+      g_value_unset (&copy);
+    }
+}
+
+/**
+ * json_node_get_int:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ *
+ * Gets the integer value stored inside a #JsonNode
+ *
+ * Return value: an integer value.
+ */
+gint64
+json_node_get_int (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, 0);
+
+  if (JSON_NODE_TYPE (node) == JSON_NODE_NULL)
+    return 0;
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_INT64)
+    return g_value_get_int64 (&(node->data.value));
+
+  return 0;
+}
+
+/**
+ * json_node_set_double:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ * @value: a double value
+ *
+ * Sets @value as the double content of the @node, replacing any existing
+ * content.
+ */
+void
+json_node_set_double (JsonNode *node,
+                      gdouble   value)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE);
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_DOUBLE)
+    g_value_set_double (&(node->data.value), value);
+  else
+    {
+      GValue copy = { 0, };
+
+      g_value_init (&copy, G_TYPE_DOUBLE);
+      g_value_set_double (&copy, value);
+
+      json_node_set_value (node, &copy);
+
+      g_value_unset (&copy);
+    }
+}
+
+/**
+ * json_node_get_double:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ *
+ * Gets the double value stored inside a #JsonNode
+ *
+ * Return value: a double value.
+ */
+gdouble
+json_node_get_double (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, 0.0);
+
+  if (JSON_NODE_TYPE (node) == JSON_NODE_NULL)
+    return 0;
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_DOUBLE)
+    return g_value_get_double (&(node->data.value));
+
+  return 0.0;
+}
+
+/**
+ * json_node_set_boolean:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ * @value: a boolean value
+ *
+ * Sets @value as the boolean content of the @node, replacing any existing
+ * content.
+ */
+void
+json_node_set_boolean (JsonNode *node,
+                       gboolean  value)
+{
+  g_return_if_fail (node != NULL);
+  g_return_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE);
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_BOOLEAN)
+    g_value_set_boolean (&(node->data.value), value);
+  else
+    {
+      GValue copy = { 0, };
+
+      g_value_init (&copy, G_TYPE_BOOLEAN);
+      g_value_set_boolean (&copy, value);
+
+      json_node_set_value (node, &copy);
+
+      g_value_unset (&copy);
+    }
+}
+
+/**
+ * json_node_get_boolean:
+ * @node: a #JsonNode of type %JSON_NODE_VALUE
+ *
+ * Gets the boolean value stored inside a #JsonNode
+ *
+ * Return value: a boolean value.
+ */
+gboolean
+json_node_get_boolean (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, FALSE);
+
+  if (JSON_NODE_TYPE (node) == JSON_NODE_NULL)
+    return FALSE;
+
+  if (G_VALUE_TYPE (&(node->data.value)) == G_TYPE_BOOLEAN)
+    return g_value_get_boolean (&(node->data.value));
+
+  return FALSE;
+}
+
+/**
+ * json_node_get_node_type:
+ * @node: a #JsonNode
+ *
+ * Retrieves the #JsonNodeType of @node
+ *
+ * Return value: the type of the node
+ *
+ * Since: 0.8
+ */
+JsonNodeType
+json_node_get_node_type (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, JSON_NODE_NULL);
+
+  return node->type;
+}
+
+/**
+ * json_node_is_null:
+ * @node: a #JsonNode
+ *
+ * Checks whether @node is a %JSON_NODE_NULL
+ *
+ * <note>A null node is not the same as a %NULL #JsonNode</note>
+ *
+ * Return value: %TRUE if the node is null
+ *
+ * Since: 0.8
+ */
+gboolean
+json_node_is_null (JsonNode *node)
+{
+  g_return_val_if_fail (node != NULL, TRUE);
+
+  return node->type == JSON_NODE_NULL;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-object.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-object.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-object.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-object.c	2011-03-27 09:15:30.764553000 -0600
@@ -0,0 +1,868 @@
+/* json-object.c - JSON object implementation
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include <glib.h>
+
+#include "json-types-private.h"
+
+/**
+ * SECTION:json-object
+ * @short_description: a JSON object representation
+ *
+ * #JsonArray is the representation of the object type inside JSON. It contains
+ * #JsonNode<!-- -->s, which may contain fundamental types, arrays or other
+ * objects. Each member of an object is accessed using its name.
+ *
+ * Since objects can be expensive, they are reference counted. You can control
+ * the lifetime of a #JsonObject using json_object_ref() and json_object_unref().
+ *
+ * To add or overwrite a member with a given name, use json_object_set_member().
+ * To extract a member with a given name, use json_object_get_member().
+ * To retrieve the list of members, use json_object_get_members().
+ * To retrieve the size of the object (that is, the number of members it has),
+ * use json_object_get_size().
+ */
+
+G_DEFINE_BOXED_TYPE (JsonObject, json_object, json_object_ref, json_object_unref);
+
+/**
+ * json_object_new:
+ * 
+ * Creates a new #JsonObject, an JSON object type representation.
+ *
+ * Return value: the newly created #JsonObject
+ */
+JsonObject *
+json_object_new (void)
+{
+  JsonObject *object;
+
+  object = g_slice_new (JsonObject);
+  
+  object->ref_count = 1;
+  object->members = g_hash_table_new_full (g_str_hash, g_str_equal,
+                                           g_free,
+                                           (GDestroyNotify) json_node_free);
+  object->members_ordered = NULL;
+
+  return object;
+}
+
+/**
+ * json_object_ref:
+ * @object: a #JsonObject
+ *
+ * Increase by one the reference count of a #JsonObject.
+ *
+ * Return value: the passed #JsonObject, with the reference count
+ *   increased by one.
+ */
+JsonObject *
+json_object_ref (JsonObject *object)
+{
+  g_return_val_if_fail (object != NULL, NULL);
+  g_return_val_if_fail (object->ref_count > 0, NULL);
+
+  g_atomic_int_exchange_and_add (&object->ref_count, 1);
+
+  return object;
+}
+
+/**
+ * json_object_unref:
+ * @object: a #JsonObject
+ *
+ * Decreases by one the reference count of a #JsonObject. If the
+ * reference count reaches zero, the object is destroyed and all
+ * its allocated resources are freed.
+ */
+void
+json_object_unref (JsonObject *object)
+{
+  gint old_ref;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (object->ref_count > 0);
+
+  old_ref = g_atomic_int_get (&object->ref_count);
+  if (old_ref > 1)
+    g_atomic_int_compare_and_exchange (&object->ref_count, old_ref, old_ref - 1);
+  else
+    {
+      g_list_free (object->members_ordered);
+      g_hash_table_destroy (object->members);
+      object->members_ordered = NULL;
+      object->members = NULL;
+
+      g_slice_free (JsonObject, object);
+    }
+}
+
+static inline void
+object_set_member_internal (JsonObject  *object,
+                            const gchar *member_name,
+                            JsonNode    *node)
+{
+  gchar *name = g_strdup (member_name);
+
+  if (g_hash_table_lookup (object->members, name) == NULL)
+    object->members_ordered = g_list_prepend (object->members_ordered, name);
+  else
+    {
+      GList *l;
+
+      /* if the member already exists then we need to replace the
+       * pointer to its name, to avoid keeping invalid pointers
+       * once we replace the key in the hash table
+       */
+      for (l = object->members_ordered; l != NULL; l =  l->next)
+        {
+          gchar *tmp = l->data;
+
+          if (strcmp (tmp, name) == 0)
+            {
+              l->data = name;
+              break;
+            }
+        }
+    }
+
+  g_hash_table_replace (object->members, name, node);
+}
+
+/**
+ * json_object_add_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ * @node: (transfer full): the value of the member
+ *
+ * Adds a member named @member_name and containing @node into a #JsonObject.
+ * The object will take ownership of the #JsonNode.
+ *
+ * This function will return if the @object already contains a member
+ * @member_name.
+ *
+ * Deprecated: 0.8: Use json_object_set_member() instead
+ */
+void
+json_object_add_member (JsonObject  *object,
+                        const gchar *member_name,
+                        JsonNode    *node)
+{
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+  g_return_if_fail (node != NULL);
+
+  if (json_object_has_member (object, member_name))
+    {
+      g_warning ("JsonObject already has a `%s' member of type `%s'",
+                 member_name,
+                 json_node_type_name (node));
+      return;
+    }
+
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_set_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ * @node: (transfer full): the value of the member
+ *
+ * Sets @node as the value of @member_name inside @object.
+ *
+ * If @object already contains a member called @member_name then
+ * the member's current value is overwritten. Otherwise, a new
+ * member is added to @object.
+ *
+ * Since: 0.8
+ */
+void
+json_object_set_member (JsonObject  *object,
+                        const gchar *member_name,
+                        JsonNode    *node)
+{
+  JsonNode *old_node;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+  g_return_if_fail (node != NULL);
+
+  old_node = g_hash_table_lookup (object->members, member_name);
+  if (old_node == NULL)
+    goto set_member;
+
+  if (old_node == node)
+    return;
+
+set_member:
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_set_int_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ * @value: the value of the member
+ *
+ * Convenience function for setting an integer @value of
+ * @member_name inside @object.
+ *
+ * See also: json_object_set_member()
+ *
+ * Since: 0.8
+ */
+void
+json_object_set_int_member (JsonObject  *object,
+                            const gchar *member_name,
+                            gint64       value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+
+  node = json_node_new (JSON_NODE_VALUE);
+  json_node_set_int (node, value);
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_set_double_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ * @value: the value of the member
+ *
+ * Convenience function for setting a floating point @value
+ * of @member_name inside @object.
+ *
+ * See also: json_object_set_member()
+ *
+ * Since: 0.8
+ */
+void
+json_object_set_double_member (JsonObject  *object,
+                               const gchar *member_name,
+                               gdouble      value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+
+  node = json_node_new (JSON_NODE_VALUE);
+  json_node_set_double (node, value);
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_set_boolean_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ * @value: the value of the member
+ *
+ * Convenience function for setting a boolean @value of
+ * @member_name inside @object.
+ *
+ * See also: json_object_set_member()
+ *
+ * Since: 0.8
+ */
+void
+json_object_set_boolean_member (JsonObject  *object,
+                                const gchar *member_name,
+                                gboolean     value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+
+  node = json_node_new (JSON_NODE_VALUE);
+  json_node_set_boolean (node, value);
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_set_string_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ * @value: the value of the member
+ *
+ * Convenience function for setting a string @value of
+ * @member_name inside @object.
+ *
+ * See also: json_object_set_member()
+ *
+ * Since: 0.8
+ */
+void
+json_object_set_string_member (JsonObject  *object,
+                               const gchar *member_name,
+                               const gchar *value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+
+  if (value != NULL)
+    {
+      node = json_node_new (JSON_NODE_VALUE);
+      json_node_set_string (node, value);
+    }
+  else
+    node = json_node_new (JSON_NODE_NULL);
+
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_set_null_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ *
+ * Convenience function for setting a null @value of
+ * @member_name inside @object.
+ *
+ * See also: json_object_set_member()
+ *
+ * Since: 0.8
+ */
+void
+json_object_set_null_member (JsonObject  *object,
+                             const gchar *member_name)
+{
+  JsonNode *node;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+
+  node = json_node_new (JSON_NODE_NULL);
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_set_array_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ * @value: (transfer full): the value of the member
+ *
+ * Convenience function for setting an array @value of
+ * @member_name inside @object.
+ *
+ * The @object will take ownership of the passed #JsonArray
+ *
+ * See also: json_object_set_member()
+ *
+ * Since: 0.8
+ */
+void
+json_object_set_array_member (JsonObject  *object,
+                              const gchar *member_name,
+                              JsonArray   *value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+
+  if (value != NULL)
+    {
+      node = json_node_new (JSON_NODE_ARRAY);
+      json_node_take_array (node, value);
+    }
+  else
+    node = json_node_new (JSON_NODE_NULL);
+
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_set_object_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ * @value: (transfer full): the value of the member
+ *
+ * Convenience function for setting an object @value of
+ * @member_name inside @object.
+ *
+ * The @object will take ownership of the passed #JsonObject
+ *
+ * See also: json_object_set_member()
+ *
+ * Since: 0.8
+ */
+void
+json_object_set_object_member (JsonObject  *object,
+                               const gchar *member_name,
+                               JsonObject  *value)
+{
+  JsonNode *node;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+
+  if (value != NULL)
+    {
+      node = json_node_new (JSON_NODE_OBJECT);
+      json_node_take_object (node, value);
+    }
+  else
+    node = json_node_new (JSON_NODE_NULL);
+
+  object_set_member_internal (object, member_name, node);
+}
+
+/**
+ * json_object_get_members:
+ * @object: a #JsonObject
+ *
+ * Retrieves all the names of the members of a #JsonObject. You can
+ * obtain the value for each member using json_object_get_member().
+ *
+ * Return value: (element-type utf8) (transfer container): a #GList
+ *   of member names. The content of the list is owned by the #JsonObject
+ *   and should never be modified or freed. When you have finished using
+ *   the returned list, use g_list_free() to free the resources it has
+ *   allocated.
+ */
+GList *
+json_object_get_members (JsonObject *object)
+{
+  GList *copy;
+
+  g_return_val_if_fail (object != NULL, NULL);
+
+  copy = g_list_copy (object->members_ordered);
+
+  return g_list_reverse (copy);
+}
+
+/**
+ * json_object_get_values:
+ * @object: a #JsonObject
+ *
+ * Retrieves all the values of the members of a #JsonObject.
+ *
+ * Return value: (element-type JsonNode) (transfer container): a #GList of
+ *   #JsonNode<!-- -->s. The content of the list is owned by the #JsonObject
+ *   and should never be modified or freed. When you have finished using the
+ *   returned list, use g_list_free() to free the resources it has allocated.
+ */
+GList *
+json_object_get_values (JsonObject *object)
+{
+  GList *values, *l;
+
+  g_return_val_if_fail (object != NULL, NULL);
+
+  values = NULL;
+  for (l = object->members_ordered; l != NULL; l = l->next)
+    values = g_list_prepend (values, g_hash_table_lookup (object->members, l->data));
+
+  return values;
+}
+
+/**
+ * json_object_dup_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the JSON object member to access
+ *
+ * Retrieves a copy of the #JsonNode containing the value of @member_name
+ * inside a #JsonObject
+ *
+ * Return value: (transfer full): a copy of the node for the requested
+ *   object member or %NULL. Use json_node_free() when done.
+ *
+ * Since: 0.6
+ */
+JsonNode *
+json_object_dup_member (JsonObject  *object,
+                        const gchar *member_name)
+{
+  JsonNode *retval;
+
+  g_return_val_if_fail (object != NULL, NULL);
+  g_return_val_if_fail (member_name != NULL, NULL);
+
+  retval = json_object_get_member (object, member_name);
+  if (!retval)
+    return NULL;
+
+  return json_node_copy (retval);
+}
+
+static inline JsonNode *
+object_get_member_internal (JsonObject  *object,
+                            const gchar *member_name)
+{
+  return g_hash_table_lookup (object->members, member_name);
+}
+
+/**
+ * json_object_get_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the JSON object member to access
+ *
+ * Retrieves the #JsonNode containing the value of @member_name inside
+ * a #JsonObject.
+ *
+ * Return value: (transfer none): a pointer to the node for the requested object
+ *   member, or %NULL
+ */
+JsonNode *
+json_object_get_member (JsonObject  *object,
+                        const gchar *member_name)
+{
+  g_return_val_if_fail (object != NULL, NULL);
+  g_return_val_if_fail (member_name != NULL, NULL);
+
+  return object_get_member_internal (object, member_name);
+}
+
+/**
+ * json_object_get_int_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ *
+ * Convenience function that retrieves the integer value
+ * stored in @member_name of @object
+ *
+ * See also: json_object_get_member()
+ *
+ * Return value: the integer value of the object's member
+ *
+ * Since: 0.8
+ */
+gint64
+json_object_get_int_member (JsonObject  *object,
+                            const gchar *member_name)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (object != NULL, 0);
+  g_return_val_if_fail (member_name != NULL, 0);
+
+  node = object_get_member_internal (object, member_name);
+  g_return_val_if_fail (node != NULL, 0);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE, 0);
+
+  return json_node_get_int (node);
+}
+
+/**
+ * json_object_get_double_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ *
+ * Convenience function that retrieves the floating point value
+ * stored in @member_name of @object
+ *
+ * See also: json_object_get_member()
+ *
+ * Return value: the floating point value of the object's member
+ *
+ * Since: 0.8
+ */
+gdouble
+json_object_get_double_member (JsonObject  *object,
+                               const gchar *member_name)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (object != NULL, 0.0);
+  g_return_val_if_fail (member_name != NULL, 0.0);
+
+  node = object_get_member_internal (object, member_name);
+  g_return_val_if_fail (node != NULL, 0.0);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE, 0.0);
+
+  return json_node_get_double (node);
+}
+
+/**
+ * json_object_get_boolean_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ *
+ * Convenience function that retrieves the boolean value
+ * stored in @member_name of @object
+ *
+ * See also: json_object_get_member()
+ *
+ * Return value: the boolean value of the object's member
+ *
+ * Since: 0.8
+ */
+gboolean
+json_object_get_boolean_member (JsonObject  *object,
+                                const gchar *member_name)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (object != NULL, FALSE);
+  g_return_val_if_fail (member_name != NULL, FALSE);
+
+  node = object_get_member_internal (object, member_name);
+  g_return_val_if_fail (node != NULL, FALSE);
+  g_return_val_if_fail (JSON_NODE_TYPE (node) == JSON_NODE_VALUE, FALSE);
+
+  return json_node_get_boolean (node);
+}
+
+/**
+ * json_object_get_null_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ *
+ * Convenience function that checks whether the value
+ * stored in @member_name of @object is null
+ *
+ * See also: json_object_get_member()
+ *
+ * Return value: %TRUE if the value is null
+ *
+ * Since: 0.8
+ */
+gboolean
+json_object_get_null_member (JsonObject  *object,
+                             const gchar *member_name)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (object != NULL, FALSE);
+  g_return_val_if_fail (member_name != NULL, FALSE);
+
+  node = object_get_member_internal (object, member_name);
+  g_return_val_if_fail (node != NULL, FALSE);
+
+  return JSON_NODE_TYPE (node) == JSON_NODE_NULL;
+}
+
+/**
+ * json_object_get_string_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ *
+ * Convenience function that retrieves the string value
+ * stored in @member_name of @object
+ *
+ * See also: json_object_get_member()
+ *
+ * Return value: the string value of the object's member
+ *
+ * Since: 0.8
+ */
+G_CONST_RETURN gchar *
+json_object_get_string_member (JsonObject  *object,
+                               const gchar *member_name)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (object != NULL, NULL);
+  g_return_val_if_fail (member_name != NULL, NULL);
+
+  node = object_get_member_internal (object, member_name);
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_HOLDS_VALUE (node) || JSON_NODE_HOLDS_NULL (node), NULL);
+
+  if (JSON_NODE_HOLDS_NULL (node))
+    return NULL;
+
+  return json_node_get_string (node);
+}
+
+/**
+ * json_object_get_array_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ *
+ * Convenience function that retrieves the array
+ * stored in @member_name of @object
+ *
+ * See also: json_object_get_member()
+ *
+ * Return value: (transfer none): the array inside the object's member
+ *
+ * Since: 0.8
+ */
+JsonArray *
+json_object_get_array_member (JsonObject  *object,
+                              const gchar *member_name)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (object != NULL, NULL);
+  g_return_val_if_fail (member_name != NULL, NULL);
+
+  node = object_get_member_internal (object, member_name);
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_HOLDS_ARRAY (node) || JSON_NODE_HOLDS_NULL (node), NULL);
+
+  if (JSON_NODE_HOLDS_NULL (node))
+    return NULL;
+
+  return json_node_get_array (node);
+}
+
+/**
+ * json_object_get_object_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member
+ *
+ * Convenience function that retrieves the object
+ * stored in @member_name of @object
+ *
+ * See also: json_object_get_member()
+ *
+ * Return value: (transfer none): the object inside the object's member
+ *
+ * Since: 0.8
+ */
+JsonObject *
+json_object_get_object_member (JsonObject  *object,
+                               const gchar *member_name)
+{
+  JsonNode *node;
+
+  g_return_val_if_fail (object != NULL, NULL);
+  g_return_val_if_fail (member_name != NULL, NULL);
+
+  node = object_get_member_internal (object, member_name);
+  g_return_val_if_fail (node != NULL, NULL);
+  g_return_val_if_fail (JSON_NODE_HOLDS_OBJECT (node) || JSON_NODE_HOLDS_NULL (node), NULL);
+
+  if (JSON_NODE_HOLDS_NULL (node))
+    return NULL;
+
+  return json_node_get_object (node);
+}
+
+/**
+ * json_object_has_member:
+ * @object: a #JsonObject
+ * @member_name: the name of a JSON object member
+ *
+ * Checks whether @object has a member named @member_name.
+ *
+ * Return value: %TRUE if the JSON object has the requested member
+ */
+gboolean
+json_object_has_member (JsonObject *object,
+                        const gchar *member_name)
+{
+  g_return_val_if_fail (object != NULL, FALSE);
+  g_return_val_if_fail (member_name != NULL, FALSE);
+
+  return (g_hash_table_lookup (object->members, member_name) != NULL);
+}
+
+/**
+ * json_object_get_size:
+ * @object: a #JsonObject
+ *
+ * Retrieves the number of members of a #JsonObject.
+ *
+ * Return value: the number of members
+ */
+guint
+json_object_get_size (JsonObject *object)
+{
+  g_return_val_if_fail (object != NULL, 0);
+
+  return g_hash_table_size (object->members);
+}
+
+/**
+ * json_object_remove_member:
+ * @object: a #JsonObject
+ * @member_name: the name of the member to remove
+ *
+ * Removes @member_name from @object, freeing its allocated resources.
+ */
+void
+json_object_remove_member (JsonObject  *object,
+                           const gchar *member_name)
+{
+  GList *l;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (member_name != NULL);
+
+  for (l = object->members_ordered; l != NULL; l = l->next)
+    {
+      const gchar *name = l->data;
+
+      if (g_strcmp0 (name, member_name) == 0)
+        {
+          object->members_ordered = g_list_delete_link (object->members_ordered, l);
+          break;
+        }
+    }
+
+  g_hash_table_remove (object->members, member_name);
+}
+
+/**
+ * json_object_foreach_member:
+ * @object: a #JsonObject
+ * @func: (scope call): the function to be called on each member
+ * @data: (closure): data to be passed to the function
+ *
+ * Iterates over all members of @object and calls @func on
+ * each one of them.
+ *
+ * It is safe to change the value of a #JsonNode of the @object
+ * from within the iterator @func, but it is not safe to add or
+ * remove members from the @object.
+ *
+ * Since: 0.8
+ */
+void
+json_object_foreach_member (JsonObject        *object,
+                            JsonObjectForeach  func,
+                            gpointer           data)
+{
+  GList *members, *l;
+
+  g_return_if_fail (object != NULL);
+  g_return_if_fail (func != NULL);
+
+  /* the list is stored in reverse order to have constant time additions */
+  members = g_list_last (object->members_ordered);
+  for (l = members; l != NULL; l = l->prev)
+    {
+      const gchar *member_name = l->data;
+      JsonNode *member_node = g_hash_table_lookup (object->members, member_name);
+
+      func (object, member_name, member_node, data);
+    }
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-parser.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-parser.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-parser.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-parser.c	2011-03-27 09:15:30.820553000 -0600
@@ -0,0 +1,1425 @@
+/* json-parser.c - JSON streams parser
+ * 
+ * This file is part of JSON-GLib
+ *
+ * Copyright  2007, 2008, 2009 OpenedHand Ltd
+ * Copyright  2009, 2010 Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+/**
+ * SECTION:json-parser
+ * @short_description: Parse JSON data streams
+ *
+ * #JsonParser provides an object for parsing a JSON data stream, either
+ * inside a file or inside a static buffer.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "json-types-private.h"
+
+#include "json-debug.h"
+#include "json-marshal.h"
+#include "json-parser.h"
+#include "json-scanner.h"
+
+GQuark
+json_parser_error_quark (void)
+{
+  return g_quark_from_static_string ("json-parser-error");
+}
+
+#define JSON_PARSER_GET_PRIVATE(obj) (G_TYPE_INSTANCE_GET_PRIVATE ((obj), JSON_TYPE_PARSER, JsonParserPrivate))
+
+struct _JsonParserPrivate
+{
+  JsonNode *root;
+  JsonNode *current_node;
+
+  JsonScanner *scanner;
+
+  JsonParserError error_code;
+  GError *last_error;
+
+  gchar *variable_name;
+  gchar *filename;
+
+  guint has_assignment : 1;
+  guint is_filename    : 1;
+};
+
+static const gchar symbol_names[] =
+  "true\0"
+  "false\0"
+  "null\0"
+  "var\0";
+
+static const struct
+{
+  guint name_offset;
+  guint token;
+} symbols[] = {
+  {  0, JSON_TOKEN_TRUE  },
+  {  5, JSON_TOKEN_FALSE },
+  { 11, JSON_TOKEN_NULL  },
+  { 16, JSON_TOKEN_VAR   }
+};
+
+static const guint n_symbols = G_N_ELEMENTS (symbols);
+
+enum
+{
+  PARSE_START,
+  OBJECT_START,
+  OBJECT_MEMBER,
+  OBJECT_END,
+  ARRAY_START,
+  ARRAY_ELEMENT,
+  ARRAY_END,
+  PARSE_END,
+  ERROR,
+
+  LAST_SIGNAL
+};
+
+static guint parser_signals[LAST_SIGNAL] = { 0, };
+
+G_DEFINE_TYPE (JsonParser, json_parser, G_TYPE_OBJECT);
+
+static guint json_parse_array  (JsonParser   *parser,
+                                JsonScanner  *scanner,
+                                JsonNode    **node);
+static guint json_parse_object (JsonParser   *parser,
+                                JsonScanner  *scanner,
+                                JsonNode    **node);
+
+static inline void
+json_parser_clear (JsonParser *parser)
+{
+  JsonParserPrivate *priv = parser->priv;
+
+  g_free (priv->variable_name);
+  priv->variable_name = NULL;
+
+  if (priv->last_error)
+    {
+      g_error_free (priv->last_error);
+      priv->last_error = NULL;
+    }
+
+  if (priv->root)
+    {
+      json_node_free (priv->root);
+      priv->root = NULL;
+    }
+}
+
+static void
+json_parser_dispose (GObject *gobject)
+{
+  json_parser_clear (JSON_PARSER (gobject));
+
+  G_OBJECT_CLASS (json_parser_parent_class)->dispose (gobject);
+}
+
+static void
+json_parser_finalize (GObject *gobject)
+{
+  JsonParserPrivate *priv = JSON_PARSER (gobject)->priv;
+
+  g_free (priv->variable_name);
+  g_free (priv->filename);
+
+  G_OBJECT_CLASS (json_parser_parent_class)->finalize (gobject);
+}
+
+static void
+json_parser_class_init (JsonParserClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (JsonParserPrivate));
+
+  gobject_class->dispose = json_parser_dispose;
+  gobject_class->finalize = json_parser_finalize;
+
+  /**
+   * JsonParser::parse-start:
+   * @parser: the #JsonParser that received the signal
+   * 
+   * The ::parse-start signal is emitted when the parser began parsing
+   * a JSON data stream.
+   */
+  parser_signals[PARSE_START] =
+    g_signal_new ("parse-start",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, parse_start),
+                  NULL, NULL,
+                  _json_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+  /**
+   * JsonParser::parse-end:
+   * @parser: the #JsonParser that received the signal
+   *
+   * The ::parse-end signal is emitted when the parser successfully
+   * finished parsing a JSON data stream
+   */
+  parser_signals[PARSE_END] =
+    g_signal_new ("parse-end",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, parse_end),
+                  NULL, NULL,
+                  _json_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+  /**
+   * JsonParser::object-start:
+   * @parser: the #JsonParser that received the signal
+   * 
+   * The ::object-start signal is emitted each time the #JsonParser
+   * starts parsing a #JsonObject.
+   */
+  parser_signals[OBJECT_START] =
+    g_signal_new ("object-start",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, object_start),
+                  NULL, NULL,
+                  _json_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+  /**
+   * JsonParser::object-member:
+   * @parser: the #JsonParser that received the signal
+   * @object: a #JsonObject
+   * @member_name: the name of the newly parsed member
+   *
+   * The ::object-member signal is emitted each time the #JsonParser
+   * has successfully parsed a single member of a #JsonObject. The
+   * object and member are passed to the signal handlers.
+   */
+  parser_signals[OBJECT_MEMBER] =
+    g_signal_new ("object-member",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, object_member),
+                  NULL, NULL,
+                  _json_marshal_VOID__BOXED_STRING,
+                  G_TYPE_NONE, 2,
+                  JSON_TYPE_OBJECT,
+                  G_TYPE_STRING);
+  /**
+   * JsonParser::object-end:
+   * @parser: the #JsonParser that received the signal
+   * @object: the parsed #JsonObject
+   *
+   * The ::object-end signal is emitted each time the #JsonParser
+   * has successfully parsed an entire #JsonObject.
+   */
+  parser_signals[OBJECT_END] =
+    g_signal_new ("object-end",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, object_end),
+                  NULL, NULL,
+                  _json_marshal_VOID__BOXED,
+                  G_TYPE_NONE, 1,
+                  JSON_TYPE_OBJECT);
+  /**
+   * JsonParser::array-start:
+   * @parser: the #JsonParser that received the signal
+   *
+   * The ::array-start signal is emitted each time the #JsonParser
+   * starts parsing a #JsonArray
+   */
+  parser_signals[ARRAY_START] =
+    g_signal_new ("array-start",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, array_start),
+                  NULL, NULL,
+                  _json_marshal_VOID__VOID,
+                  G_TYPE_NONE, 0);
+  /**
+   * JsonParser::array-element:
+   * @parser: the #JsonParser that received the signal
+   * @array: a #JsonArray
+   * @index_: the index of the newly parsed element
+   *
+   * The ::array-element signal is emitted each time the #JsonParser
+   * has successfully parsed a single element of a #JsonArray. The
+   * array and element index are passed to the signal handlers.
+   */
+  parser_signals[ARRAY_ELEMENT] =
+    g_signal_new ("array-element",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, array_element),
+                  NULL, NULL,
+                  _json_marshal_VOID__BOXED_INT,
+                  G_TYPE_NONE, 2,
+                  JSON_TYPE_ARRAY,
+                  G_TYPE_INT);
+  /**
+   * JsonParser::array-end:
+   * @parser: the #JsonParser that received the signal
+   * @array: the parsed #JsonArray
+   *
+   * The ::array-end signal is emitted each time the #JsonParser
+   * has successfully parsed an entire #JsonArray
+   */
+  parser_signals[ARRAY_END] =
+    g_signal_new ("array-end",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, array_end),
+                  NULL, NULL,
+                  _json_marshal_VOID__BOXED,
+                  G_TYPE_NONE, 1,
+                  JSON_TYPE_ARRAY);
+  /**
+   * JsonParser::error:
+   * @parser: the parser instance that received the signal
+   * @error: a pointer to the #GError
+   *
+   * The ::error signal is emitted each time a #JsonParser encounters
+   * an error in a JSON stream.
+   */
+  parser_signals[ERROR] =
+    g_signal_new ("error",
+                  G_OBJECT_CLASS_TYPE (gobject_class),
+                  G_SIGNAL_RUN_LAST,
+                  G_STRUCT_OFFSET (JsonParserClass, error),
+                  NULL, NULL,
+                  _json_marshal_VOID__POINTER,
+                  G_TYPE_NONE, 1,
+                  G_TYPE_POINTER);
+}
+
+static void
+json_parser_init (JsonParser *parser)
+{
+  JsonParserPrivate *priv;
+
+  parser->priv = priv = JSON_PARSER_GET_PRIVATE (parser);
+
+  priv->root = NULL;
+  priv->current_node = NULL;
+
+  priv->error_code = JSON_PARSER_ERROR_PARSE;
+  priv->last_error = NULL;
+
+  priv->has_assignment = FALSE;
+  priv->variable_name = NULL;
+
+  priv->is_filename = FALSE;
+  priv->filename = FALSE;
+}
+
+static guint
+json_parse_value (JsonParser   *parser,
+                  JsonScanner  *scanner,
+                  guint         token,
+                  JsonNode    **node)
+{
+  JsonParserPrivate *priv = parser->priv;
+  JsonNode *current_node = priv->current_node;
+  gboolean is_negative = FALSE;
+
+  if (token == '-')
+    {
+      guint next_token = json_scanner_peek_next_token (scanner);
+
+      if (next_token == G_TOKEN_INT ||
+          next_token == G_TOKEN_FLOAT)
+        {
+           is_negative = TRUE;
+           token = json_scanner_get_next_token (scanner);
+        }
+      else
+        return G_TOKEN_INT;
+    }
+
+  switch (token)
+    {
+    case G_TOKEN_INT:
+      *node = json_node_new (JSON_NODE_VALUE);
+      JSON_NOTE (PARSER, "abs(node): %" G_GINT64_FORMAT " (sign: %s)",
+                 scanner->value.v_int64,
+                 is_negative ? "negative" : "positive");
+      json_node_set_int (*node, is_negative ? scanner->value.v_int64 * -1
+                                            : scanner->value.v_int64);
+      break;
+
+    case G_TOKEN_FLOAT:
+      *node = json_node_new (JSON_NODE_VALUE);
+      JSON_NOTE (PARSER, "abs(node): %.6f (sign: %s)",
+                 scanner->value.v_float,
+                 is_negative ? "negative" : "positive");
+      json_node_set_double (*node, is_negative ? scanner->value.v_float * -1.0
+                                               : scanner->value.v_float);
+      break;
+
+    case G_TOKEN_STRING:
+      *node = json_node_new (JSON_NODE_VALUE);
+      JSON_NOTE (PARSER, "node: '%s'",
+                 scanner->value.v_string);
+      json_node_set_string (*node, scanner->value.v_string);
+      break;
+
+    case JSON_TOKEN_TRUE:
+    case JSON_TOKEN_FALSE:
+      *node = json_node_new (JSON_NODE_VALUE);
+      JSON_NOTE (PARSER, "node: '%s'",
+                 JSON_TOKEN_TRUE ? "<true>" : "<false>");
+      json_node_set_boolean (*node, token == JSON_TOKEN_TRUE ? TRUE : FALSE);
+      break;
+
+    case JSON_TOKEN_NULL:
+      *node = json_node_new (JSON_NODE_NULL);
+      JSON_NOTE (PARSER, "node: <null>");
+      break;
+
+    default:
+      {
+        JsonNodeType cur_type;
+
+        *node = NULL;
+
+        cur_type = json_node_get_node_type (current_node);
+        if (cur_type == JSON_NODE_ARRAY)
+          return G_TOKEN_RIGHT_BRACE;
+        else if (cur_type == JSON_NODE_OBJECT)
+          return G_TOKEN_RIGHT_CURLY;
+        else
+          {
+            priv->error_code = JSON_PARSER_ERROR_INVALID_BAREWORD;
+            return G_TOKEN_SYMBOL;
+          }
+      }
+    }
+
+  return G_TOKEN_NONE;
+}
+
+static guint
+json_parse_array (JsonParser   *parser,
+                  JsonScanner  *scanner,
+                  JsonNode    **node)
+{
+  JsonParserPrivate *priv = parser->priv;
+  JsonNode *old_current;
+  JsonArray *array;
+  guint token;
+  gint idx;
+
+  old_current = priv->current_node;
+  priv->current_node = json_node_new (JSON_NODE_ARRAY);
+
+  array = json_array_new ();
+
+  token = json_scanner_get_next_token (scanner);
+  g_assert (token == G_TOKEN_LEFT_BRACE);
+
+  g_signal_emit (parser, parser_signals[ARRAY_START], 0);
+
+  idx = 0;
+  while (token != G_TOKEN_RIGHT_BRACE)
+    {
+      guint next_token = json_scanner_peek_next_token (scanner);
+      JsonNode *element = NULL;
+
+      /* parse the element */
+      switch (next_token)
+        {
+        case G_TOKEN_LEFT_BRACE:
+          JSON_NOTE (PARSER, "Nested array at index %d", idx);
+          token = json_parse_array (parser, scanner, &element);
+          break;
+
+        case G_TOKEN_LEFT_CURLY:
+          JSON_NOTE (PARSER, "Nested object at index %d", idx);
+          token = json_parse_object (parser, scanner, &element);
+          break;
+
+        case G_TOKEN_INT:
+        case G_TOKEN_FLOAT:
+        case G_TOKEN_STRING:
+        case '-':
+        case JSON_TOKEN_TRUE:
+        case JSON_TOKEN_FALSE:
+        case JSON_TOKEN_NULL:
+          token = json_scanner_get_next_token (scanner);
+          token = json_parse_value (parser, scanner, token, &element);
+          break;
+
+        case G_TOKEN_RIGHT_BRACE:
+          goto array_done;
+
+        default:
+          if (next_token != G_TOKEN_RIGHT_BRACE)
+            token = G_TOKEN_RIGHT_BRACE;
+          break;
+        }
+
+      if (token != G_TOKEN_NONE || element == NULL)
+        {
+          /* the json_parse_* functions will have set the error code */
+          json_array_unref (array);
+          json_node_free (priv->current_node);
+          priv->current_node = old_current;
+
+          return token;
+        }
+
+      next_token = json_scanner_peek_next_token (scanner);
+
+      if (next_token == G_TOKEN_COMMA)
+        {
+          token = json_scanner_get_next_token (scanner);
+          next_token = json_scanner_peek_next_token (scanner);
+
+          /* look for trailing commas */
+          if (next_token == G_TOKEN_RIGHT_BRACE)
+            {
+              priv->error_code = JSON_PARSER_ERROR_TRAILING_COMMA;
+
+              json_array_unref (array);
+              json_node_free (priv->current_node);
+              json_node_free (element);
+              priv->current_node = old_current;
+
+              return G_TOKEN_RIGHT_BRACE;
+            }
+        }
+
+      JSON_NOTE (PARSER, "Array element %d completed", idx + 1);
+      json_node_set_parent (element, priv->current_node);
+      json_array_add_element (array, element);
+
+      g_signal_emit (parser, parser_signals[ARRAY_ELEMENT], 0,
+                     array,
+                     idx);
+
+      token = next_token;
+    }
+
+array_done:
+  json_scanner_get_next_token (scanner);
+
+  json_node_take_array (priv->current_node, array);
+  json_node_set_parent (priv->current_node, old_current);
+
+  g_signal_emit (parser, parser_signals[ARRAY_END], 0, array);
+
+  if (node != NULL && *node == NULL)
+    *node = priv->current_node;
+
+  priv->current_node = old_current;
+
+  return G_TOKEN_NONE;
+}
+
+static guint
+json_parse_object (JsonParser   *parser,
+                   JsonScanner  *scanner,
+                   JsonNode    **node)
+{
+  JsonParserPrivate *priv = parser->priv;
+  JsonObject *object;
+  JsonNode *old_current;
+  guint token;
+
+  old_current = priv->current_node;
+  priv->current_node = json_node_new (JSON_NODE_OBJECT);
+
+  object = json_object_new ();
+
+  token = json_scanner_get_next_token (scanner);
+  g_assert (token == G_TOKEN_LEFT_CURLY);
+
+  g_signal_emit (parser, parser_signals[OBJECT_START], 0);
+
+  while (token != G_TOKEN_RIGHT_CURLY)
+    {
+      guint next_token = json_scanner_peek_next_token (scanner);
+      JsonNode *member = NULL;
+      gchar *name;
+
+      /* we need to abort here because empty objects do not
+       * have member names
+       */
+      if (next_token == G_TOKEN_RIGHT_CURLY)
+        break;
+
+      /* parse the member's name */
+      if (next_token != G_TOKEN_STRING)
+        {
+          JSON_NOTE (PARSER, "Missing object member name");
+
+          priv->error_code = JSON_PARSER_ERROR_PARSE;
+
+          json_object_unref (object);
+          json_node_free (priv->current_node);
+          priv->current_node = old_current;
+
+          return G_TOKEN_STRING;
+        }
+
+      /* member name */
+      token = json_scanner_get_next_token (scanner);
+      name = g_strdup (scanner->value.v_string);
+      JSON_NOTE (PARSER, "Object member '%s'", name);
+
+      /* a colon separates names from values */
+      next_token = json_scanner_peek_next_token (scanner);
+      if (next_token != ':')
+        {
+          JSON_NOTE (PARSER, "Missing object member name separator");
+
+          priv->error_code = JSON_PARSER_ERROR_MISSING_COLON;
+
+          g_free (name);
+          json_object_unref (object);
+          json_node_free (priv->current_node);
+          priv->current_node = old_current;
+
+          return ':';
+        }
+
+      /* we swallow the ':' */
+      token = json_scanner_get_next_token (scanner);
+      g_assert (token == ':');
+      next_token = json_scanner_peek_next_token (scanner);
+
+      /* parse the member's value */
+      switch (next_token)
+        {
+        case G_TOKEN_LEFT_BRACE:
+          JSON_NOTE (PARSER, "Nested array at member %s", name);
+          token = json_parse_array (parser, scanner, &member);
+          break;
+
+        case G_TOKEN_LEFT_CURLY:
+          JSON_NOTE (PARSER, "Nested object at member %s", name);
+          token = json_parse_object (parser, scanner, &member);
+          break;
+
+        case G_TOKEN_INT:
+        case G_TOKEN_FLOAT:
+        case G_TOKEN_STRING:
+        case '-':
+        case JSON_TOKEN_TRUE:
+        case JSON_TOKEN_FALSE:
+        case JSON_TOKEN_NULL:
+          token = json_scanner_get_next_token (scanner);
+          token = json_parse_value (parser, scanner, token, &member);
+          break;
+
+        default:
+          /* once a member name is defined we need a value */
+          token = G_TOKEN_SYMBOL;
+          break;
+        }
+
+      if (token != G_TOKEN_NONE || member == NULL)
+        {
+          /* the json_parse_* functions will have set the error code */
+          g_free (name);
+          json_object_unref (object);
+          json_node_free (priv->current_node);
+          priv->current_node = old_current;
+
+          return token;
+        }
+
+      next_token = json_scanner_peek_next_token (scanner);
+      if (next_token == G_TOKEN_COMMA)
+        {
+          token = json_scanner_get_next_token (scanner);
+          next_token = json_scanner_peek_next_token (scanner);
+
+          /* look for trailing commas */
+          if (next_token == G_TOKEN_RIGHT_CURLY)
+            {
+              priv->error_code = JSON_PARSER_ERROR_TRAILING_COMMA;
+
+              json_object_unref (object);
+              json_node_free (member);
+              json_node_free (priv->current_node);
+              priv->current_node = old_current;
+
+              return G_TOKEN_RIGHT_BRACE;
+            }
+        }
+      else if (next_token == G_TOKEN_STRING)
+        {
+          priv->error_code = JSON_PARSER_ERROR_MISSING_COMMA;
+
+          json_object_unref (object);
+          json_node_free (member);
+          json_node_free (priv->current_node);
+          priv->current_node = old_current;
+
+          return G_TOKEN_COMMA;
+        }
+
+      JSON_NOTE (PARSER, "Object member '%s' completed", name);
+      json_node_set_parent (member, priv->current_node);
+      json_object_set_member (object, name, member);
+
+      g_signal_emit (parser, parser_signals[OBJECT_MEMBER], 0,
+                     object,
+                     name);
+
+      g_free (name);
+
+      token = next_token;
+    }
+
+  json_scanner_get_next_token (scanner);
+
+  json_node_take_object (priv->current_node, object);
+  json_node_set_parent (priv->current_node, old_current);
+
+  g_signal_emit (parser, parser_signals[OBJECT_END], 0, object);
+
+  if (node != NULL && *node == NULL)
+    *node = priv->current_node;
+
+  priv->current_node = old_current;
+
+  return G_TOKEN_NONE;
+}
+
+static guint
+json_parse_statement (JsonParser  *parser,
+                      JsonScanner *scanner)
+{
+  JsonParserPrivate *priv = parser->priv;
+  guint token;
+
+  token = json_scanner_peek_next_token (scanner);
+  switch (token)
+    {
+    case G_TOKEN_LEFT_CURLY:
+      JSON_NOTE (PARSER, "Statement is object declaration");
+      return json_parse_object (parser, scanner, &priv->root);
+
+    case G_TOKEN_LEFT_BRACE:
+      JSON_NOTE (PARSER, "Statement is array declaration");
+      return json_parse_array (parser, scanner, &priv->root);
+
+    /* some web APIs are not only passing the data structures: they are
+     * also passing an assigment, which makes parsing horribly complicated
+     * only because web developers are lazy, and writing "var foo = " is
+     * evidently too much to request from them.
+     */
+    case JSON_TOKEN_VAR:
+      {
+        guint next_token;
+        gchar *name;
+
+        JSON_NOTE (PARSER, "Statement is an assignment");
+
+        /* swallow the 'var' token... */
+        token = json_scanner_get_next_token (scanner);
+
+        /* ... swallow the variable name... */
+        next_token = json_scanner_get_next_token (scanner);
+        if (next_token != G_TOKEN_IDENTIFIER)
+          {
+            priv->error_code = JSON_PARSER_ERROR_INVALID_BAREWORD;
+            return G_TOKEN_IDENTIFIER;
+          }
+
+        name = g_strdup (scanner->value.v_identifier);
+
+        /* ... and finally swallow the '=' */
+        next_token = json_scanner_get_next_token (scanner);
+        if (next_token != '=')
+          return '=';
+
+        priv->has_assignment = TRUE;
+        priv->variable_name = name;
+
+        token = json_parse_statement (parser, scanner);
+
+        /* remove the trailing semi-colon */
+        next_token = json_scanner_peek_next_token (scanner);
+        if (next_token == ';')
+          {
+            token = json_scanner_get_next_token (scanner);
+            return G_TOKEN_NONE;
+          }
+
+        return token;
+      }
+      break;
+
+    case JSON_TOKEN_NULL:
+    case JSON_TOKEN_TRUE:
+    case JSON_TOKEN_FALSE:
+    case '-':
+    case G_TOKEN_INT:
+    case G_TOKEN_FLOAT:
+    case G_TOKEN_STRING:
+      JSON_NOTE (PARSER, "Statement is a value");
+      token = json_scanner_get_next_token (scanner);
+      return json_parse_value (parser, scanner, token, &priv->root);
+
+    default:
+      JSON_NOTE (PARSER, "Unknown statement");
+      json_scanner_get_next_token (scanner);
+      priv->error_code = JSON_PARSER_ERROR_INVALID_BAREWORD;
+      return G_TOKEN_SYMBOL;
+    }
+}
+
+static void
+json_scanner_msg_handler (JsonScanner *scanner,
+                          gchar       *message,
+                          gboolean     is_error)
+{
+  JsonParser *parser = scanner->user_data;
+  JsonParserPrivate *priv = parser->priv;
+
+  if (is_error)
+    {
+      GError *error = NULL;
+
+      g_set_error (&error, JSON_PARSER_ERROR,
+                   priv->error_code,
+                   "%s:%d: Parse error: %s",
+                   priv->is_filename ? priv->filename : "<none>",
+                   scanner->line,
+                   message);
+      
+      parser->priv->last_error = error;
+      g_signal_emit (parser, parser_signals[ERROR], 0, error);
+    }
+  else
+    g_warning ("%s:%d: Parse error: %s",
+               priv->is_filename ? priv->filename : "<none>",
+               scanner->line,
+               message);
+}
+
+static JsonScanner *
+json_scanner_create (JsonParser *parser)
+{
+  JsonScanner *scanner;
+  gint i;
+
+  scanner = json_scanner_new ();
+  scanner->msg_handler = json_scanner_msg_handler;
+  scanner->user_data = parser;
+
+  for (i = 0; i < n_symbols; i++)
+    {
+      json_scanner_scope_add_symbol (scanner, 0,
+                                     symbol_names + symbols[i].name_offset,
+                                     GINT_TO_POINTER (symbols[i].token));
+    }
+
+  return scanner;
+}
+
+/**
+ * json_parser_new:
+ * 
+ * Creates a new #JsonParser instance. You can use the #JsonParser to
+ * load a JSON stream from either a file or a buffer and then walk the
+ * hierarchy using the data types API.
+ *
+ * Return value: the newly created #JsonParser. Use g_object_unref()
+ *   to release all the memory it allocates.
+ */
+JsonParser *
+json_parser_new (void)
+{
+  return g_object_new (JSON_TYPE_PARSER, NULL);
+}
+
+static gboolean
+json_parser_load (JsonParser   *parser,
+                  const gchar  *data,
+                  gsize         length,
+                  GError      **error)
+{
+  JsonParserPrivate *priv = parser->priv;
+  JsonScanner *scanner;
+  gboolean done;
+  gboolean retval = TRUE;
+  gint i;
+
+  json_parser_clear (parser);
+
+  scanner = json_scanner_create (parser);
+  json_scanner_input_text (scanner, data, length);
+
+  priv->scanner = scanner;
+
+  g_signal_emit (parser, parser_signals[PARSE_START], 0);
+
+  done = FALSE;
+  while (!done)
+    {
+      if (json_scanner_peek_next_token (scanner) == G_TOKEN_EOF)
+        done = TRUE;
+      else
+        {
+          guint expected_token;
+          gint cur_token;
+
+          /* we try to show the expected token, if possible */
+          expected_token = json_parse_statement (parser, scanner);
+          if (expected_token != G_TOKEN_NONE)
+            {
+              const gchar *symbol_name;
+              gchar *msg;
+
+              cur_token = scanner->token;
+              msg = NULL;
+              symbol_name = NULL;
+
+              if (scanner->scope_id == 0)
+                {
+                  if (expected_token > JSON_TOKEN_INVALID &&
+                      expected_token < JSON_TOKEN_LAST)
+                    {
+                      for (i = 0; i < n_symbols; i++)
+                        if (symbols[i].token == expected_token)
+                          symbol_name = symbol_names + symbols[i].name_offset;
+
+                      if (!msg)
+                        msg = g_strconcat ("e.g. '", symbol_name, "'", NULL);
+                    }
+
+                  if (cur_token > JSON_TOKEN_INVALID &&
+                      cur_token < JSON_TOKEN_LAST)
+                    {
+                      symbol_name = "???";
+
+                      for (i = 0; i < n_symbols; i++)
+                        if (symbols[i].token == cur_token)
+                          symbol_name = symbol_names + symbols[i].name_offset;
+                    }
+                }
+
+              /* this will emit the ::error signal via the custom
+               * message handler we install
+               */
+              json_scanner_unexp_token (scanner, expected_token,
+                                        NULL, "value",
+                                        symbol_name, msg,
+                                        TRUE);
+
+              /* and this will propagate the error we create in the
+               * same message handler
+               */
+              if (priv->last_error)
+                {
+                  g_propagate_error (error, priv->last_error);
+                  priv->last_error = NULL;
+                }
+
+              retval = FALSE;
+
+              g_free (msg);
+              done = TRUE;
+            }
+        }
+    }
+
+  g_signal_emit (parser, parser_signals[PARSE_END], 0);
+
+  /* remove the scanner */
+  json_scanner_destroy (scanner);
+  priv->scanner = NULL;
+  priv->current_node = NULL;
+
+  return retval;
+}
+
+/**
+ * json_parser_load_from_file:
+ * @parser: a #JsonParser
+ * @filename: the path for the file to parse
+ * @error: return location for a #GError, or %NULL
+ *
+ * Loads a JSON stream from the content of @filename and parses it. See
+ * json_parser_load_from_data().
+ *
+ * Return value: %TRUE if the file was successfully loaded and parsed.
+ *   In case of error, @error is set accordingly and %FALSE is returned
+ */
+gboolean
+json_parser_load_from_file (JsonParser   *parser,
+                            const gchar  *filename,
+                            GError      **error)
+{
+  JsonParserPrivate *priv;
+  GError *internal_error;
+  gchar *data;
+  gsize length;
+  gboolean retval = TRUE;
+
+  g_return_val_if_fail (JSON_IS_PARSER (parser), FALSE);
+  g_return_val_if_fail (filename != NULL, FALSE);
+
+  priv = parser->priv;
+
+  internal_error = NULL;
+  if (!g_file_get_contents (filename, &data, &length, &internal_error))
+    {
+      g_propagate_error (error, internal_error);
+      return FALSE;
+    }
+
+  g_free (priv->filename);
+
+  priv->is_filename = TRUE;
+  priv->filename = g_strdup (filename);
+
+  if (!json_parser_load (parser, data, length, &internal_error))
+    {
+      g_propagate_error (error, internal_error);
+      retval = FALSE;
+    }
+
+  g_free (data);
+
+  return retval;
+}
+
+/**
+ * json_parser_load_from_data:
+ * @parser: a #JsonParser
+ * @data: the buffer to parse
+ * @length: the length of the buffer, or -1
+ * @error: return location for a #GError, or %NULL
+ *
+ * Loads a JSON stream from a buffer and parses it. You can call this function
+ * multiple times with the same #JsonParser object, but the contents of the
+ * parser will be destroyed each time.
+ *
+ * Return value: %TRUE if the buffer was succesfully parser. In case
+ *   of error, @error is set accordingly and %FALSE is returned
+ */
+gboolean
+json_parser_load_from_data (JsonParser   *parser,
+                            const gchar  *data,
+                            gssize        length,
+                            GError      **error)
+{
+  JsonParserPrivate *priv;
+  GError *internal_error;
+  gboolean retval = TRUE;
+
+  g_return_val_if_fail (JSON_IS_PARSER (parser), FALSE);
+  g_return_val_if_fail (data != NULL, FALSE);
+
+  priv = parser->priv;
+
+  if (length < 0)
+    length = strlen (data);
+
+  priv->is_filename = FALSE;
+  g_free (priv->filename);
+  priv->filename = NULL;
+
+  internal_error = NULL;
+  if (!json_parser_load (parser, data, length, &internal_error))
+    {
+      g_propagate_error (error, internal_error);
+      retval = FALSE;
+    }
+
+  return retval;
+}
+
+/**
+ * json_parser_get_root:
+ * @parser: a #JsonParser
+ *
+ * Retrieves the top level node from the parsed JSON stream.
+ *
+ * Return value: (transfer none): the root #JsonNode . The returned
+ *   node is owned by the #JsonParser and should never be modified
+ *   or freed.
+ */
+JsonNode *
+json_parser_get_root (JsonParser *parser)
+{
+  g_return_val_if_fail (JSON_IS_PARSER (parser), NULL);
+
+  return parser->priv->root;
+}
+
+/**
+ * json_parser_get_current_line:
+ * @parser: a #JsonParser
+ *
+ * Retrieves the line currently parsed, starting from 1.
+ *
+ * This function has defined behaviour only while parsing; calling this
+ * function from outside the signal handlers emitted by #JsonParser will
+ * yield 0.
+ *
+ * Return value: the currently parsed line, or 0.
+ */
+guint
+json_parser_get_current_line (JsonParser *parser)
+{
+  g_return_val_if_fail (JSON_IS_PARSER (parser), 0);
+
+  if (parser->priv->scanner)
+    return json_scanner_cur_line (parser->priv->scanner);
+
+  return 0;
+}
+
+/**
+ * json_parser_get_current_pos:
+ * @parser: a #JsonParser
+ *
+ * Retrieves the current position inside the current line, starting
+ * from 0.
+ *
+ * This function has defined behaviour only while parsing; calling this
+ * function from outside the signal handlers emitted by #JsonParser will
+ * yield 0.
+ *
+ * Return value: the position in the current line, or 0.
+ */
+guint
+json_parser_get_current_pos (JsonParser *parser)
+{
+  g_return_val_if_fail (JSON_IS_PARSER (parser), 0);
+
+  if (parser->priv->scanner)
+    return json_scanner_cur_line (parser->priv->scanner);
+
+  return 0;
+}
+
+/**
+ * json_parser_has_assignment:
+ * @parser: a #JsonParser
+ * @variable_name: (out) (allow-none) (transfer none): Return location for the variable
+ *   name, or %NULL
+ *
+ * A JSON data stream might sometimes contain an assignment, like:
+ *
+ * |[
+ *   var _json_data = { "member_name" : [ ...
+ * ]|
+ *
+ * even though it would technically constitute a violation of the RFC.
+ *
+ * #JsonParser will ignore the left hand identifier and parse the right
+ * hand value of the assignment. #JsonParser will record, though, the
+ * existence of the assignment in the data stream and the variable name
+ * used.
+ *
+ * Return value: %TRUE if there was an assignment, %FALSE otherwise. If
+ *   @variable_name is not %NULL it will be set to the name of the variable
+ *   used in the assignment. The string is owned by #JsonParser and should
+ *   never be modified or freed.
+ *
+ * Since: 0.4
+ */
+gboolean
+json_parser_has_assignment (JsonParser  *parser,
+                            gchar      **variable_name)
+{
+  JsonParserPrivate *priv;
+
+  g_return_val_if_fail (JSON_IS_PARSER (parser), FALSE);
+
+  priv = parser->priv;
+
+  if (priv->has_assignment && variable_name)
+    *variable_name = priv->variable_name;
+
+  return priv->has_assignment;
+}
+
+#define GET_DATA_BLOCK_SIZE     8192
+
+/**
+ * json_parser_load_from_stream:
+ * @parser: a #JsonParser
+ * @stream: an open #GInputStream
+ * @cancellable: (allow-none): a #GCancellable, or %NULL
+ * @error: the return location for a #GError, or %NULL
+ *
+ * Loads the contents of an input stream and parses them.
+ *
+ * If @cancellable is not %NULL, then the operation can be cancelled by
+ * triggering the @cancellable object from another thread. If the
+ * operation was cancelled, the error %G_IO_ERROR_CANCELLED will be set
+ * on the passed @error.
+ *
+ * Return value: %TRUE if the data stream was successfully read and
+ *   parsed, and %FALSE otherwise
+ *
+ * Since: 0.12
+ */
+gboolean
+json_parser_load_from_stream (JsonParser    *parser,
+                              GInputStream  *stream,
+                              GCancellable  *cancellable,
+                              GError       **error)
+{
+  GByteArray *content;
+  gsize pos;
+  gssize res;
+  gboolean retval = FALSE;
+
+  g_return_val_if_fail (JSON_IS_PARSER (parser), FALSE);
+  g_return_val_if_fail (G_IS_INPUT_STREAM (stream), FALSE);
+  g_return_val_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable), FALSE);
+
+  if (g_cancellable_set_error_if_cancelled (cancellable, error))
+    return FALSE;
+
+  content = g_byte_array_new ();
+  pos = 0;
+
+  g_byte_array_set_size (content, pos + GET_DATA_BLOCK_SIZE + 1);
+  while ((res = g_input_stream_read (stream, content->data + pos,
+                                     GET_DATA_BLOCK_SIZE,
+                                     cancellable, error)) > 0)
+    {
+      pos += res;
+      g_byte_array_set_size (content, pos + GET_DATA_BLOCK_SIZE + 1);
+    }
+
+  if (res < 0)
+    {
+      /* error has already been set */
+      retval = FALSE;
+      goto out;
+    }
+
+  /* zero-terminate the content; we allocated an extra byte for this */
+  content->data[pos] = 0;
+
+  retval = json_parser_load (parser, (const gchar *) content->data, content->len, error);
+
+out:
+  g_byte_array_free (content, TRUE);
+
+  return retval;
+}
+
+typedef struct _LoadStreamData
+{
+  JsonParser *parser;
+  GError *error;
+  GCancellable *cancellable;
+  GAsyncReadyCallback callback;
+  gpointer user_data;
+  GByteArray *content;
+  gsize pos;
+} LoadStreamData;
+
+static void
+load_stream_data_free (gpointer data)
+{
+  LoadStreamData *closure;
+
+  if (G_UNLIKELY (data == NULL))
+    return;
+
+  closure = data;
+
+  if (closure->error)
+    g_error_free (closure->error);
+
+  if (closure->cancellable)
+    g_object_unref (closure->cancellable);
+
+  if (closure->content)
+    g_byte_array_free (closure->content, TRUE);
+
+  g_object_unref (closure->parser);
+
+  g_free (closure);
+}
+
+static void
+load_stream_data_read_callback (GObject      *object,
+                                GAsyncResult *read_res,
+                                gpointer      user_data)
+{
+  GInputStream *stream = G_INPUT_STREAM (object);
+  LoadStreamData *data = user_data;
+  GError *error = NULL;
+  gssize read_size;
+
+  read_size = g_input_stream_read_finish (stream, read_res, &error);
+  if (read_size < 0)
+    {
+      if (error != NULL)
+        data->error = error;
+      else
+        {
+          GSimpleAsyncResult *res;
+
+          /* EOF */
+          res = g_simple_async_result_new (G_OBJECT (data->parser),
+                                           data->callback,
+                                           data->user_data,
+                                           json_parser_load_from_stream_async);
+          g_simple_async_result_set_op_res_gpointer (res, data, load_stream_data_free);
+          g_simple_async_result_complete (res);
+          g_object_unref (res);
+        }
+    }
+  else if (read_size > 0)
+    {
+      data->pos += read_size;
+
+      g_byte_array_set_size (data->content, data->pos + GET_DATA_BLOCK_SIZE);
+
+      g_input_stream_read_async (stream, data->content->data + data->pos,
+                                 GET_DATA_BLOCK_SIZE,
+                                 0,
+                                 data->cancellable,
+                                 load_stream_data_read_callback,
+                                 data);
+    }
+  else
+    {
+      GSimpleAsyncResult *res;
+
+      res = g_simple_async_result_new (G_OBJECT (data->parser),
+                                       data->callback,
+                                       data->user_data,
+                                       json_parser_load_from_stream_async);
+      g_simple_async_result_set_op_res_gpointer (res, data, load_stream_data_free);
+      g_simple_async_result_complete (res);
+      g_object_unref (res);
+    }
+}
+
+/**
+ * json_parser_load_from_stream_finish:
+ * @parser: a #JsonParser
+ * @result: a #GAsyncResult
+ * @error: the return location for a #GError or %NULL
+ *
+ * Finishes an asynchronous stream loading started with
+ * json_parser_load_from_stream_async().
+ *
+ * Return value: %TRUE if the content of the stream was successfully retrieves
+ *   and parsed, and %FALSE otherwise. In case of error, the #GError will be
+ *   filled accordingly.
+ *
+ * Since: 0.12
+ */
+gboolean
+json_parser_load_from_stream_finish (JsonParser    *parser,
+                                     GAsyncResult  *result,
+                                     GError       **error)
+{
+  GSimpleAsyncResult *simple;
+  LoadStreamData *data;
+
+  g_return_val_if_fail (JSON_IS_PARSER (parser), FALSE);
+  g_return_val_if_fail (G_IS_SIMPLE_ASYNC_RESULT (result), FALSE);
+
+  simple = G_SIMPLE_ASYNC_RESULT (result);
+
+  if (g_simple_async_result_propagate_error (simple, error))
+    return FALSE;
+
+  g_warn_if_fail (g_simple_async_result_get_source_tag (simple) == json_parser_load_from_stream_async);
+
+  data = g_simple_async_result_get_op_res_gpointer (simple);
+
+  if (data->error)
+    {
+      g_propagate_error (error, data->error);
+      data->error = NULL;
+      return FALSE;
+    }
+
+  g_byte_array_set_size (data->content, data->pos + 1);
+  data->content->data[data->pos] = 0;
+
+  return json_parser_load (parser, (const gchar *) data->content->data, data->content->len, error);
+}
+
+/**
+ * json_parser_load_from_stream_async:
+ * @parser: a #JsonParser
+ * @stream: a #GInputStream
+ * @cancellable: (allow-none): a #GCancellable, or %NULL
+ * @callback: a #GAsyncReadyCallback to call when the request is satisfied
+ * @user_data: the data to pass to @callback
+ *
+ * Asynchronously reads the contents of @stream.
+ *
+ * For more details, see json_parser_load_from_stream() which is the
+ * synchronous version of this call.
+ *
+ * When the operation is finished, @callback will be called. You should
+ * then call json_parser_load_from_stream_finish() to get the result
+ * of the operation.
+ *
+ * Since: 0.12
+ */
+void
+json_parser_load_from_stream_async (JsonParser          *parser,
+                                    GInputStream        *stream,
+                                    GCancellable        *cancellable,
+                                    GAsyncReadyCallback  callback,
+                                    gpointer             user_data)
+{
+  LoadStreamData *data;
+
+  g_return_if_fail (JSON_IS_PARSER (parser));
+  g_return_if_fail (G_IS_INPUT_STREAM (stream));
+  g_return_if_fail (cancellable == NULL || G_IS_CANCELLABLE (cancellable));
+
+  data = g_new0 (LoadStreamData, 1);
+
+  if (cancellable != NULL)
+    data->cancellable = g_object_ref (cancellable);
+
+  data->callback = callback;
+  data->user_data = user_data;
+  data->content = g_byte_array_new ();
+  data->parser = g_object_ref (parser);
+
+  g_byte_array_set_size (data->content, data->pos + GET_DATA_BLOCK_SIZE);
+  g_input_stream_read_async (stream, data->content->data + data->pos,
+                             GET_DATA_BLOCK_SIZE, 0,
+                             data->cancellable,
+                             load_stream_data_read_callback,
+                             data);
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-parser.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-parser.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-parser.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-parser.h	2011-03-27 09:15:30.768552999 -0600
@@ -0,0 +1,173 @@
+/* json-parser.h - JSON streams parser
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_PARSER_H__
+#define __JSON_PARSER_H__
+
+#include <glib-object.h>
+#include <gio/gio.h>
+#include <json-glib/json-types.h>
+
+G_BEGIN_DECLS
+
+#define JSON_TYPE_PARSER                (json_parser_get_type ())
+#define JSON_PARSER(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), JSON_TYPE_PARSER, JsonParser))
+#define JSON_IS_PARSER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JSON_TYPE_PARSER))
+#define JSON_PARSER_CLASS(klass)        (G_TYPE_CHECK_CLASS_CAST ((klass), JSON_TYPE_PARSER, JsonParserClass))
+#define JSON_IS_PARSER_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE ((klass), JSON_TYPE_PARSER))
+#define JSON_PARSER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), JSON_TYPE_PARSER, JsonParserClass))
+
+#define JSON_PARSER_ERROR               (json_parser_error_quark ())
+
+typedef struct _JsonParser              JsonParser;
+typedef struct _JsonParserPrivate       JsonParserPrivate;
+typedef struct _JsonParserClass         JsonParserClass;
+
+/**
+ * JsonParserError:
+ * @JSON_PARSER_ERROR_PARSE: parse error
+ * @JSON_PARSER_ERROR_TRAILING_COMMA: unexpected trailing comma
+ * @JSON_PARSER_ERROR_MISSING_COMMA: expected comma
+ * @JSON_PARSER_ERROR_MISSING_COLON: expected colon
+ * @JSON_PARSER_ERROR_INVALID_BAREWORD: invalid bareword
+ * @JSON_PARSER_ERROR_UNKNOWN: unknown error
+ *
+ * Error enumeration for #JsonParser
+ *
+ * This enumeration can be extended at later date
+ */
+typedef enum {
+  JSON_PARSER_ERROR_PARSE,
+  JSON_PARSER_ERROR_TRAILING_COMMA,
+  JSON_PARSER_ERROR_MISSING_COMMA,
+  JSON_PARSER_ERROR_MISSING_COLON,
+  JSON_PARSER_ERROR_INVALID_BAREWORD,
+  
+  JSON_PARSER_ERROR_UNKNOWN
+} JsonParserError;
+
+/**
+ * JsonParser:
+ * 
+ * JSON data streams parser. The contents of the #JsonParser structure are
+ * private and should only be accessed via the provided API.
+ */
+struct _JsonParser
+{
+  /*< private >*/
+  GObject parent_instance;
+
+  JsonParserPrivate *priv;
+};
+
+/**
+ * JsonParserClass:
+ * @parse_start: class handler for the JsonParser::parse-start signal
+ * @object_start: class handler for the JsonParser::object-start signal
+ * @object_member: class handler for the JsonParser::object-member signal
+ * @object_end: class handler for the JsonParser::object-end signal
+ * @array_start: class handler for the JsonParser::array-start signal
+ * @array_element: class handler for the JsonParser::array-element signal
+ * @array_end: class handler for the JsonParser::array-end signal
+ * @parse_end: class handler for the JsonParser::parse-end signal
+ * @error: class handler for the JsonParser::error signal
+ *
+ * #JsonParser class.
+ */
+struct _JsonParserClass
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  /*< public  >*/
+  void (* parse_start)   (JsonParser   *parser);
+
+  void (* object_start)  (JsonParser   *parser);
+  void (* object_member) (JsonParser   *parser,
+                          JsonObject   *object,
+                          const gchar  *member_name);
+  void (* object_end)    (JsonParser   *parser,
+                          JsonObject   *object);
+
+  void (* array_start)   (JsonParser   *parser);
+  void (* array_element) (JsonParser   *parser,
+                          JsonArray    *array,
+                          gint          index_);
+  void (* array_end)     (JsonParser   *parser,
+                          JsonArray    *array);
+
+  void (* parse_end)     (JsonParser   *parser);
+  
+  void (* error)         (JsonParser   *parser,
+                          const GError *error);
+
+  /*< private >*/
+  /* padding for future expansion */
+  void (* _json_reserved1) (void);
+  void (* _json_reserved2) (void);
+  void (* _json_reserved3) (void);
+  void (* _json_reserved4) (void);
+  void (* _json_reserved5) (void);
+  void (* _json_reserved6) (void);
+  void (* _json_reserved7) (void);
+  void (* _json_reserved8) (void);
+};
+
+GQuark json_parser_error_quark (void);
+GType json_parser_get_type (void) G_GNUC_CONST;
+
+JsonParser *json_parser_new                     (void);
+gboolean    json_parser_load_from_file          (JsonParser           *parser,
+                                                 const gchar          *filename,
+                                                 GError              **error);
+gboolean    json_parser_load_from_data          (JsonParser           *parser,
+                                                 const gchar          *data,
+                                                 gssize                length,
+                                                 GError              **error);
+gboolean    json_parser_load_from_stream        (JsonParser           *parser,
+                                                 GInputStream         *stream,
+                                                 GCancellable         *cancellable,
+                                                 GError              **error);
+void        json_parser_load_from_stream_async  (JsonParser           *parser,
+                                                 GInputStream         *stream,
+                                                 GCancellable         *cancellable,
+                                                 GAsyncReadyCallback   callback,
+                                                 gpointer              user_data);
+gboolean    json_parser_load_from_stream_finish (JsonParser           *parser,
+                                                 GAsyncResult         *result,
+                                                 GError              **error);
+
+JsonNode *  json_parser_get_root                (JsonParser           *parser);
+
+guint       json_parser_get_current_line        (JsonParser           *parser);
+guint       json_parser_get_current_pos         (JsonParser           *parser);
+gboolean    json_parser_has_assignment          (JsonParser           *parser,
+                                                 gchar               **variable_name);
+
+G_END_DECLS
+
+#endif /* __JSON_PARSER_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-reader.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-reader.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-reader.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-reader.c	2011-03-27 09:15:30.776552999 -0600
@@ -0,0 +1,932 @@
+/* json-reader.h - JSON cursor parser
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2010  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+/**
+ * SECTION:json-reader
+ * @Title: JsonReader
+ * @short_description: A cursor-based parser
+ *
+ * #JsonReader provides a simple, cursor-based API for parsing a JSON DOM. It
+ * is similar, in spirit, to the XML Reader API.
+ *
+ * In case of error, #JsonReader will be set in an error state; all subsequent
+ * calls will simply be ignored until a function that resets the error state is
+ * called, e.g.:
+ *
+ * |[
+ * /&ast; ask for the 7th element; if the element does not exist, the
+ *  &ast; reader will be put in an error state
+ *  &ast;/
+ * json_reader_read_element (reader, 6);
+ *
+ * /&ast; in case of error, this will return NULL, otherwise it will
+ *  &ast; return the value of the element
+ *  &ast;/
+ * str = json_reader_get_string_value (value);
+ *
+ * /&ast; this function resets the error state if any was set &ast;/
+ * json_reader_end_element (reader);
+ * ]|
+ *
+ * If you want to detect the error state as soon as possible, you can use
+ * json_reader_get_error():
+ *
+ * |[
+ * /&ast; like the example above, but in this case we print out the
+ *  &ast; error immediately
+ *  &ast;/
+ * if (!json_reader_read_element (reader, 6))
+ *   {
+ *     const GError *error = json_reader_get_error (error);
+ *     g_print ("Unable to read the element: %s", error->message);
+ *   }
+ * ]|
+ *
+ * #JsonReader is available since JSON-GLib 0.12.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+
+#include "json-reader.h"
+
+#include "json-types-private.h"
+
+#include "json-debug.h"
+
+#define json_reader_return_if_error_set(r)      G_STMT_START {  \
+        if (((JsonReader *) (r))->priv->error != NULL)          \
+          return;                               } G_STMT_END
+
+#define json_reader_return_val_if_error_set(r,v) G_STMT_START {  \
+        if (((JsonReader *) (r))->priv->error != NULL)           \
+          return (v);                           } G_STMT_END
+
+struct _JsonReaderPrivate
+{
+  JsonNode *root;
+
+  JsonNode *current_node;
+  JsonNode *previous_node;
+
+  gchar *current_member;
+
+  GError *error;
+};
+
+enum
+{
+  PROP_0,
+
+  PROP_ROOT,
+
+  PROP_LAST
+};
+
+static GParamSpec *reader_properties[PROP_LAST] = { NULL, };
+
+G_DEFINE_TYPE (JsonReader, json_reader, G_TYPE_OBJECT);
+
+static void
+json_reader_finalize (GObject *gobject)
+{
+  JsonReaderPrivate *priv = JSON_READER (gobject)->priv;
+
+  if (priv->root != NULL)
+    json_node_free (priv->root);
+
+  if (priv->error != NULL)
+    g_clear_error (&priv->error);
+
+  g_free (priv->current_member);
+
+  G_OBJECT_CLASS (json_reader_parent_class)->finalize (gobject);
+}
+
+static void
+json_reader_set_property (GObject      *gobject,
+                          guint         prop_id,
+                          const GValue *value,
+                          GParamSpec   *pspec)
+{
+  switch (prop_id)
+    {
+    case PROP_ROOT:
+      json_reader_set_root (JSON_READER (gobject), g_value_get_boxed (value));
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+json_reader_get_property (GObject    *gobject,
+                          guint       prop_id,
+                          GValue     *value,
+                          GParamSpec *pspec)
+{
+  switch (prop_id)
+    {
+    case PROP_ROOT:
+      g_value_set_boxed (value, JSON_READER (gobject)->priv->root);
+      break;
+
+    default:
+      G_OBJECT_WARN_INVALID_PROPERTY_ID (gobject, prop_id, pspec);
+      break;
+    }
+}
+
+static void
+json_reader_class_init (JsonReaderClass *klass)
+{
+  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
+
+  g_type_class_add_private (klass, sizeof (JsonReaderPrivate));
+
+  /**
+   * JsonReader:root:
+   *
+   * The root of the JSON tree that the #JsonReader should read.
+   *
+   * Since: 0.12
+   */
+  reader_properties[PROP_ROOT] =
+    g_param_spec_boxed ("root",
+                        "Root Node",
+                        "The root of the tree to read",
+                        JSON_TYPE_NODE,
+                        G_PARAM_READWRITE |
+                        G_PARAM_CONSTRUCT |
+                        G_PARAM_STATIC_STRINGS);
+
+  gobject_class->finalize = json_reader_finalize;
+  gobject_class->set_property = json_reader_set_property;
+  gobject_class->get_property = json_reader_get_property;
+  g_object_class_install_properties (gobject_class, PROP_LAST, reader_properties);
+}
+
+static void
+json_reader_init (JsonReader *self)
+{
+  self->priv = G_TYPE_INSTANCE_GET_PRIVATE (self, JSON_TYPE_READER,
+                                            JsonReaderPrivate);
+}
+
+GQuark
+json_reader_error_quark (void)
+{
+  return g_quark_from_static_string ("json-reader-error");
+}
+
+/**
+ * json_reader_new:
+ * @node: (allow-none): a #JsonNode, or %NULL
+ *
+ * Creates a new #JsonReader. You can use this object to read the contents of
+ * the JSON tree starting from @node
+ *
+ * Return value: the newly created #JsonReader. Use g_object_unref() to
+ *   release the allocated resources when done
+ *
+ * Since: 0.12
+ */
+JsonReader *
+json_reader_new (JsonNode *node)
+{
+  return g_object_new (JSON_TYPE_READER, "root", node, NULL);
+}
+
+/*
+ * json_reader_unset_error:
+ * @reader: a #JsonReader
+ *
+ * Unsets the error state of @reader, if set
+ */
+static inline void
+json_reader_unset_error (JsonReader *reader)
+{
+  if (reader->priv->error != NULL)
+    g_clear_error (&(reader->priv->error));
+}
+
+/**
+ * json_reader_set_root:
+ * @reader: a #JsonReader
+ * @root: (allow-none): a #JsonNode
+ *
+ * Sets the root #JsonNode to be read by @reader. The @reader will take
+ * a copy of @root
+ *
+ * If another #JsonNode is currently set as root, it will be replaced.
+ *
+ * Since: 0.12
+ */
+void
+json_reader_set_root (JsonReader *reader,
+                      JsonNode   *root)
+{
+  JsonReaderPrivate *priv;
+
+  g_return_if_fail (JSON_IS_READER (reader));
+
+  priv = reader->priv;
+
+  if (priv->root == root)
+    return;
+
+  if (priv->root != NULL)
+    {
+      json_node_free (priv->root);
+      priv->root = NULL;
+      priv->current_node = NULL;
+      priv->previous_node = NULL;
+    }
+
+  if (root != NULL)
+    {
+      priv->root = json_node_copy (root);
+      priv->current_node = priv->root;
+      priv->previous_node = NULL;
+    }
+
+  g_object_notify_by_pspec (G_OBJECT (reader), reader_properties[PROP_ROOT]);
+}
+
+/*
+ * json_reader_ser_error:
+ * @reader: a #JsonReader
+ * @error_code: the #JsonReaderError code for the error
+ * @error_fmt: format string
+ * @Varargs: list of arguments for the @error_fmt string
+ *
+ * Sets the error state of @reader using the given error code
+ * and string
+ *
+ * Return value: %FALSE, to be used to return immediately from
+ *   the caller function
+ */
+static gboolean
+json_reader_set_error (JsonReader      *reader,
+                       JsonReaderError  error_code,
+                       const gchar     *error_fmt,
+                       ...)
+{
+  JsonReaderPrivate *priv = reader->priv;
+  va_list args;
+  gchar *error_msg;
+
+  if (priv->error != NULL)
+    g_clear_error (&priv->error);
+
+  va_start (args, error_fmt);
+  error_msg = g_strdup_vprintf (error_fmt, args);
+  va_end (args);
+
+  g_set_error_literal (&priv->error, JSON_READER_ERROR,
+                       error_code,
+                       error_msg);
+
+  g_free (error_msg);
+
+  return FALSE;
+}
+
+/**
+ * json_reader_get_error:
+ * @reader: a #JsonReader
+ *
+ * Retrieves the #GError currently set on @reader, if the #JsonReader
+ * is in error state
+ *
+ * Return value: (transfer none): the pointer to the error, or %NULL
+ *
+ * Since: 0.12
+ */
+G_CONST_RETURN GError *
+json_reader_get_error (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), FALSE);
+
+  return reader->priv->error;
+}
+
+/**
+ * json_reader_is_array:
+ * @reader: a #JsonReader
+ *
+ * Checks whether the @reader is currently on an array
+ *
+ * Return value: %TRUE if the #JsonReader is on an array, and %FALSE
+ *   otherwise
+ *
+ * Since: 0.12
+ */
+gboolean
+json_reader_is_array (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), FALSE);
+  json_reader_return_val_if_error_set (reader, FALSE);
+
+  if (reader->priv->current_node == NULL)
+    return FALSE;
+
+  return JSON_NODE_HOLDS_ARRAY (reader->priv->current_node);
+}
+
+/**
+ * json_reader_is_object:
+ * @reader: a #JsonReader
+ *
+ * Checks whether the @reader is currently on an object
+ *
+ * Return value: %TRUE if the #JsonReader is on an object, and %FALSE
+ *   otherwise
+ *
+ * Since: 0.12
+ */
+gboolean
+json_reader_is_object (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), FALSE);
+  json_reader_return_val_if_error_set (reader, FALSE);
+
+  if (reader->priv->current_node == NULL)
+    return FALSE;
+
+  return JSON_NODE_HOLDS_OBJECT (reader->priv->current_node);
+}
+
+/**
+ * json_reader_is_value:
+ * @reader: a #JsonReader
+ *
+ * Checks whether the @reader is currently on a value
+ *
+ * Return value: %TRUE if the #JsonReader is on a value, and %FALSE
+ *   otherwise
+ *
+ * Since: 0.12
+ */
+gboolean
+json_reader_is_value (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), FALSE);
+  json_reader_return_val_if_error_set (reader, FALSE);
+
+  if (reader->priv->current_node == NULL)
+    return FALSE;
+
+  return JSON_NODE_HOLDS_VALUE (reader->priv->current_node);
+}
+
+/**
+ * json_reader_read_element:
+ * @reader: a #JsonReader
+ * @index_: the index of the element
+ *
+ * Advances the cursor of @reader to the element @index_ of the array
+ * or the object at the current position.
+ *
+ * You can use the json_reader_get_value* family of functions to retrieve
+ * the value of the element; for instance:
+ *
+ * |[
+ * json_reader_read_element (reader, 0);
+ * int_value = json_reader_get_int_value (reader);
+ * ]|
+ *
+ * After reading the value, json_reader_end_element() should be called to
+ * reposition the cursor inside the #JsonReader, e.g.:
+ *
+ * |[
+ * json_reader_read_element (reader, 1);
+ * str_value = json_reader_get_string_value (reader);
+ * json_reader_end_element (reader);
+ *
+ * json_reader_read_element (reader, 2);
+ * str_value = json_reader_get_string_value (reader);
+ * json_reader_end_element (reader);
+ * ]|
+ *
+ * If @reader is not currently on an array or an object, or if the @index_ is
+ * bigger than the size of the array or the object, the #JsonReader will be
+ * put in an error state until json_reader_end_element() is called.
+ *
+ * Return value: %TRUE on success, and %FALSE otherwise
+ *
+ * Since: 0.12
+ */
+gboolean
+json_reader_read_element (JsonReader *reader,
+                          guint       index_)
+{
+  JsonReaderPrivate *priv;
+
+  g_return_val_if_fail (JSON_READER (reader), FALSE);
+  json_reader_return_val_if_error_set (reader, FALSE);
+
+  priv = reader->priv;
+
+  if (priv->current_node == NULL)
+    priv->current_node = priv->root;
+
+  if (!(JSON_NODE_HOLDS_ARRAY (priv->current_node) ||
+        JSON_NODE_HOLDS_OBJECT (priv->current_node)))
+    return json_reader_set_error (reader, JSON_READER_ERROR_NO_ARRAY,
+                                  "The current node is of type '%s', but "
+                                  "an array or an object was expected.",
+                                  json_node_type_name (priv->current_node));
+
+  switch (json_node_get_node_type (priv->current_node))
+    {
+    case JSON_NODE_ARRAY:
+      {
+        JsonArray *array = json_node_get_array (priv->current_node);
+
+        if (index_ >= json_array_get_length (array))
+          return json_reader_set_error (reader, JSON_READER_ERROR_INVALID_INDEX,
+                                        "The index '%d' is greater than the size "
+                                        "of the array at the current position.",
+                                        index_);
+
+        priv->previous_node = priv->current_node;
+        priv->current_node = json_array_get_element (array, index_);
+      }
+      break;
+
+    case JSON_NODE_OBJECT:
+      {
+        JsonObject *object = json_node_get_object (priv->current_node);
+        GList *members;
+        const gchar *name;
+
+        if (index_ >= json_object_get_size (object))
+          return json_reader_set_error (reader, JSON_READER_ERROR_INVALID_INDEX,
+                                        "The index '%d' is greater than the size "
+                                        "of the object at the current position.",
+                                        index_);
+
+        priv->previous_node = priv->current_node;
+        g_free (priv->current_member);
+
+        members = json_object_get_members (object);
+        name = g_list_nth_data (members, index_);
+
+        priv->current_node = json_object_get_member (object, name);
+        priv->current_member = g_strdup (name);
+
+        g_list_free (members);
+      }
+      break;
+
+    default:
+      g_assert_not_reached ();
+      return FALSE;
+    }
+
+  return TRUE;
+}
+
+/**
+ * json_reader_end_element:
+ * @reader: a #JsonReader
+ *
+ * Moves the cursor back to the previous node after being positioned
+ * inside an array
+ *
+ * This function resets the error state of @reader, if any was set
+ *
+ * Since: 0.12
+ */
+void
+json_reader_end_element (JsonReader *reader)
+{
+  JsonReaderPrivate *priv;
+  JsonNode *tmp;
+
+  g_return_if_fail (JSON_IS_READER (reader));
+
+  json_reader_unset_error (reader);
+
+  priv = reader->priv;
+
+  if (priv->previous_node != NULL)
+    tmp = json_node_get_parent (priv->previous_node);
+  else
+    tmp = NULL;
+
+  g_free (priv->current_member);
+  priv->current_member = NULL;
+
+  priv->current_node = priv->previous_node;
+  priv->previous_node = tmp;
+}
+
+/**
+ * json_reader_count_elements:
+ * @reader: a #JsonReader
+ *
+ * Counts the elements of the current position, if @reader is
+ * positioned on an array
+ *
+ * Return value: the number of elements, or -1. In case of failure
+ *   the #JsonReader is set in an error state
+ *
+ * Since: 0.12
+ */
+gint
+json_reader_count_elements (JsonReader *reader)
+{
+  JsonReaderPrivate *priv;
+
+  g_return_val_if_fail (JSON_IS_READER (reader), -1);
+
+  priv = reader->priv;
+
+  if (priv->current_node == NULL)
+    return -1;
+
+  if (!JSON_NODE_HOLDS_ARRAY (priv->current_node))
+    return -1;
+
+  return json_array_get_length (json_node_get_array (priv->current_node));
+}
+
+/**
+ * json_reader_read_member:
+ * @reader: a #JsonReader
+ * @member_name: the name of the member to read
+ *
+ * Advances the cursor of @reader to the @member_name of the object at the
+ * current position.
+ *
+ * You can use the json_reader_get_value* family of functions to retrieve
+ * the value of the member; for instance:
+ *
+ * |[
+ * json_reader_read_member (reader, "width");
+ * width = json_reader_get_int_value (reader);
+ * ]|
+ *
+ * After reading the value, json_reader_end_member() should be called to
+ * reposition the cursor inside the #JsonReader, e.g.:
+ *
+ * |[
+ * json_reader_read_member (reader, "author");
+ * author = json_reader_get_string_value (reader);
+ * json_reader_end_element (reader);
+ *
+ * json_reader_read_element (reader, "title");
+ * title = json_reader_get_string_value (reader);
+ * json_reader_end_element (reader);
+ * ]|
+ *
+ * If @reader is not currently on an object, or if the @member_name is not
+ * defined in the object, the #JsonReader will be put in an error state until
+ * json_reader_end_member() is called.
+ *
+ * Return value: %TRUE on success, and %FALSE otherwise
+ *
+ * Since: 0.12
+ */
+gboolean
+json_reader_read_member (JsonReader  *reader,
+                         const gchar *member_name)
+{
+  JsonReaderPrivate *priv;
+  JsonObject *object;
+
+  g_return_val_if_fail (JSON_READER (reader), FALSE);
+  g_return_val_if_fail (member_name != NULL, FALSE);
+  json_reader_return_val_if_error_set (reader, FALSE);
+
+  priv = reader->priv;
+
+  if (priv->current_node == NULL)
+    priv->current_node = priv->root;
+
+  if (!JSON_NODE_HOLDS_OBJECT (priv->current_node))
+    return json_reader_set_error (reader, JSON_READER_ERROR_NO_OBJECT,
+                                  "The current node is of type '%s', but "
+                                  "an object was expected.",
+                                  json_node_type_name (priv->current_node));
+
+  object = json_node_get_object (priv->current_node);
+  if (!json_object_has_member (object, member_name))
+    return json_reader_set_error (reader, JSON_READER_ERROR_INVALID_MEMBER,
+                                  "The member '%s' is not defined in the "
+                                  "object at the current position.",
+                                  member_name);
+
+  g_free (priv->current_member);
+
+  priv->previous_node = priv->current_node;
+  priv->current_node = json_object_get_member (object, member_name);
+  priv->current_member = g_strdup (member_name);
+
+  return TRUE;
+}
+
+/**
+ * json_reader_end_member:
+ * @reader: a #JsonReader
+ *
+ * Moves the cursor back to the previous node after being positioned
+ * inside an object
+ *
+ * This function resets the error state of @reader, if any was set
+ *
+ * Since: 0.12
+ */
+void
+json_reader_end_member (JsonReader *reader)
+{
+  JsonReaderPrivate *priv;
+  JsonNode *tmp;
+
+  g_return_if_fail (JSON_IS_READER (reader));
+
+  json_reader_unset_error (reader);
+
+  priv = reader->priv;
+
+  if (priv->previous_node != NULL)
+    tmp = json_node_get_parent (priv->previous_node);
+  else
+    tmp = NULL;
+
+  g_free (priv->current_member);
+  priv->current_member = NULL;
+
+  priv->current_node = priv->previous_node;
+  priv->previous_node = tmp;
+}
+
+/**
+ * json_reader_list_members:
+ * @reader: a #JsonReader
+ *
+ * Retrieves a list of member names from the current position, if @reader
+ * is positioned on an object.
+ *
+ * Return value: (transfer full): a newly allocated, %NULL-terminated
+ *   array of strings holding the members name. Use g_strfreev() when
+ *   done.
+ *
+ * Since: 0.14
+ */
+gchar **
+json_reader_list_members (JsonReader *reader)
+{
+  JsonReaderPrivate *priv;
+  GList *members, *l;
+  gchar **retval;
+  gint i;
+
+  g_return_val_if_fail (JSON_IS_READER (reader), NULL);
+
+  priv = reader->priv;
+
+  if (priv->current_node == NULL)
+    return NULL;
+
+  if (!JSON_NODE_HOLDS_OBJECT (priv->current_node))
+    return NULL;
+
+  members = json_object_get_members (json_node_get_object (priv->current_node));
+  if (members == NULL)
+    return NULL;
+
+  retval = g_new (gchar*, g_list_length (members) + 1);
+  for (l = members, i = 0; l != NULL; l = l->next, i += 1)
+    retval[i] = g_strdup (l->data);
+
+  retval[i] = NULL;
+
+  g_list_free (members);
+
+  return retval;
+}
+
+/**
+ * json_reader_count_members:
+ * @reader: a #JsonReader
+ *
+ * Counts the members of the current position, if @reader is
+ * positioned on an object
+ *
+ * Return value: the number of members, or -1. In case of failure
+ *   the #JsonReader is set in an error state
+ *
+ * Since: 0.12
+ */
+gint
+json_reader_count_members (JsonReader *reader)
+{
+  JsonReaderPrivate *priv;
+
+  g_return_val_if_fail (JSON_IS_READER (reader), -1);
+
+  priv = reader->priv;
+
+  if (priv->current_node == NULL)
+    return -1;
+
+  if (!JSON_NODE_HOLDS_OBJECT (priv->current_node))
+    return -1;
+
+  return json_object_get_size (json_node_get_object (priv->current_node));
+}
+
+/**
+ * json_reader_get_value:
+ * @reader: a #JsonReader
+ *
+ * Retrieves the #JsonNode of the current position of @reader
+ *
+ * Return value: (transfer none): a #JsonNode, or %NULL. The returned node
+ *   is owned by the #JsonReader and it should not be modified or freed
+ *   directly
+ *
+ * Since: 0.12
+ */
+JsonNode *
+json_reader_get_value (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), NULL);
+  json_reader_return_val_if_error_set (reader, NULL);
+
+  if (reader->priv->current_node == NULL)
+    return NULL;
+
+  if (!JSON_NODE_HOLDS_VALUE (reader->priv->current_node))
+    return NULL;
+
+  return reader->priv->current_node;
+}
+
+/**
+ * json_reader_get_int_value:
+ * @reader: a #JsonReader
+ *
+ * Retrieves the integer value of the current position of @reader
+ *
+ * Return value: the integer value
+ *
+ * Since: 0.12
+ */
+gint64
+json_reader_get_int_value (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), 0);
+  json_reader_return_val_if_error_set (reader, 0);
+
+  if (reader->priv->current_node == NULL)
+    return 0;
+
+  if (!JSON_NODE_HOLDS_VALUE (reader->priv->current_node))
+    return 0;
+
+  return json_node_get_int (reader->priv->current_node);
+}
+
+/**
+ * json_reader_get_double_value:
+ * @reader: a #JsonReader
+ *
+ * Retrieves the floating point value of the current position of @reader
+ *
+ * Return value: the floating point value
+ *
+ * Since: 0.12
+ */
+gdouble
+json_reader_get_double_value (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), 0.0);
+  json_reader_return_val_if_error_set (reader, 0.0);
+
+  if (reader->priv->current_node == NULL)
+    return 0.0;
+
+  if (!JSON_NODE_HOLDS_VALUE (reader->priv->current_node))
+    return 0.0;
+
+  return json_node_get_double (reader->priv->current_node);
+}
+
+/**
+ * json_reader_get_string_value:
+ * @reader: a #JsonReader
+ *
+ * Retrieves the string value of the current position of @reader
+ *
+ * Return value: the string value
+ *
+ * Since: 0.12
+ */
+G_CONST_RETURN gchar *
+json_reader_get_string_value (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), NULL);
+  json_reader_return_val_if_error_set (reader, NULL);
+
+  if (reader->priv->current_node == NULL)
+    return NULL;
+
+  if (!JSON_NODE_HOLDS_VALUE (reader->priv->current_node))
+    return NULL;
+
+  return json_node_get_string (reader->priv->current_node);
+}
+
+/**
+ * json_reader_get_boolean_value:
+ * @reader: a #JsonReader
+ *
+ * Retrieves the boolean value of the current position of @reader
+ *
+ * Return value: the boolean value
+ *
+ * Since: 0.12
+ */
+gboolean
+json_reader_get_boolean_value (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), FALSE);
+  json_reader_return_val_if_error_set (reader, FALSE);
+
+  if (reader->priv->current_node == NULL)
+    return FALSE;
+
+  if (!JSON_NODE_HOLDS_VALUE (reader->priv->current_node))
+    return FALSE;
+
+  return json_node_get_boolean (reader->priv->current_node);
+}
+
+/**
+ * json_reader_get_null_value:
+ * @reader: a #JsonReader
+ *
+ * Checks whether the value of the current position of @reader is 'null'
+ *
+ * Return value: %TRUE if 'null' is set, and %FALSE otherwise
+ *
+ * Since: 0.12
+ */
+gboolean
+json_reader_get_null_value (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), FALSE);
+  json_reader_return_val_if_error_set (reader, FALSE);
+
+  if (reader->priv->current_node == NULL)
+    return FALSE;
+
+  return JSON_NODE_HOLDS_NULL (reader->priv->current_node);
+}
+
+/**
+ * json_reader_get_member_name:
+ * @reader: a #JsonReader
+ *
+ * Retrieves the name of the current member.
+ *
+ * Return value: (transfer none): the name of the member, or %NULL
+ *
+ * Since: 0.14
+ */
+G_CONST_RETURN gchar *
+json_reader_get_member_name (JsonReader *reader)
+{
+  g_return_val_if_fail (JSON_IS_READER (reader), NULL);
+  json_reader_return_val_if_error_set (reader, NULL);
+
+  return reader->priv->current_member;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-reader.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-reader.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-reader.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-reader.h	2011-03-27 09:15:30.772553000 -0600
@@ -0,0 +1,142 @@
+/* json-reader.h - JSON cursor parser
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2010  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_READER_H__
+#define __JSON_READER_H__
+
+#include <json-glib/json-types.h>
+
+G_BEGIN_DECLS
+
+#define JSON_TYPE_READER                (json_reader_get_type ())
+#define JSON_READER(obj)                (G_TYPE_CHECK_INSTANCE_CAST ((obj), JSON_TYPE_READER, JsonReader))
+#define JSON_IS_READER(obj)             (G_TYPE_CHECK_INSTANCE_TYPE ((obj), JSON_TYPE_READER))
+#define JSON_READER_CLASS(klass)        (G_TYPE_CHECK_CLASS_CAST ((klass), JSON_TYPE_READER, JsonReaderClass))
+#define JSON_IS_READER_CLASS(klass)     (G_TYPE_CHECK_CLASS_TYPE ((klass), JSON_TYPE_READER))
+#define JSON_READER_GET_CLASS(obj)      (G_TYPE_INSTANCE_GET_CLASS ((obj), JSON_TYPE_READER, JsonReaderClass))
+
+/**
+ * JSON_READER_ERROR:
+ *
+ * Error domain for #JsonReader errors
+ *
+ * Since: 0.12
+ */
+#define JSON_READER_ERROR               (json_reader_error_quark ())
+
+typedef struct _JsonReader              JsonReader;
+typedef struct _JsonReaderPrivate       JsonReaderPrivate;
+typedef struct _JsonReaderClass         JsonReaderClass;
+
+/**
+ * JsonReaderError:
+ * @JSON_READER_ERROR_NO_ARRAY: No array found at the current position
+ * @JSON_READER_ERROR_INVALID_INDEX: Index out of bounds
+ * @JSON_READER_ERROR_NO_OBJECT: No object found at the current position
+ * @JSON_READER_ERROR_INVALID_MEMBER: Member not found
+ *
+ * Error codes enumeration for #JsonReader errors
+ *
+ * Since: 0.12
+ */
+typedef enum {
+  JSON_READER_ERROR_NO_ARRAY,
+  JSON_READER_ERROR_INVALID_INDEX,
+  JSON_READER_ERROR_NO_OBJECT,
+  JSON_READER_ERROR_INVALID_MEMBER
+} JsonReaderError;
+
+/**
+ * JsonReader:
+ *
+ * The <structname>JsonReader</structname> structure contains only
+ * private data and should only be accessed using the provided API
+ *
+ * Since: 0.12
+ */
+struct _JsonReader
+{
+  /*< private >*/
+  GObject parent_instance;
+
+  JsonReaderPrivate *priv;
+};
+
+/**
+ * JsonReaderClass:
+ *
+ * The <structname>JsonReaderClass</structname> structure contains only
+ * private data
+ *
+ * Since: 0.12
+ */
+struct _JsonReaderClass
+{
+  /*< private >*/
+  GObjectClass parent_class;
+
+  void (*_json_padding0) (void);
+  void (*_json_padding1) (void);
+  void (*_json_padding2) (void);
+  void (*_json_padding3) (void);
+  void (*_json_padding4) (void);
+};
+
+GQuark json_reader_error_quark (void);
+GType json_reader_get_type (void) G_GNUC_CONST;
+
+JsonReader *           json_reader_new               (JsonNode     *node);
+
+void                   json_reader_set_root          (JsonReader   *reader,
+                                                      JsonNode     *root);
+
+G_CONST_RETURN GError *json_reader_get_error         (JsonReader   *reader);
+
+gboolean               json_reader_is_array          (JsonReader   *reader);
+gboolean               json_reader_read_element      (JsonReader   *reader,
+                                                      guint         index_);
+void                   json_reader_end_element       (JsonReader   *reader);
+gint                   json_reader_count_elements    (JsonReader   *reader);
+
+gboolean               json_reader_is_object         (JsonReader   *reader);
+gboolean               json_reader_read_member       (JsonReader   *reader,
+                                                      const gchar  *member_name);
+void                   json_reader_end_member        (JsonReader   *reader);
+gint                   json_reader_count_members     (JsonReader   *reader);
+gchar **               json_reader_list_members      (JsonReader   *reader);
+G_CONST_RETURN gchar * json_reader_get_member_name   (JsonReader   *reader);
+
+gboolean               json_reader_is_value          (JsonReader   *reader);
+JsonNode *             json_reader_get_value         (JsonReader   *reader);
+gint64                 json_reader_get_int_value     (JsonReader   *reader);
+gdouble                json_reader_get_double_value  (JsonReader   *reader);
+G_CONST_RETURN gchar * json_reader_get_string_value  (JsonReader   *reader);
+gboolean               json_reader_get_boolean_value (JsonReader   *reader);
+gboolean               json_reader_get_null_value    (JsonReader   *reader);
+
+G_END_DECLS
+
+#endif /* __JSON_READER_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-scanner.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-scanner.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-scanner.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-scanner.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,1861 @@
+/* json-scanner.c: Tokenizer for JSON
+ * Copyright (C) 2008 OpenedHand
+ *
+ * Based on JsonScanner: Flexible lexical scanner for general purpose.
+ * Copyright (C) 1997, 1998 Tim Janik
+ *
+ * Modified by Emmanuele Bassi <ebassi@openedhand.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <errno.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <string.h>
+#include <stdio.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#include <glib.h>
+#include <glib/gprintf.h>
+
+#include "json-scanner.h"
+
+#ifdef G_OS_WIN32
+#include <io.h> /* For _read() */
+#endif
+
+struct _JsonScannerConfig
+{
+  /* Character sets
+   */
+  gchar *cset_skip_characters; /* default: " \t\n" */
+  gchar *cset_identifier_first;
+  gchar *cset_identifier_nth;
+  gchar *cpair_comment_single; /* default: "#\n" */
+  
+  /* Should symbol lookup work case sensitive? */
+  guint case_sensitive : 1;
+  
+  /* Boolean values to be adjusted "on the fly"
+   * to configure scanning behaviour.
+   */
+  guint skip_comment_multi : 1;  /* C like comment */
+  guint skip_comment_single : 1; /* single line comment */
+  guint scan_comment_multi : 1;  /* scan multi line comments? */
+  guint scan_identifier : 1;
+  guint scan_identifier_1char : 1;
+  guint scan_identifier_NULL : 1;
+  guint scan_symbols : 1;
+  guint scan_binary : 1;
+  guint scan_octal : 1;
+  guint scan_float : 1;
+  guint scan_hex : 1;            /* `0x0ff0' */
+  guint scan_hex_dollar : 1;     /* `$0ff0' */
+  guint scan_string_sq : 1;      /* string: 'anything' */
+  guint scan_string_dq : 1;      /* string: "\\-escapes!\n" */
+  guint numbers_2_int : 1;       /* bin, octal, hex => int */
+  guint int_2_float : 1;         /* int => G_TOKEN_FLOAT? */
+  guint identifier_2_string : 1;
+  guint char_2_token : 1;        /* return G_TOKEN_CHAR? */
+  guint symbol_2_token : 1;
+  guint scope_0_fallback : 1;    /* try scope 0 on lookups? */
+  guint store_int64 : 1;         /* use value.v_int64 rather than v_int */
+  guint padding_dummy;
+};
+
+static JsonScannerConfig json_scanner_config_template =
+{
+  ( " \t\r\n" )		/* cset_skip_characters */,
+  (
+   "_"
+   G_CSET_a_2_z
+   G_CSET_A_2_Z
+  )			/* cset_identifier_first */,
+  (
+   G_CSET_DIGITS
+   "-_"
+   G_CSET_a_2_z
+   G_CSET_A_2_Z
+  )			/* cset_identifier_nth */,
+  ( "//\n" )		/* cpair_comment_single */,
+  TRUE			/* case_sensitive */,
+  TRUE			/* skip_comment_multi */,
+  TRUE			/* skip_comment_single */,
+  FALSE			/* scan_comment_multi */,
+  TRUE			/* scan_identifier */,
+  TRUE			/* scan_identifier_1char */,
+  FALSE			/* scan_identifier_NULL */,
+  TRUE			/* scan_symbols */,
+  TRUE			/* scan_binary */,
+  TRUE			/* scan_octal */,
+  TRUE			/* scan_float */,
+  TRUE			/* scan_hex */,
+  TRUE			/* scan_hex_dollar */,
+  TRUE			/* scan_string_sq */,
+  TRUE			/* scan_string_dq */,
+  TRUE			/* numbers_2_int */,
+  FALSE			/* int_2_float */,
+  FALSE			/* identifier_2_string */,
+  TRUE			/* char_2_token */,
+  TRUE			/* symbol_2_token */,
+  FALSE			/* scope_0_fallback */,
+  TRUE                  /* store_int64 */
+};
+
+/* --- defines --- */
+#define	to_lower(c)				( \
+	(guchar) (							\
+	  ( (((guchar)(c))>='A' && ((guchar)(c))<='Z') * ('a'-'A') ) |	\
+	  ( (((guchar)(c))>=192 && ((guchar)(c))<=214) * (224-192) ) |	\
+	  ( (((guchar)(c))>=216 && ((guchar)(c))<=222) * (248-216) ) |	\
+	  ((guchar)(c))							\
+	)								\
+)
+
+#define	READ_BUFFER_SIZE	(4000)
+
+static const gchar json_symbol_names[] =
+  "true\0"
+  "false\0"
+  "null\0"
+  "var\0";
+
+static const struct
+{
+  guint name_offset;
+  guint token;
+} json_symbols[] = {
+  {  0, JSON_TOKEN_TRUE },
+  {  5, JSON_TOKEN_FALSE },
+  { 11, JSON_TOKEN_NULL },
+  { 16, JSON_TOKEN_VAR }
+};
+
+static const guint n_json_symbols = G_N_ELEMENTS (json_symbols);
+
+/* --- typedefs --- */
+typedef	struct	_JsonScannerKey JsonScannerKey;
+
+struct	_JsonScannerKey
+{
+  guint scope_id;
+  gchar *symbol;
+  gpointer value;
+};
+
+/* --- prototypes --- */
+static gboolean	json_scanner_key_equal (gconstpointer v1,
+                                        gconstpointer v2);
+static guint    json_scanner_key_hash  (gconstpointer v);
+
+static inline
+JsonScannerKey *json_scanner_lookup_internal (JsonScanner *scanner,
+                                              guint        scope_id,
+                                              const gchar *symbol);
+static void     json_scanner_get_token_ll    (JsonScanner *scanner,
+                                              GTokenType  *token_p,
+                                              GTokenValue *value_p,
+                                              guint       *line_p,
+                                              guint       *position_p);
+static void	json_scanner_get_token_i     (JsonScanner *scanner,
+                                              GTokenType  *token_p,
+                                              GTokenValue *value_p,
+                                              guint       *line_p,
+                                              guint       *position_p);
+
+static guchar   json_scanner_peek_next_char  (JsonScanner *scanner);
+static guchar   json_scanner_get_char        (JsonScanner *scanner,
+                                              guint       *line_p,
+                                              guint       *position_p);
+static gunichar json_scanner_get_unichar     (JsonScanner *scanner,
+                                              guint       *line_p,
+                                              guint       *position_p);
+static void     json_scanner_msg_handler     (JsonScanner *scanner,
+                                              gchar       *message,
+                                              gboolean     is_error);
+
+/* --- functions --- */
+static inline gint
+json_scanner_char_2_num (guchar c,
+                         guchar base)
+{
+  if (c >= '0' && c <= '9')
+    c -= '0';
+  else if (c >= 'A' && c <= 'Z')
+    c -= 'A' - 10;
+  else if (c >= 'a' && c <= 'z')
+    c -= 'a' - 10;
+  else
+    return -1;
+  
+  if (c < base)
+    return c;
+  
+  return -1;
+}
+
+JsonScanner *
+json_scanner_new (void)
+{
+  JsonScanner *scanner;
+  JsonScannerConfig *config_templ;
+  
+  config_templ = &json_scanner_config_template;
+  
+  scanner = g_new0 (JsonScanner, 1);
+  
+  scanner->user_data = NULL;
+  scanner->max_parse_errors = 1;
+  scanner->parse_errors	= 0;
+  scanner->input_name = NULL;
+  g_datalist_init (&scanner->qdata);
+  
+  scanner->config = g_new0 (JsonScannerConfig, 1);
+  
+  scanner->config->case_sensitive	 = config_templ->case_sensitive;
+  scanner->config->cset_skip_characters	 = config_templ->cset_skip_characters;
+  if (!scanner->config->cset_skip_characters)
+    scanner->config->cset_skip_characters = "";
+  scanner->config->cset_identifier_first = config_templ->cset_identifier_first;
+  scanner->config->cset_identifier_nth	 = config_templ->cset_identifier_nth;
+  scanner->config->cpair_comment_single	 = config_templ->cpair_comment_single;
+  scanner->config->skip_comment_multi	 = config_templ->skip_comment_multi;
+  scanner->config->skip_comment_single	 = config_templ->skip_comment_single;
+  scanner->config->scan_comment_multi	 = config_templ->scan_comment_multi;
+  scanner->config->scan_identifier	 = config_templ->scan_identifier;
+  scanner->config->scan_identifier_1char = config_templ->scan_identifier_1char;
+  scanner->config->scan_identifier_NULL	 = config_templ->scan_identifier_NULL;
+  scanner->config->scan_symbols		 = config_templ->scan_symbols;
+  scanner->config->scan_binary		 = config_templ->scan_binary;
+  scanner->config->scan_octal		 = config_templ->scan_octal;
+  scanner->config->scan_float		 = config_templ->scan_float;
+  scanner->config->scan_hex		 = config_templ->scan_hex;
+  scanner->config->scan_hex_dollar	 = config_templ->scan_hex_dollar;
+  scanner->config->scan_string_sq	 = config_templ->scan_string_sq;
+  scanner->config->scan_string_dq	 = config_templ->scan_string_dq;
+  scanner->config->numbers_2_int	 = config_templ->numbers_2_int;
+  scanner->config->int_2_float		 = config_templ->int_2_float;
+  scanner->config->identifier_2_string	 = config_templ->identifier_2_string;
+  scanner->config->char_2_token		 = config_templ->char_2_token;
+  scanner->config->symbol_2_token	 = config_templ->symbol_2_token;
+  scanner->config->scope_0_fallback	 = config_templ->scope_0_fallback;
+  scanner->config->store_int64		 = config_templ->store_int64;
+  
+  scanner->token = G_TOKEN_NONE;
+  scanner->value.v_int64 = 0;
+  scanner->line = 1;
+  scanner->position = 0;
+  
+  scanner->next_token = G_TOKEN_NONE;
+  scanner->next_value.v_int64 = 0;
+  scanner->next_line = 1;
+  scanner->next_position = 0;
+  
+  scanner->symbol_table = g_hash_table_new (json_scanner_key_hash,
+                                            json_scanner_key_equal);
+  scanner->input_fd = -1;
+  scanner->text = NULL;
+  scanner->text_end = NULL;
+  scanner->buffer = NULL;
+  scanner->scope_id = 0;
+  
+  scanner->msg_handler = json_scanner_msg_handler;
+  
+  return scanner;
+}
+
+static inline void
+json_scanner_free_value (GTokenType  *token_p,
+                         GTokenValue *value_p)
+{
+  switch (*token_p)
+    {
+    case G_TOKEN_STRING:
+    case G_TOKEN_IDENTIFIER:
+    case G_TOKEN_IDENTIFIER_NULL:
+    case G_TOKEN_COMMENT_SINGLE:
+    case G_TOKEN_COMMENT_MULTI:
+      g_free (value_p->v_string);
+      break;
+      
+    default:
+      break;
+    }
+  
+  *token_p = G_TOKEN_NONE;
+}
+
+static void
+json_scanner_destroy_symbol_table_entry (gpointer _key,
+                                         gpointer _value,
+                                         gpointer _data)
+{
+  JsonScannerKey *key = _key;
+  
+  g_free (key->symbol);
+  g_slice_free (JsonScannerKey, key);
+}
+
+void
+json_scanner_destroy (JsonScanner *scanner)
+{
+  g_return_if_fail (scanner != NULL);
+  
+  g_datalist_clear (&scanner->qdata);
+  g_hash_table_foreach (scanner->symbol_table, 
+			json_scanner_destroy_symbol_table_entry,
+                        NULL);
+  g_hash_table_destroy (scanner->symbol_table);
+  json_scanner_free_value (&scanner->token, &scanner->value);
+  json_scanner_free_value (&scanner->next_token, &scanner->next_value);
+  g_free (scanner->config);
+  g_free (scanner->buffer);
+  g_free (scanner);
+}
+
+static void
+json_scanner_msg_handler (JsonScanner *scanner,
+                          gchar       *message,
+                          gboolean     is_error)
+{
+  g_return_if_fail (scanner != NULL);
+  
+  g_fprintf (stderr, "%s:%d: ",
+	     scanner->input_name ? scanner->input_name : "<memory>",
+	     scanner->line);
+  if (is_error)
+    g_fprintf (stderr, "error: ");
+
+  g_fprintf (stderr, "%s\n", message);
+}
+
+void
+json_scanner_error (JsonScanner *scanner,
+                    const gchar *format,
+                    ...)
+{
+  g_return_if_fail (scanner != NULL);
+  g_return_if_fail (format != NULL);
+  
+  scanner->parse_errors++;
+  
+  if (scanner->msg_handler)
+    {
+      va_list args;
+      gchar *string;
+      
+      va_start (args, format);
+      string = g_strdup_vprintf (format, args);
+      va_end (args);
+      
+      scanner->msg_handler (scanner, string, TRUE);
+      
+      g_free (string);
+    }
+}
+
+void
+json_scanner_warn (JsonScanner *scanner,
+                   const gchar *format,
+                   ...)
+{
+  g_return_if_fail (scanner != NULL);
+  g_return_if_fail (format != NULL);
+  
+  if (scanner->msg_handler)
+    {
+      va_list args;
+      gchar *string;
+      
+      va_start (args, format);
+      string = g_strdup_vprintf (format, args);
+      va_end (args);
+      
+      scanner->msg_handler (scanner, string, FALSE);
+      
+      g_free (string);
+    }
+}
+
+static gboolean
+json_scanner_key_equal (gconstpointer v1,
+                        gconstpointer v2)
+{
+  const JsonScannerKey *key1 = v1;
+  const JsonScannerKey *key2 = v2;
+  
+  return (key1->scope_id == key2->scope_id) &&
+         (strcmp (key1->symbol, key2->symbol) == 0);
+}
+
+static guint
+json_scanner_key_hash (gconstpointer v)
+{
+  const JsonScannerKey *key = v;
+  gchar *c;
+  guint h;
+  
+  h = key->scope_id;
+  for (c = key->symbol; *c; c++)
+    h = (h << 5) - h + *c;
+  
+  return h;
+}
+
+static inline JsonScannerKey *
+json_scanner_lookup_internal (JsonScanner *scanner,
+                              guint        scope_id,
+                              const gchar *symbol)
+{
+  JsonScannerKey *key_p;
+  JsonScannerKey key;
+  
+  key.scope_id = scope_id;
+  
+  if (!scanner->config->case_sensitive)
+    {
+      gchar *d;
+      const gchar *c;
+      
+      key.symbol = g_new (gchar, strlen (symbol) + 1);
+      for (d = key.symbol, c = symbol; *c; c++, d++)
+	*d = to_lower (*c);
+      *d = 0;
+      key_p = g_hash_table_lookup (scanner->symbol_table, &key);
+      g_free (key.symbol);
+    }
+  else
+    {
+      key.symbol = (gchar*) symbol;
+      key_p = g_hash_table_lookup (scanner->symbol_table, &key);
+    }
+  
+  return key_p;
+}
+
+void
+json_scanner_scope_add_symbol (JsonScanner *scanner,
+                               guint        scope_id,
+                               const gchar *symbol,
+                               gpointer     value)
+{
+  JsonScannerKey *key;
+
+  g_return_if_fail (scanner != NULL);
+  g_return_if_fail (symbol != NULL);
+
+  key = json_scanner_lookup_internal (scanner, scope_id, symbol);
+  if (!key)
+    {
+      key = g_slice_new (JsonScannerKey);
+      key->scope_id = scope_id;
+      key->symbol = g_strdup (symbol);
+      key->value = value;
+      if (!scanner->config->case_sensitive)
+	{
+	  gchar *c;
+
+	  c = key->symbol;
+	  while (*c != 0)
+	    {
+	      *c = to_lower (*c);
+	      c++;
+	    }
+	}
+
+      g_hash_table_insert (scanner->symbol_table, key, key);
+    }
+  else
+    key->value = value;
+}
+
+void
+json_scanner_scope_remove_symbol (JsonScanner *scanner,
+                                  guint        scope_id,
+                                  const gchar *symbol)
+{
+  JsonScannerKey *key;
+
+  g_return_if_fail (scanner != NULL);
+  g_return_if_fail (symbol != NULL);
+
+  key = json_scanner_lookup_internal (scanner, scope_id, symbol);
+  if (key)
+    {
+      g_hash_table_remove (scanner->symbol_table, key);
+      g_free (key->symbol);
+      g_slice_free (JsonScannerKey, key);
+    }
+}
+
+gpointer
+json_scanner_lookup_symbol (JsonScanner *scanner,
+                            const gchar *symbol)
+{
+  JsonScannerKey *key;
+  guint scope_id;
+
+  g_return_val_if_fail (scanner != NULL, NULL);
+
+  if (!symbol)
+    return NULL;
+
+  scope_id = scanner->scope_id;
+  key = json_scanner_lookup_internal (scanner, scope_id, symbol);
+  if (!key && scope_id && scanner->config->scope_0_fallback)
+    key = json_scanner_lookup_internal (scanner, 0, symbol);
+
+  if (key)
+    return key->value;
+  else
+    return NULL;
+}
+
+gpointer
+json_scanner_scope_lookup_symbol (JsonScanner *scanner,
+                                  guint        scope_id,
+                                  const gchar *symbol)
+{
+  JsonScannerKey *key;
+
+  g_return_val_if_fail (scanner != NULL, NULL);
+
+  if (!symbol)
+    return NULL;
+
+  key = json_scanner_lookup_internal (scanner, scope_id, symbol);
+
+  if (key)
+    return key->value;
+  else
+    return NULL;
+}
+
+guint
+json_scanner_set_scope (JsonScanner *scanner,
+                        guint        scope_id)
+{
+  guint old_scope_id;
+
+  g_return_val_if_fail (scanner != NULL, 0);
+
+  old_scope_id = scanner->scope_id;
+  scanner->scope_id = scope_id;
+
+  return old_scope_id;
+}
+
+typedef struct {
+  GHFunc func;
+  gpointer data;
+  guint scope_id;
+} ForeachClosure;
+
+static void
+json_scanner_foreach_internal (gpointer _key,
+                               gpointer _value,
+                               gpointer _user_data)
+{
+  JsonScannerKey *key = _value;
+  ForeachClosure *closure = _user_data;
+
+  if (key->scope_id == closure->scope_id)
+    closure->func (key->symbol, key->value, closure->data);
+}
+
+void
+json_scanner_scope_foreach_symbol (JsonScanner *scanner,
+                                   guint        scope_id,
+                                   GHFunc       func,
+                                   gpointer     user_data)
+{
+  ForeachClosure closure;
+
+  g_return_if_fail (scanner != NULL);
+  g_return_if_fail (func != NULL);
+
+  closure.func = func;
+  closure.data = user_data;
+  closure.scope_id = scope_id;
+
+  g_hash_table_foreach (scanner->symbol_table,
+                        json_scanner_foreach_internal,
+                        &closure);
+}
+
+GTokenType
+json_scanner_peek_next_token (JsonScanner *scanner)
+{
+  g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
+
+  if (scanner->next_token == G_TOKEN_NONE)
+    {
+      scanner->next_line = scanner->line;
+      scanner->next_position = scanner->position;
+      json_scanner_get_token_i (scanner,
+                                &scanner->next_token,
+                                &scanner->next_value,
+                                &scanner->next_line,
+                                &scanner->next_position);
+    }
+
+  return scanner->next_token;
+}
+
+GTokenType
+json_scanner_get_next_token (JsonScanner *scanner)
+{
+  g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
+
+  if (scanner->next_token != G_TOKEN_NONE)
+    {
+      json_scanner_free_value (&scanner->token, &scanner->value);
+
+      scanner->token = scanner->next_token;
+      scanner->value = scanner->next_value;
+      scanner->line = scanner->next_line;
+      scanner->position = scanner->next_position;
+      scanner->next_token = G_TOKEN_NONE;
+    }
+  else
+    json_scanner_get_token_i (scanner,
+                              &scanner->token,
+                              &scanner->value,
+                              &scanner->line,
+                              &scanner->position);
+
+  return scanner->token;
+}
+
+GTokenType
+json_scanner_cur_token (JsonScanner *scanner)
+{
+  g_return_val_if_fail (scanner != NULL, G_TOKEN_EOF);
+
+  return scanner->token;
+}
+
+GTokenValue
+json_scanner_cur_value (JsonScanner *scanner)
+{
+  GTokenValue v;
+
+  v.v_int64 = 0;
+
+  g_return_val_if_fail (scanner != NULL, v);
+
+  /* MSC isn't capable of handling return scanner->value; ? */
+
+  v = scanner->value;
+
+  return v;
+}
+
+guint
+json_scanner_cur_line (JsonScanner *scanner)
+{
+  g_return_val_if_fail (scanner != NULL, 0);
+
+  return scanner->line;
+}
+
+guint
+json_scanner_cur_position (JsonScanner *scanner)
+{
+  g_return_val_if_fail (scanner != NULL, 0);
+
+  return scanner->position;
+}
+
+gboolean
+json_scanner_eof (JsonScanner *scanner)
+{
+  g_return_val_if_fail (scanner != NULL, TRUE);
+
+  return scanner->token == G_TOKEN_EOF || scanner->token == G_TOKEN_ERROR;
+}
+
+void
+json_scanner_input_file (JsonScanner *scanner,
+                         gint         input_fd)
+{
+  g_return_if_fail (scanner != NULL);
+  g_return_if_fail (input_fd >= 0);
+
+  if (scanner->input_fd >= 0)
+    json_scanner_sync_file_offset (scanner);
+
+  scanner->token = G_TOKEN_NONE;
+  scanner->value.v_int64 = 0;
+  scanner->line = 1;
+  scanner->position = 0;
+  scanner->next_token = G_TOKEN_NONE;
+
+  scanner->input_fd = input_fd;
+  scanner->text = NULL;
+  scanner->text_end = NULL;
+
+  if (!scanner->buffer)
+    scanner->buffer = g_new (gchar, READ_BUFFER_SIZE + 1);
+}
+
+void
+json_scanner_input_text (JsonScanner *scanner,
+                         const gchar *text,
+                         guint        text_len)
+{
+  g_return_if_fail (scanner != NULL);
+  if (text_len)
+    g_return_if_fail (text != NULL);
+  else
+    text = NULL;
+
+  if (scanner->input_fd >= 0)
+    json_scanner_sync_file_offset (scanner);
+
+  scanner->token = G_TOKEN_NONE;
+  scanner->value.v_int64 = 0;
+  scanner->line = 1;
+  scanner->position = 0;
+  scanner->next_token = G_TOKEN_NONE;
+
+  scanner->input_fd = -1;
+  scanner->text = text;
+  scanner->text_end = text + text_len;
+
+  if (scanner->buffer)
+    {
+      g_free (scanner->buffer);
+      scanner->buffer = NULL;
+    }
+}
+
+static guchar
+json_scanner_peek_next_char (JsonScanner *scanner)
+{
+  if (scanner->text < scanner->text_end)
+    return *scanner->text;
+  else if (scanner->input_fd >= 0)
+    {
+      gint count;
+      gchar *buffer;
+
+      buffer = scanner->buffer;
+      do
+	{
+	  count = read (scanner->input_fd, buffer, READ_BUFFER_SIZE);
+	}
+      while (count == -1 && (errno == EINTR || errno == EAGAIN));
+
+      if (count < 1)
+	{
+	  scanner->input_fd = -1;
+
+	  return 0;
+	}
+      else
+	{
+	  scanner->text = buffer;
+	  scanner->text_end = buffer + count;
+
+	  return *buffer;
+	}
+    }
+  else
+    return 0;
+}
+
+void
+json_scanner_sync_file_offset (JsonScanner *scanner)
+{
+  g_return_if_fail (scanner != NULL);
+
+  /* for file input, rewind the filedescriptor to the current
+   * buffer position and blow the file read ahead buffer. useful
+   * for third party uses of our file descriptor, which hooks 
+   * onto the current scanning position.
+   */
+
+  if (scanner->input_fd >= 0 && scanner->text_end > scanner->text)
+    {
+      gint buffered;
+
+      buffered = scanner->text_end - scanner->text;
+      if (lseek (scanner->input_fd, - buffered, SEEK_CUR) >= 0)
+	{
+	  /* we succeeded, blow our buffer's contents now */
+	  scanner->text = NULL;
+	  scanner->text_end = NULL;
+	}
+      else
+	errno = 0;
+    }
+}
+
+static guchar
+json_scanner_get_char (JsonScanner *scanner,
+                       guint       *line_p,
+                       guint       *position_p)
+{
+  guchar fchar;
+
+  if (scanner->text < scanner->text_end)
+    fchar = *(scanner->text++);
+  else if (scanner->input_fd >= 0)
+    {
+      gint count;
+      gchar *buffer;
+
+      buffer = scanner->buffer;
+      do
+	{
+	  count = read (scanner->input_fd, buffer, READ_BUFFER_SIZE);
+	}
+      while (count == -1 && (errno == EINTR || errno == EAGAIN));
+
+      if (count < 1)
+	{
+	  scanner->input_fd = -1;
+	  fchar = 0;
+	}
+      else
+	{
+	  scanner->text = buffer + 1;
+	  scanner->text_end = buffer + count;
+	  fchar = *buffer;
+	  if (!fchar)
+	    {
+	      json_scanner_sync_file_offset (scanner);
+	      scanner->text_end = scanner->text;
+	      scanner->input_fd = -1;
+	    }
+	}
+    }
+  else
+    fchar = 0;
+  
+  if (fchar == '\n')
+    {
+      (*position_p) = 0;
+      (*line_p)++;
+    }
+  else if (fchar)
+    {
+      (*position_p)++;
+    }
+  
+  return fchar;
+}
+
+#define is_hex_digit(c)         (((c) >= '0' && (c) <= '9') || \
+                                 ((c) >= 'a' && (c) <= 'f') || \
+                                 ((c) >= 'A' && (c) <= 'F'))
+#define to_hex_digit(c)         (((c) <= '9') ? (c) - '0' : ((c) & 7) + 9)
+
+static gunichar
+json_scanner_get_unichar (JsonScanner *scanner,
+                          guint       *line_p,
+                          guint       *position_p)
+{
+  gunichar uchar;
+  gchar ch;
+  gint i;
+
+  uchar = 0;
+  for (i = 0; i < 4; i++)
+    {
+      ch = json_scanner_get_char (scanner, line_p, position_p);
+
+      if (is_hex_digit (ch))
+        uchar += ((gunichar) to_hex_digit (ch) << ((3 - i) * 4));
+      else
+        break;
+    }
+
+  g_assert (g_unichar_validate (uchar) || g_unichar_type (uchar) == G_UNICODE_SURROGATE);
+
+  return uchar;
+}
+
+void
+json_scanner_unexp_token (JsonScanner *scanner,
+                          GTokenType   expected_token,
+                          const gchar *identifier_spec,
+                          const gchar *symbol_spec,
+                          const gchar *symbol_name,
+                          const gchar *message,
+                          gint         is_error)
+{
+  gchar	*token_string;
+  guint	token_string_len;
+  gchar	*expected_string;
+  guint	expected_string_len;
+  gchar	*message_prefix;
+  gboolean print_unexp;
+  void (*msg_handler) (JsonScanner*, const gchar*, ...);
+  
+  g_return_if_fail (scanner != NULL);
+  
+  if (is_error)
+    msg_handler = json_scanner_error;
+  else
+    msg_handler = json_scanner_warn;
+  
+  if (!identifier_spec)
+    identifier_spec = "identifier";
+  if (!symbol_spec)
+    symbol_spec = "symbol";
+  
+  token_string_len = 56;
+  token_string = g_new (gchar, token_string_len + 1);
+  expected_string_len = 64;
+  expected_string = g_new (gchar, expected_string_len + 1);
+  print_unexp = TRUE;
+  
+  switch (scanner->token)
+    {
+    case G_TOKEN_EOF:
+      g_snprintf (token_string, token_string_len, "end of file");
+      break;
+      
+    default:
+      if (scanner->token >= 1 && scanner->token <= 255)
+	{
+	  if ((scanner->token >= ' ' && scanner->token <= '~') ||
+	      strchr (scanner->config->cset_identifier_first, scanner->token) ||
+	      strchr (scanner->config->cset_identifier_nth, scanner->token))
+	    g_snprintf (token_string, token_string_len, "character `%c'", scanner->token);
+	  else
+	    g_snprintf (token_string, token_string_len, "character `\\%o'", scanner->token);
+	  break;
+	}
+      else if (!scanner->config->symbol_2_token)
+	{
+	  g_snprintf (token_string, token_string_len, "(unknown) token <%d>", scanner->token);
+	  break;
+	}
+      /* fall through */
+    case G_TOKEN_SYMBOL:
+      if (expected_token == G_TOKEN_SYMBOL ||
+	  (scanner->config->symbol_2_token &&
+	   expected_token > G_TOKEN_LAST))
+	print_unexp = FALSE;
+      if (symbol_name)
+	g_snprintf (token_string, token_string_len,
+                    "%s%s `%s'",
+                    print_unexp ? "" : "invalid ",
+                    symbol_spec,
+                    symbol_name);
+      else
+	g_snprintf (token_string, token_string_len,
+                    "%s%s",
+                    print_unexp ? "" : "invalid ",
+                    symbol_spec);
+      break;
+ 
+    case G_TOKEN_ERROR:
+      print_unexp = FALSE;
+      expected_token = G_TOKEN_NONE;
+      switch (scanner->value.v_error)
+	{
+	case G_ERR_UNEXP_EOF:
+	  g_snprintf (token_string, token_string_len, "scanner: unexpected end of file");
+	  break;
+	  
+	case G_ERR_UNEXP_EOF_IN_STRING:
+	  g_snprintf (token_string, token_string_len, "scanner: unterminated string constant");
+	  break;
+	  
+	case G_ERR_UNEXP_EOF_IN_COMMENT:
+	  g_snprintf (token_string, token_string_len, "scanner: unterminated comment");
+	  break;
+	  
+	case G_ERR_NON_DIGIT_IN_CONST:
+	  g_snprintf (token_string, token_string_len, "scanner: non digit in constant");
+	  break;
+	  
+	case G_ERR_FLOAT_RADIX:
+	  g_snprintf (token_string, token_string_len, "scanner: invalid radix for floating constant");
+	  break;
+	  
+	case G_ERR_FLOAT_MALFORMED:
+	  g_snprintf (token_string, token_string_len, "scanner: malformed floating constant");
+	  break;
+	  
+	case G_ERR_DIGIT_RADIX:
+	  g_snprintf (token_string, token_string_len, "scanner: digit is beyond radix");
+	  break;
+	  
+	case G_ERR_UNKNOWN:
+	default:
+	  g_snprintf (token_string, token_string_len, "scanner: unknown error");
+	  break;
+	}
+      break;
+      
+    case G_TOKEN_CHAR:
+      g_snprintf (token_string, token_string_len, "character `%c'", scanner->value.v_char);
+      break;
+      
+    case G_TOKEN_IDENTIFIER:
+    case G_TOKEN_IDENTIFIER_NULL:
+      if (expected_token == G_TOKEN_IDENTIFIER ||
+	  expected_token == G_TOKEN_IDENTIFIER_NULL)
+	print_unexp = FALSE;
+      g_snprintf (token_string, token_string_len,
+                  "%s%s `%s'",
+                  print_unexp ? "" : "invalid ",
+                  identifier_spec,
+                  scanner->token == G_TOKEN_IDENTIFIER ? scanner->value.v_string : "null");
+      break;
+      
+    case G_TOKEN_BINARY:
+    case G_TOKEN_OCTAL:
+    case G_TOKEN_INT:
+    case G_TOKEN_HEX:
+      if (scanner->config->store_int64)
+	g_snprintf (token_string, token_string_len, "number `%" G_GUINT64_FORMAT "'", scanner->value.v_int64);
+      else
+	g_snprintf (token_string, token_string_len, "number `%lu'", scanner->value.v_int);
+      break;
+      
+    case G_TOKEN_FLOAT:
+      g_snprintf (token_string, token_string_len, "number `%.3f'", scanner->value.v_float);
+      break;
+      
+    case G_TOKEN_STRING:
+      if (expected_token == G_TOKEN_STRING)
+	print_unexp = FALSE;
+      g_snprintf (token_string, token_string_len,
+                  "%s%sstring constant \"%s\"",
+                  print_unexp ? "" : "invalid ",
+                  scanner->value.v_string[0] == 0 ? "empty " : "",
+                  scanner->value.v_string);
+      token_string[token_string_len - 2] = '"';
+      token_string[token_string_len - 1] = 0;
+      break;
+      
+    case G_TOKEN_COMMENT_SINGLE:
+    case G_TOKEN_COMMENT_MULTI:
+      g_snprintf (token_string, token_string_len, "comment");
+      break;
+      
+    case G_TOKEN_NONE:
+      /* somehow the user's parsing code is screwed, there isn't much
+       * we can do about it.
+       * Note, a common case to trigger this is
+       * json_scanner_peek_next_token(); json_scanner_unexp_token();
+       * without an intermediate json_scanner_get_next_token().
+       */
+      g_assert_not_reached ();
+      break;
+    }
+  
+  
+  switch (expected_token)
+    {
+      gboolean need_valid;
+      gchar *tstring;
+    case G_TOKEN_EOF:
+      g_snprintf (expected_string, expected_string_len, "end of file");
+      break;
+    default:
+      if (expected_token >= 1 && expected_token <= 255)
+	{
+	  if ((expected_token >= ' ' && expected_token <= '~') ||
+	      strchr (scanner->config->cset_identifier_first, expected_token) ||
+	      strchr (scanner->config->cset_identifier_nth, expected_token))
+	    g_snprintf (expected_string, expected_string_len, "character `%c'", expected_token);
+	  else
+	    g_snprintf (expected_string, expected_string_len, "character `\\%o'", expected_token);
+	  break;
+	}
+      else if (!scanner->config->symbol_2_token)
+	{
+	  g_snprintf (expected_string, expected_string_len, "(unknown) token <%d>", expected_token);
+	  break;
+	}
+      /* fall through */
+    case G_TOKEN_SYMBOL:
+      need_valid = (scanner->token == G_TOKEN_SYMBOL ||
+		    (scanner->config->symbol_2_token &&
+		     scanner->token > G_TOKEN_LAST));
+      g_snprintf (expected_string, expected_string_len,
+                  "%s%s",
+                  need_valid ? "valid " : "",
+                  symbol_spec);
+      /* FIXME: should we attempt to lookup the symbol_name for symbol_2_token? */
+      break;
+    case G_TOKEN_CHAR:
+      g_snprintf (expected_string, expected_string_len, "%scharacter",
+		  scanner->token == G_TOKEN_CHAR ? "valid " : "");
+      break;
+    case G_TOKEN_BINARY:
+      tstring = "binary";
+      g_snprintf (expected_string, expected_string_len, "%snumber (%s)",
+		  scanner->token == expected_token ? "valid " : "", tstring);
+      break;
+    case G_TOKEN_OCTAL:
+      tstring = "octal";
+      g_snprintf (expected_string, expected_string_len, "%snumber (%s)",
+		  scanner->token == expected_token ? "valid " : "", tstring);
+      break;
+    case G_TOKEN_INT:
+      tstring = "integer";
+      g_snprintf (expected_string, expected_string_len, "%snumber (%s)",
+		  scanner->token == expected_token ? "valid " : "", tstring);
+      break;
+    case G_TOKEN_HEX:
+      tstring = "hexadecimal";
+      g_snprintf (expected_string, expected_string_len, "%snumber (%s)",
+		  scanner->token == expected_token ? "valid " : "", tstring);
+      break;
+    case G_TOKEN_FLOAT:
+      tstring = "float";
+      g_snprintf (expected_string, expected_string_len, "%snumber (%s)",
+		  scanner->token == expected_token ? "valid " : "", tstring);
+      break;
+    case G_TOKEN_STRING:
+      g_snprintf (expected_string,
+		  expected_string_len,
+		  "%sstring constant",
+		  scanner->token == G_TOKEN_STRING ? "valid " : "");
+      break;
+    case G_TOKEN_IDENTIFIER:
+    case G_TOKEN_IDENTIFIER_NULL:
+      need_valid = (scanner->token == G_TOKEN_IDENTIFIER_NULL ||
+		    scanner->token == G_TOKEN_IDENTIFIER);
+      g_snprintf (expected_string,
+		  expected_string_len,
+		  "%s%s",
+		  need_valid ? "valid " : "",
+		  identifier_spec);
+      break;
+    case G_TOKEN_COMMENT_SINGLE:
+      tstring = "single-line";
+      g_snprintf (expected_string, expected_string_len, "%scomment (%s)",
+		  scanner->token == expected_token ? "valid " : "", tstring);
+      break;
+    case G_TOKEN_COMMENT_MULTI:
+      tstring = "multi-line";
+      g_snprintf (expected_string, expected_string_len, "%scomment (%s)",
+		  scanner->token == expected_token ? "valid " : "", tstring);
+      break;
+    case G_TOKEN_NONE:
+    case G_TOKEN_ERROR:
+      /* this is handled upon printout */
+      break;
+    }
+  
+  if (message && message[0] != 0)
+    message_prefix = " - ";
+  else
+    {
+      message_prefix = "";
+      message = "";
+    }
+  if (expected_token == G_TOKEN_ERROR)
+    {
+      msg_handler (scanner,
+		   "failure around %s%s%s",
+		   token_string,
+		   message_prefix,
+		   message);
+    }
+  else if (expected_token == G_TOKEN_NONE)
+    {
+      if (print_unexp)
+	msg_handler (scanner,
+		     "unexpected %s%s%s",
+		     token_string,
+		     message_prefix,
+		     message);
+      else
+	msg_handler (scanner,
+		     "%s%s%s",
+		     token_string,
+		     message_prefix,
+		     message);
+    }
+  else
+    {
+      if (print_unexp)
+	msg_handler (scanner,
+		     "unexpected %s, expected %s%s%s",
+		     token_string,
+		     expected_string,
+		     message_prefix,
+		     message);
+      else
+	msg_handler (scanner,
+		     "%s, expected %s%s%s",
+		     token_string,
+		     expected_string,
+		     message_prefix,
+		     message);
+    }
+  
+  g_free (token_string);
+  g_free (expected_string);
+}
+
+static void
+json_scanner_get_token_i (JsonScanner	*scanner,
+		       GTokenType	*token_p,
+		       GTokenValue	*value_p,
+		       guint		*line_p,
+		       guint		*position_p)
+{
+  do
+    {
+      json_scanner_free_value (token_p, value_p);
+      json_scanner_get_token_ll (scanner, token_p, value_p, line_p, position_p);
+    }
+  while (((*token_p > 0 && *token_p < 256) &&
+	  strchr (scanner->config->cset_skip_characters, *token_p)) ||
+	 (*token_p == G_TOKEN_CHAR &&
+	  strchr (scanner->config->cset_skip_characters, value_p->v_char)) ||
+	 (*token_p == G_TOKEN_COMMENT_MULTI &&
+	  scanner->config->skip_comment_multi) ||
+	 (*token_p == G_TOKEN_COMMENT_SINGLE &&
+	  scanner->config->skip_comment_single));
+  
+  switch (*token_p)
+    {
+    case G_TOKEN_IDENTIFIER:
+      if (scanner->config->identifier_2_string)
+	*token_p = G_TOKEN_STRING;
+      break;
+      
+    case G_TOKEN_SYMBOL:
+      if (scanner->config->symbol_2_token)
+	*token_p = (GTokenType) value_p->v_symbol;
+      break;
+      
+    case G_TOKEN_BINARY:
+    case G_TOKEN_OCTAL:
+    case G_TOKEN_HEX:
+      if (scanner->config->numbers_2_int)
+	*token_p = G_TOKEN_INT;
+      break;
+      
+    default:
+      break;
+    }
+  
+  if (*token_p == G_TOKEN_INT &&
+      scanner->config->int_2_float)
+    {
+      *token_p = G_TOKEN_FLOAT;
+      if (scanner->config->store_int64)
+        {
+#ifdef _MSC_VER
+          /* work around error C2520, see gvaluetransform.c */
+          value_p->v_float = (__int64)value_p->v_int64;
+#else
+          value_p->v_float = value_p->v_int64;
+#endif
+        }
+      else
+	value_p->v_float = value_p->v_int;
+    }
+  
+  errno = 0;
+}
+
+static void
+json_scanner_get_token_ll (JsonScanner *scanner,
+                           GTokenType  *token_p,
+                           GTokenValue *value_p,
+                           guint       *line_p,
+                           guint       *position_p)
+{
+  JsonScannerConfig *config;
+  GTokenType	   token;
+  gboolean	   in_comment_multi;
+  gboolean	   in_comment_single;
+  gboolean	   in_string_sq;
+  gboolean	   in_string_dq;
+  GString	  *gstring;
+  GTokenValue	   value;
+  guchar	   ch;
+  
+  config = scanner->config;
+  (*value_p).v_int64 = 0;
+  
+  if ((scanner->text >= scanner->text_end && scanner->input_fd < 0) ||
+      scanner->token == G_TOKEN_EOF)
+    {
+      *token_p = G_TOKEN_EOF;
+      return;
+    }
+  
+  in_comment_multi = FALSE;
+  in_comment_single = FALSE;
+  in_string_sq = FALSE;
+  in_string_dq = FALSE;
+  gstring = NULL;
+  
+  do /* while (ch != 0) */
+    {
+      gboolean dotted_float = FALSE;
+      
+      ch = json_scanner_get_char (scanner, line_p, position_p);
+      
+      value.v_int64 = 0;
+      token = G_TOKEN_NONE;
+      
+      /* this is *evil*, but needed ;(
+       * we first check for identifier first character, because	 it
+       * might interfere with other key chars like slashes or numbers
+       */
+      if (config->scan_identifier &&
+	  ch && strchr (config->cset_identifier_first, ch))
+	goto identifier_precedence;
+      
+      switch (ch)
+	{
+	case 0:
+	  token = G_TOKEN_EOF;
+	  (*position_p)++;
+	  /* ch = 0; */
+	  break;
+	  
+	case '/':
+	  if (!config->scan_comment_multi ||
+	      json_scanner_peek_next_char (scanner) != '*')
+	    goto default_case;
+	  json_scanner_get_char (scanner, line_p, position_p);
+	  token = G_TOKEN_COMMENT_MULTI;
+	  in_comment_multi = TRUE;
+	  gstring = g_string_new (NULL);
+	  while ((ch = json_scanner_get_char (scanner, line_p, position_p)) != 0)
+	    {
+	      if (ch == '*' && json_scanner_peek_next_char (scanner) == '/')
+		{
+		  json_scanner_get_char (scanner, line_p, position_p);
+		  in_comment_multi = FALSE;
+		  break;
+		}
+	      else
+		gstring = g_string_append_c (gstring, ch);
+	    }
+	  ch = 0;
+	  break;
+	  
+	case '\'':
+	  if (!config->scan_string_sq)
+	    goto default_case;
+	  token = G_TOKEN_STRING;
+	  in_string_sq = TRUE;
+	  gstring = g_string_new (NULL);
+	  while ((ch = json_scanner_get_char (scanner, line_p, position_p)) != 0)
+	    {
+	      if (ch == '\'')
+		{
+		  in_string_sq = FALSE;
+		  break;
+		}
+	      else
+		gstring = g_string_append_c (gstring, ch);
+	    }
+	  ch = 0;
+	  break;
+	  
+	case '"':
+	  if (!config->scan_string_dq)
+	    goto default_case;
+	  token = G_TOKEN_STRING;
+	  in_string_dq = TRUE;
+	  gstring = g_string_new (NULL);
+	  while ((ch = json_scanner_get_char (scanner, line_p, position_p)) != 0)
+	    {
+	      if (ch == '"')
+		{
+		  in_string_dq = FALSE;
+		  break;
+		}
+	      else
+		{
+		  if (ch == '\\')
+		    {
+		      ch = json_scanner_get_char (scanner, line_p, position_p);
+		      switch (ch)
+			{
+			  guint	i;
+			  guint	fchar;
+			  
+			case 0:
+			  break;
+			  
+			case '\\':
+			  gstring = g_string_append_c (gstring, '\\');
+			  break;
+			  
+			case 'n':
+			  gstring = g_string_append_c (gstring, '\n');
+			  break;
+			  
+			case 't':
+			  gstring = g_string_append_c (gstring, '\t');
+			  break;
+			  
+			case 'r':
+			  gstring = g_string_append_c (gstring, '\r');
+			  break;
+			  
+			case 'b':
+			  gstring = g_string_append_c (gstring, '\b');
+			  break;
+			  
+			case 'f':
+			  gstring = g_string_append_c (gstring, '\f');
+			  break;
+
+                        case 'u':
+                          fchar = json_scanner_peek_next_char (scanner);
+                          if (is_hex_digit (fchar))
+                            {
+                              gunichar ucs;
+
+                              ucs = json_scanner_get_unichar (scanner, line_p, position_p);
+
+                              if (g_unichar_type (ucs) == G_UNICODE_SURROGATE)
+                                {
+                                  /* read next surrogate */
+                                  if ('\\' == json_scanner_get_char (scanner, line_p, position_p)
+                                      && 'u' == json_scanner_get_char (scanner, line_p, position_p))
+                                    {
+                                      gunichar ucs_lo = json_scanner_get_unichar (scanner, line_p, position_p);
+                                      g_assert (g_unichar_type (ucs_lo) == G_UNICODE_SURROGATE);
+                                      ucs = (((ucs & 0x3ff) << 10) | (ucs_lo & 0x3ff)) + 0x10000;
+                                    }
+                                }
+
+                              g_assert (g_unichar_validate (ucs));
+                              gstring = g_string_append_unichar (gstring, ucs);
+                            }
+                          break;
+			  
+			case '0':
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			  i = ch - '0';
+			  fchar = json_scanner_peek_next_char (scanner);
+			  if (fchar >= '0' && fchar <= '7')
+			    {
+			      ch = json_scanner_get_char (scanner, line_p, position_p);
+			      i = i * 8 + ch - '0';
+			      fchar = json_scanner_peek_next_char (scanner);
+			      if (fchar >= '0' && fchar <= '7')
+				{
+				  ch = json_scanner_get_char (scanner, line_p, position_p);
+				  i = i * 8 + ch - '0';
+				}
+			    }
+			  gstring = g_string_append_c (gstring, i);
+			  break;
+			  
+			default:
+			  gstring = g_string_append_c (gstring, ch);
+			  break;
+			}
+		    }
+		  else
+		    gstring = g_string_append_c (gstring, ch);
+		}
+	    }
+	  ch = 0;
+	  break;
+	  
+	case '.':
+	  if (!config->scan_float)
+	    goto default_case;
+	  token = G_TOKEN_FLOAT;
+	  dotted_float = TRUE;
+	  ch = json_scanner_get_char (scanner, line_p, position_p);
+	  goto number_parsing;
+	  
+	case '$':
+	  if (!config->scan_hex_dollar)
+	    goto default_case;
+	  token = G_TOKEN_HEX;
+	  ch = json_scanner_get_char (scanner, line_p, position_p);
+	  goto number_parsing;
+	  
+	case '0':
+	  if (config->scan_octal)
+	    token = G_TOKEN_OCTAL;
+	  else
+	    token = G_TOKEN_INT;
+	  ch = json_scanner_peek_next_char (scanner);
+	  if (config->scan_hex && (ch == 'x' || ch == 'X'))
+	    {
+	      token = G_TOKEN_HEX;
+	      json_scanner_get_char (scanner, line_p, position_p);
+	      ch = json_scanner_get_char (scanner, line_p, position_p);
+	      if (ch == 0)
+		{
+		  token = G_TOKEN_ERROR;
+		  value.v_error = G_ERR_UNEXP_EOF;
+		  (*position_p)++;
+		  break;
+		}
+	      if (json_scanner_char_2_num (ch, 16) < 0)
+		{
+		  token = G_TOKEN_ERROR;
+		  value.v_error = G_ERR_DIGIT_RADIX;
+		  ch = 0;
+		  break;
+		}
+	    }
+	  else if (config->scan_binary && (ch == 'b' || ch == 'B'))
+	    {
+	      token = G_TOKEN_BINARY;
+	      json_scanner_get_char (scanner, line_p, position_p);
+	      ch = json_scanner_get_char (scanner, line_p, position_p);
+	      if (ch == 0)
+		{
+		  token = G_TOKEN_ERROR;
+		  value.v_error = G_ERR_UNEXP_EOF;
+		  (*position_p)++;
+		  break;
+		}
+	      if (json_scanner_char_2_num (ch, 10) < 0)
+		{
+		  token = G_TOKEN_ERROR;
+		  value.v_error = G_ERR_NON_DIGIT_IN_CONST;
+		  ch = 0;
+		  break;
+		}
+	    }
+	  else
+	    ch = '0';
+	  /* fall through */
+	case '1':
+	case '2':
+	case '3':
+	case '4':
+	case '5':
+	case '6':
+	case '7':
+	case '8':
+	case '9':
+	number_parsing:
+	{
+          gboolean in_number = TRUE;
+	  gchar *endptr;
+	  
+	  if (token == G_TOKEN_NONE)
+	    token = G_TOKEN_INT;
+	  
+	  gstring = g_string_new (dotted_float ? "0." : "");
+	  gstring = g_string_append_c (gstring, ch);
+	  
+	  do /* while (in_number) */
+	    {
+	      gboolean is_E;
+	      
+	      is_E = token == G_TOKEN_FLOAT && (ch == 'e' || ch == 'E');
+	      
+	      ch = json_scanner_peek_next_char (scanner);
+	      
+	      if (json_scanner_char_2_num (ch, 36) >= 0 ||
+		  (config->scan_float && ch == '.') ||
+		  (is_E && (ch == '+' || ch == '-')))
+		{
+		  ch = json_scanner_get_char (scanner, line_p, position_p);
+		  
+		  switch (ch)
+		    {
+		    case '.':
+		      if (token != G_TOKEN_INT && token != G_TOKEN_OCTAL)
+			{
+			  value.v_error = token == G_TOKEN_FLOAT ? G_ERR_FLOAT_MALFORMED : G_ERR_FLOAT_RADIX;
+			  token = G_TOKEN_ERROR;
+			  in_number = FALSE;
+			}
+		      else
+			{
+			  token = G_TOKEN_FLOAT;
+			  gstring = g_string_append_c (gstring, ch);
+			}
+		      break;
+		      
+		    case '0':
+		    case '1':
+		    case '2':
+		    case '3':
+		    case '4':
+		    case '5':
+		    case '6':
+		    case '7':
+		    case '8':
+		    case '9':
+		      gstring = g_string_append_c (gstring, ch);
+		      break;
+		      
+		    case '-':
+		    case '+':
+		      if (token != G_TOKEN_FLOAT)
+			{
+			  token = G_TOKEN_ERROR;
+			  value.v_error = G_ERR_NON_DIGIT_IN_CONST;
+			  in_number = FALSE;
+			}
+		      else
+			gstring = g_string_append_c (gstring, ch);
+		      break;
+		      
+		    case 'e':
+		    case 'E':
+		      if ((token != G_TOKEN_HEX && !config->scan_float) ||
+			  (token != G_TOKEN_HEX &&
+			   token != G_TOKEN_OCTAL &&
+			   token != G_TOKEN_FLOAT &&
+			   token != G_TOKEN_INT))
+			{
+			  token = G_TOKEN_ERROR;
+			  value.v_error = G_ERR_NON_DIGIT_IN_CONST;
+			  in_number = FALSE;
+			}
+		      else
+			{
+			  if (token != G_TOKEN_HEX)
+			    token = G_TOKEN_FLOAT;
+			  gstring = g_string_append_c (gstring, ch);
+			}
+		      break;
+		      
+		    default:
+		      if (token != G_TOKEN_HEX)
+			{
+			  token = G_TOKEN_ERROR;
+			  value.v_error = G_ERR_NON_DIGIT_IN_CONST;
+			  in_number = FALSE;
+			}
+		      else
+			gstring = g_string_append_c (gstring, ch);
+		      break;
+		    }
+		}
+	      else
+		in_number = FALSE;
+	    }
+	  while (in_number);
+	  
+	  endptr = NULL;
+	  if (token == G_TOKEN_FLOAT)
+	    value.v_float = g_strtod (gstring->str, &endptr);
+	  else
+	    {
+	      guint64 ui64 = 0;
+	      switch (token)
+		{
+		case G_TOKEN_BINARY:
+		  ui64 = g_ascii_strtoull (gstring->str, &endptr, 2);
+		  break;
+		case G_TOKEN_OCTAL:
+		  ui64 = g_ascii_strtoull (gstring->str, &endptr, 8);
+		  break;
+		case G_TOKEN_INT:
+		  ui64 = g_ascii_strtoull (gstring->str, &endptr, 10);
+		  break;
+		case G_TOKEN_HEX:
+		  ui64 = g_ascii_strtoull (gstring->str, &endptr, 16);
+		  break;
+		default: ;
+		}
+	      if (scanner->config->store_int64)
+		value.v_int64 = ui64;
+	      else
+		value.v_int = ui64;
+	    }
+	  if (endptr && *endptr)
+	    {
+	      token = G_TOKEN_ERROR;
+	      if (*endptr == 'e' || *endptr == 'E')
+		value.v_error = G_ERR_NON_DIGIT_IN_CONST;
+	      else
+		value.v_error = G_ERR_DIGIT_RADIX;
+	    }
+	  g_string_free (gstring, TRUE);
+	  gstring = NULL;
+	  ch = 0;
+	} /* number_parsing:... */
+	break;
+	
+	default:
+	default_case:
+	{
+	  if (config->cpair_comment_single &&
+	      ch == config->cpair_comment_single[0])
+	    {
+	      token = G_TOKEN_COMMENT_SINGLE;
+	      in_comment_single = TRUE;
+	      gstring = g_string_new (NULL);
+	      ch = json_scanner_get_char (scanner, line_p, position_p);
+	      while (ch != 0)
+		{
+		  if (ch == config->cpair_comment_single[1])
+		    {
+		      in_comment_single = FALSE;
+		      ch = 0;
+		      break;
+		    }
+		  
+		  gstring = g_string_append_c (gstring, ch);
+		  ch = json_scanner_get_char (scanner, line_p, position_p);
+		}
+	      /* ignore a missing newline at EOF for single line comments */
+	      if (in_comment_single &&
+		  config->cpair_comment_single[1] == '\n')
+		in_comment_single = FALSE;
+	    }
+	  else if (config->scan_identifier && ch &&
+		   strchr (config->cset_identifier_first, ch))
+	    {
+	    identifier_precedence:
+	      
+	      if (config->cset_identifier_nth && ch &&
+		  strchr (config->cset_identifier_nth,
+			  json_scanner_peek_next_char (scanner)))
+		{
+		  token = G_TOKEN_IDENTIFIER;
+		  gstring = g_string_new (NULL);
+		  gstring = g_string_append_c (gstring, ch);
+		  do
+		    {
+		      ch = json_scanner_get_char (scanner, line_p, position_p);
+		      gstring = g_string_append_c (gstring, ch);
+		      ch = json_scanner_peek_next_char (scanner);
+		    }
+		  while (ch && strchr (config->cset_identifier_nth, ch));
+		  ch = 0;
+		}
+	      else if (config->scan_identifier_1char)
+		{
+		  token = G_TOKEN_IDENTIFIER;
+		  value.v_identifier = g_new0 (gchar, 2);
+		  value.v_identifier[0] = ch;
+		  ch = 0;
+		}
+	    }
+	  if (ch)
+	    {
+	      if (config->char_2_token)
+		token = ch;
+	      else
+		{
+		  token = G_TOKEN_CHAR;
+		  value.v_char = ch;
+		}
+	      ch = 0;
+	    }
+	} /* default_case:... */
+	break;
+	}
+      g_assert (ch == 0 && token != G_TOKEN_NONE); /* paranoid */
+    }
+  while (ch != 0);
+  
+  if (in_comment_multi || in_comment_single ||
+      in_string_sq || in_string_dq)
+    {
+      token = G_TOKEN_ERROR;
+      if (gstring)
+	{
+	  g_string_free (gstring, TRUE);
+	  gstring = NULL;
+	}
+      (*position_p)++;
+      if (in_comment_multi || in_comment_single)
+	value.v_error = G_ERR_UNEXP_EOF_IN_COMMENT;
+      else /* (in_string_sq || in_string_dq) */
+	value.v_error = G_ERR_UNEXP_EOF_IN_STRING;
+    }
+  
+  if (gstring)
+    {
+      value.v_string = g_string_free (gstring, FALSE);
+      gstring = NULL;
+    }
+  
+  if (token == G_TOKEN_IDENTIFIER)
+    {
+      if (config->scan_symbols)
+	{
+	  JsonScannerKey *key;
+	  guint scope_id;
+	  
+	  scope_id = scanner->scope_id;
+	  key = json_scanner_lookup_internal (scanner, scope_id, value.v_identifier);
+	  if (!key && scope_id && scanner->config->scope_0_fallback)
+	    key = json_scanner_lookup_internal (scanner, 0, value.v_identifier);
+	  
+	  if (key)
+	    {
+	      g_free (value.v_identifier);
+	      token = G_TOKEN_SYMBOL;
+	      value.v_symbol = key->value;
+	    }
+	}
+      
+      if (token == G_TOKEN_IDENTIFIER &&
+	  config->scan_identifier_NULL &&
+	  strlen (value.v_identifier) == 4)
+	{
+	  gchar *null_upper = "NULL";
+	  gchar *null_lower = "null";
+	  
+	  if (scanner->config->case_sensitive)
+	    {
+	      if (value.v_identifier[0] == null_upper[0] &&
+		  value.v_identifier[1] == null_upper[1] &&
+		  value.v_identifier[2] == null_upper[2] &&
+		  value.v_identifier[3] == null_upper[3])
+		token = G_TOKEN_IDENTIFIER_NULL;
+	    }
+	  else
+	    {
+	      if ((value.v_identifier[0] == null_upper[0] ||
+		   value.v_identifier[0] == null_lower[0]) &&
+		  (value.v_identifier[1] == null_upper[1] ||
+		   value.v_identifier[1] == null_lower[1]) &&
+		  (value.v_identifier[2] == null_upper[2] ||
+		   value.v_identifier[2] == null_lower[2]) &&
+		  (value.v_identifier[3] == null_upper[3] ||
+		   value.v_identifier[3] == null_lower[3]))
+		token = G_TOKEN_IDENTIFIER_NULL;
+	    }
+	}
+    }
+  
+  *token_p = token;
+  *value_p = value;
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-scanner.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-scanner.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-scanner.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-scanner.h	2011-03-27 09:15:30.764553000 -0600
@@ -0,0 +1,171 @@
+/* json-scanner.h: Tokenizer for JSON
+ *
+ * This file is part of JSON-GLib
+ * Copyright (C) 2008 OpenedHand
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ */
+
+/*
+ * JsonScanner is a specialized tokenizer for JSON adapted from
+ * the GScanner tokenizer in GLib; GScanner came with this notice:
+ * 
+ * Modified by the GLib Team and others 1997-2000.  See the AUTHORS
+ * file for a list of people on the GLib Team.  See the ChangeLog
+ * files for a list of changes.  These files are distributed with
+ * GLib at ftp://ftp.gtk.org/pub/gtk/. 
+ *
+ * JsonScanner: modified by Emmanuele Bassi <ebassi@openedhand.com>
+ */
+
+#ifndef __JSON_SCANNER_H__
+#define __JSON_SCANNER_H__
+
+#include <glib/gdataset.h>
+#include <glib/ghash.h>
+#include <glib/gscanner.h>
+
+G_BEGIN_DECLS
+
+typedef struct _JsonScanner       JsonScanner;
+typedef struct _JsonScannerConfig JsonScannerConfig;
+
+typedef void (* JsonScannerMsgFunc) (JsonScanner *scanner,
+                                     gchar       *message,
+                                     gboolean     is_error);
+
+/**
+ * JsonTokenType:
+ * @JSON_TOKEN_INVALID: marker
+ * @JSON_TOKEN_TRUE: symbol for 'true' bareword
+ * @JSON_TOKEN_FALSE: symbol for 'false' bareword
+ * @JSON_TOKEN_NULL: symbol for 'null' bareword
+ * @JSON_TOKEN_VAR: symbol for 'var' bareword
+ * @JSON_TOKEN_LAST: marker
+ *
+ * Tokens for JsonScanner-based parser, extending #GTokenType.
+ */
+typedef enum {
+  JSON_TOKEN_INVALID = G_TOKEN_LAST,
+
+  JSON_TOKEN_TRUE,
+  JSON_TOKEN_FALSE,
+  JSON_TOKEN_NULL,
+  JSON_TOKEN_VAR,
+
+  JSON_TOKEN_LAST
+} JsonTokenType;
+
+/**
+ * JsonScanner:
+ *
+ * Tokenizer scanner for JSON. See #GScanner
+ *
+ * Since: 0.6
+ */
+struct _JsonScanner
+{
+  /*< private >*/
+  /* unused fields */
+  gpointer user_data;
+  guint max_parse_errors;
+  
+  /* json_scanner_error() increments this field */
+  guint parse_errors;
+  
+  /* name of input stream, featured by the default message handler */
+  const gchar *input_name;
+  
+  /* quarked data */
+  GData *qdata;
+  
+  /* link into the scanner configuration */
+  JsonScannerConfig *config;
+  
+  /* fields filled in after json_scanner_get_next_token() */
+  GTokenType token;
+  GTokenValue value;
+  guint line;
+  guint position;
+  
+  /* fields filled in after json_scanner_peek_next_token() */
+  GTokenType next_token;
+  GTokenValue next_value;
+  guint next_line;
+  guint next_position;
+  
+  /* to be considered private */
+  GHashTable *symbol_table;
+  gint input_fd;
+  const gchar *text;
+  const gchar *text_end;
+  gchar *buffer;
+  guint scope_id;
+  
+  /* handler function for _warn and _error */
+  JsonScannerMsgFunc msg_handler;
+};
+
+JsonScanner *json_scanner_new                  (void);
+void         json_scanner_destroy              (JsonScanner *scanner);
+void         json_scanner_input_file           (JsonScanner *scanner,
+                                                gint         input_fd);
+void         json_scanner_sync_file_offset     (JsonScanner *scanner);
+void         json_scanner_input_text           (JsonScanner *scanner,
+                                                const gchar *text,
+                                                guint        text_len);
+GTokenType   json_scanner_get_next_token       (JsonScanner *scanner);
+GTokenType   json_scanner_peek_next_token      (JsonScanner *scanner);
+GTokenType   json_scanner_cur_token            (JsonScanner *scanner);
+GTokenValue  json_scanner_cur_value            (JsonScanner *scanner);
+guint        json_scanner_cur_line             (JsonScanner *scanner);
+guint        json_scanner_cur_position         (JsonScanner *scanner);
+gboolean     json_scanner_eof                  (JsonScanner *scanner);
+guint        json_scanner_set_scope            (JsonScanner *scanner,
+                                                guint        scope_id);
+void         json_scanner_scope_add_symbol     (JsonScanner *scanner,
+                                                guint        scope_id,
+                                                const gchar *symbol,
+                                                gpointer     value);
+void         json_scanner_scope_remove_symbol  (JsonScanner *scanner,
+                                                guint        scope_id,
+                                                const gchar *symbol);
+gpointer     json_scanner_scope_lookup_symbol  (JsonScanner *scanner,
+                                                guint        scope_id,
+                                                const gchar *symbol);
+void         json_scanner_scope_foreach_symbol (JsonScanner *scanner,
+                                                guint        scope_id,
+                                                GHFunc       func,
+                                                gpointer     user_data);
+gpointer     json_scanner_lookup_symbol        (JsonScanner *scanner,
+                                                const gchar *symbol);
+void         json_scanner_unexp_token          (JsonScanner *scanner,
+                                                GTokenType   expected_token,
+                                                const gchar *identifier_spec,
+                                                const gchar *symbol_spec,
+                                                const gchar *symbol_name,
+                                                const gchar *message,
+                                                gint         is_error);
+void         json_scanner_error                (JsonScanner *scanner,
+                                                const gchar *format,
+                                                ...) G_GNUC_PRINTF (2,3);
+void         json_scanner_warn                 (JsonScanner *scanner,
+                                                const gchar *format,
+                                                ...) G_GNUC_PRINTF (2,3);
+
+G_END_DECLS
+
+#endif /* __JSON_SCANNER_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-serializable.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-serializable.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-serializable.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-serializable.c	2011-03-27 09:15:30.764553000 -0600
@@ -0,0 +1,231 @@
+/* json-gobject.c - JSON GObject integration
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@openedhand.com>
+ */
+
+/**
+ * SECTION:json-serializable
+ * @short_description: Interface for serialize and deserialize special GObjects
+ *
+ * #JsonSerializable is an interface for #GObject classes that
+ * allows controlling how the class is going to be serialized
+ * or deserialized by json_construct_gobject() and
+ * json_serialize_gobject() respectively.
+ */
+
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <string.h>
+#include <stdlib.h>
+
+#include "json-types-private.h"
+#include "json-gobject-private.h"
+#include "json-debug.h"
+
+/**
+ * json_serializable_serialize_property:
+ * @serializable: a #JsonSerializable object
+ * @property_name: the name of the property
+ * @value: the value of the property
+ * @pspec: a #GParamSpec
+ *
+ * Asks a #JsonSerializable implementation to serialize a #GObject
+ * property into a #JsonNode object.
+ *
+ * Return value: a #JsonNode containing the serialized property
+ */
+JsonNode *
+json_serializable_serialize_property (JsonSerializable *serializable,
+                                      const gchar      *property_name,
+                                      const GValue     *value,
+                                      GParamSpec       *pspec)
+{
+  JsonSerializableIface *iface;
+
+  g_return_val_if_fail (JSON_IS_SERIALIZABLE (serializable), NULL);
+  g_return_val_if_fail (property_name != NULL, NULL);
+  g_return_val_if_fail (value != NULL, NULL);
+  g_return_val_if_fail (pspec != NULL, NULL);
+
+  iface = JSON_SERIALIZABLE_GET_IFACE (serializable);
+
+  return iface->serialize_property (serializable, property_name, value, pspec);
+}
+
+/**
+ * json_serializable_deserialize_property:
+ * @serializable: a #JsonSerializable
+ * @property_name: the name of the property
+ * @value: (out): a pointer to an uninitialized #GValue
+ * @pspec: a #GParamSpec
+ * @property_node: a #JsonNode containing the serialized property
+ *
+ * Asks a #JsonSerializable implementation to deserialize the
+ * property contained inside @property_node into @value.
+ *
+ * Return value: %TRUE if the property was successfully deserialized.
+ */
+gboolean
+json_serializable_deserialize_property (JsonSerializable *serializable,
+                                        const gchar      *property_name,
+                                        GValue           *value,
+                                        GParamSpec       *pspec,
+                                        JsonNode         *property_node)
+{
+  JsonSerializableIface *iface;
+
+  g_return_val_if_fail (JSON_IS_SERIALIZABLE (serializable), FALSE);
+  g_return_val_if_fail (property_name != NULL, FALSE);
+  g_return_val_if_fail (value != NULL, FALSE);
+  g_return_val_if_fail (pspec != NULL, FALSE);
+  g_return_val_if_fail (property_node != NULL, FALSE);
+
+  iface = JSON_SERIALIZABLE_GET_IFACE (serializable);
+
+  return iface->deserialize_property (serializable,
+                                      property_name,
+                                      value,
+                                      pspec,
+                                      property_node);
+}
+
+static gboolean
+json_serializable_real_deserialize (JsonSerializable *serializable,
+                                    const gchar      *name,
+                                    GValue           *value,
+                                    GParamSpec       *pspec,
+                                    JsonNode         *node)
+{
+  JSON_NOTE (GOBJECT, "Default deserialization for property '%s'", pspec->name);
+  return json_deserialize_pspec (value, pspec, node);
+}
+
+static JsonNode *
+json_serializable_real_serialize (JsonSerializable *serializable,
+                                  const gchar      *name,
+                                  const GValue     *value,
+                                  GParamSpec       *pspec)
+{
+  JSON_NOTE (GOBJECT, "Default serialization for property '%s'", pspec->name);
+  return json_serialize_pspec (value, pspec);
+}
+
+/* typedef to satisfy G_DEFINE_INTERFACE's naming */
+typedef JsonSerializableIface   JsonSerializableInterface;
+
+static void
+json_serializable_default_init (JsonSerializableInterface *iface)
+{
+  iface->serialize_property = json_serializable_real_serialize;
+  iface->deserialize_property = json_serializable_real_deserialize;
+}
+
+G_DEFINE_INTERFACE (JsonSerializable, json_serializable, G_TYPE_OBJECT);
+
+/**
+ * json_serializable_default_serialize_property:
+ * @serializable: a #JsonSerializable object
+ * @property_name: the name of the property
+ * @value: the value of the property
+ * @pspec: a #GParamSpec
+ *
+ * Calls the default implementation of the #JsonSerializable
+ * serialize_property() virtual function
+ *
+ * This function can be used inside a custom implementation
+ * of the serialize_property() virtual function in lieu of:
+ *
+ * |[
+ *   JsonSerializable *iface;
+ *   JsonNode *node;
+ *
+ *   iface = g_type_default_interface_peek (JSON_TYPE_SERIALIZABLE);
+ *   node = iface->serialize_property (serializable, property_name,
+ *                                     value,
+ *                                     pspec);
+ * ]|
+ *
+ * Return value: (transfer full): a #JsonNode containing the serialized
+ *   property
+ *
+ * Since: 0.10
+ */
+JsonNode *
+json_serializable_default_serialize_property (JsonSerializable *serializable,
+                                              const gchar      *property_name,
+                                              const GValue     *value,
+                                              GParamSpec       *pspec)
+{
+  g_return_val_if_fail (JSON_IS_SERIALIZABLE (serializable), NULL);
+  g_return_val_if_fail (property_name != NULL, NULL);
+  g_return_val_if_fail (value != NULL, NULL);
+  g_return_val_if_fail (pspec != NULL, NULL);
+
+  return json_serializable_real_serialize (serializable,
+                                           property_name,
+                                           value, pspec);
+}
+
+/**
+ * json_serializable_default_deserialize_property:
+ * @serializable: a #JsonSerializable
+ * @property_name: the name of the property
+ * @value: a pointer to an uninitialized #GValue
+ * @pspec: a #GParamSpec
+ * @property_node: a #JsonNode containing the serialized property
+ *
+ * Calls the default implementation of the #JsonSerializable
+ * deserialize_property() virtual function
+ *
+ * This function can be used inside a custom implementation
+ * of the deserialize_property() virtual function in lieu of:
+ *
+ * |[
+ *   JsonSerializable *iface;
+ *   gboolean res;
+ *
+ *   iface = g_type_default_interface_peek (JSON_TYPE_SERIALIZABLE);
+ *   res = iface->deserialize_property (serializable, property_name,
+ *                                      value,
+ *                                      pspec,
+ *                                      property_node);
+ * ]|
+ *
+ * Return value: %TRUE if the property was successfully deserialized.
+ *
+ * Since: 0.10
+ */
+gboolean
+json_serializable_default_deserialize_property (JsonSerializable *serializable,
+                                                const gchar      *property_name,
+                                                GValue           *value,
+                                                GParamSpec       *pspec,
+                                                JsonNode         *property_node)
+{
+  g_return_val_if_fail (JSON_IS_SERIALIZABLE (serializable), FALSE);
+  g_return_val_if_fail (property_name != NULL, FALSE);
+  g_return_val_if_fail (value != NULL, FALSE);
+  g_return_val_if_fail (pspec != NULL, FALSE);
+  g_return_val_if_fail (property_node != NULL, FALSE);
+
+  return json_serializable_real_deserialize (serializable,
+                                             property_name,
+                                             value, pspec,
+                                             property_node);
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-types.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-types.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-types.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-types.h	2011-03-27 09:15:30.772553000 -0600
@@ -0,0 +1,334 @@
+/* json-types.h - JSON data types
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_TYPES_H__
+#define __JSON_TYPES_H__
+
+#include <glib-object.h>
+
+G_BEGIN_DECLS
+
+/**
+ * JSON_NODE_TYPE:
+ * @node: a #JsonNode
+ *
+ * Evaluates to the #JsonNodeType contained by @node
+ */
+#define JSON_NODE_TYPE(node)    (json_node_get_node_type ((node)))
+
+/**
+ * JSON_NODE_HOLDS:
+ * @node: a #JsonNode
+ * @t: a #JsonNodeType
+ *
+ * Evaluates to %TRUE if the @node holds type @t
+ *
+ * Since: 0.10
+ */
+#define JSON_NODE_HOLDS(node,t)         (json_node_get_node_type ((node)) == (t))
+
+/**
+ * JSON_NODE_HOLDS_VALUE:
+ * @node: a #JsonNode
+ *
+ * Evaluates to %TRUE if @node holds a %JSON_NODE_VALUE
+ *
+ * Since: 0.10
+ */
+#define JSON_NODE_HOLDS_VALUE(node)     (JSON_NODE_HOLDS ((node), JSON_NODE_VALUE))
+
+/**
+ * JSON_NODE_HOLDS_OBJECT:
+ * @node: a #JsonNode
+ *
+ * Evaluates to %TRUE if @node holds a %JSON_NODE_OBJECT
+ *
+ * Since: 0.10
+ */
+#define JSON_NODE_HOLDS_OBJECT(node)    (JSON_NODE_HOLDS ((node), JSON_NODE_OBJECT))
+
+/**
+ * JSON_NODE_HOLDS_ARRAY:
+ * @node: a #JsonNode
+ *
+ * Evaluates to %TRUE if @node holds a %JSON_NODE_ARRAY
+ *
+ * Since: 0.10
+ */
+#define JSON_NODE_HOLDS_ARRAY(node)     (JSON_NODE_HOLDS ((node), JSON_NODE_ARRAY))
+
+/**
+ * JSON_NODE_HOLDS_NULL:
+ * @node: a #JsonNode
+ *
+ * Evaluates to %TRUE if @node holds a %JSON_NODE_NULL
+ *
+ * Since: 0.10
+ */
+#define JSON_NODE_HOLDS_NULL(node)      (JSON_NODE_HOLDS ((node), JSON_NODE_NULL))
+
+#define JSON_TYPE_NODE          (json_node_get_type ())
+#define JSON_TYPE_OBJECT        (json_object_get_type ())
+#define JSON_TYPE_ARRAY         (json_array_get_type ())
+
+/**
+ * JsonNode:
+ *
+ * A generic container of JSON data types. The contents of the #JsonNode
+ * structure are private and should only be accessed via the provided
+ * functions and never directly.
+ */
+typedef struct _JsonNode        JsonNode;
+
+/**
+ * JsonObject:
+ *
+ * A JSON object type. The contents of the #JsonObject structure are private
+ * and should only be accessed by the provided API
+ */
+typedef struct _JsonObject      JsonObject;
+
+/**
+ * JsonArray:
+ *
+ * A JSON array type. The contents of the #JsonArray structure are private
+ * and should only be accessed by the provided API
+ */
+typedef struct _JsonArray       JsonArray;
+
+/**
+ * JsonNodeType:
+ * @JSON_NODE_OBJECT: The node contains a #JsonObject
+ * @JSON_NODE_ARRAY: The node contains a #JsonArray
+ * @JSON_NODE_VALUE: The node contains a fundamental type
+ * @JSON_NODE_NULL: Special type, for nodes containing null
+ *
+ * Indicates the content of a #JsonNode.
+ */
+typedef enum {
+  JSON_NODE_OBJECT,
+  JSON_NODE_ARRAY,
+  JSON_NODE_VALUE,
+  JSON_NODE_NULL
+} JsonNodeType;
+
+/**
+ * JsonObjectForeach:
+ * @object: the iterated #JsonObject
+ * @member_name: the name of the member
+ * @member_node: a #JsonNode containing the @member_name value
+ * @user_data: data passed to the function
+ *
+ * The function to be passed to json_object_foreach_member(). You
+ * should not add or remove members to and from @object within
+ * this function. It is safe to change the value of @member_node.
+ *
+ * Since: 0.8
+ */
+typedef void (* JsonObjectForeach) (JsonObject  *object,
+                                    const gchar *member_name,
+                                    JsonNode    *member_node,
+                                    gpointer     user_data);
+
+/**
+ * JsonArrayForeach:
+ * @array: the iterated #JsonArray
+ * @index_: the index of the element
+ * @element_node: a #JsonNode containing the value at @index_
+ * @user_data: data passed to the function
+ *
+ * The function to be passed to json_array_foreach_element(). You
+ * should not add or remove elements to and from @array within
+ * this function. It is safe to change the value of @element_node.
+ *
+ * Since: 0.8
+ */
+typedef void (* JsonArrayForeach) (JsonArray  *array,
+                                   guint       index_,
+                                   JsonNode   *element_node,
+                                   gpointer    user_data);
+
+/*
+ * JsonNode
+ */
+GType                 json_node_get_type        (void) G_GNUC_CONST;
+JsonNode *            json_node_new             (JsonNodeType  type);
+JsonNode *            json_node_copy            (JsonNode     *node);
+void                  json_node_free            (JsonNode     *node);
+JsonNodeType          json_node_get_node_type   (JsonNode     *node);
+GType                 json_node_get_value_type  (JsonNode     *node);
+void                  json_node_set_parent      (JsonNode     *node,
+                                                 JsonNode     *parent);
+JsonNode *            json_node_get_parent      (JsonNode     *node);
+G_CONST_RETURN gchar *json_node_type_name       (JsonNode     *node);
+
+void                  json_node_set_object      (JsonNode     *node,
+                                                 JsonObject   *object);
+void                  json_node_take_object     (JsonNode     *node,
+                                                 JsonObject   *object);
+JsonObject *          json_node_get_object      (JsonNode     *node);
+JsonObject *          json_node_dup_object      (JsonNode     *node);
+void                  json_node_set_array       (JsonNode     *node,
+                                                 JsonArray    *array);
+void                  json_node_take_array      (JsonNode     *node,
+                                                 JsonArray    *array);
+JsonArray *           json_node_get_array       (JsonNode     *node);
+JsonArray *           json_node_dup_array       (JsonNode     *node);
+void                  json_node_set_value       (JsonNode     *node,
+                                                 const GValue *value);
+void                  json_node_get_value       (JsonNode     *node,
+                                                 GValue       *value);
+void                  json_node_set_string      (JsonNode     *node,
+                                                 const gchar  *value);
+G_CONST_RETURN gchar *json_node_get_string      (JsonNode     *node);
+gchar *               json_node_dup_string      (JsonNode     *node);
+void                  json_node_set_int         (JsonNode     *node,
+                                                 gint64        value);
+gint64                json_node_get_int         (JsonNode     *node);
+void                  json_node_set_double      (JsonNode     *node,
+                                                 gdouble       value);
+gdouble               json_node_get_double      (JsonNode     *node);
+void                  json_node_set_boolean     (JsonNode     *node,
+                                                 gboolean      value);
+gboolean              json_node_get_boolean     (JsonNode     *node);
+gboolean              json_node_is_null         (JsonNode     *node);
+
+/*
+ * JsonObject
+ */
+GType                 json_object_get_type           (void) G_GNUC_CONST;
+JsonObject *          json_object_new                (void);
+JsonObject *          json_object_ref                (JsonObject  *object);
+void                  json_object_unref              (JsonObject  *object);
+
+#ifndef JSON_DISABLE_DEPRECATED
+void                  json_object_add_member         (JsonObject  *object,
+                                                      const gchar *member_name,
+                                                      JsonNode    *node) G_GNUC_DEPRECATED;
+#endif /* JSON_DISABLE_DEPRECATED */
+
+void                  json_object_set_member         (JsonObject  *object,
+                                                      const gchar *member_name,
+                                                      JsonNode    *node);
+void                  json_object_set_int_member     (JsonObject  *object,
+                                                      const gchar *member_name,
+                                                      gint64       value);
+void                  json_object_set_double_member  (JsonObject  *object,
+                                                      const gchar *member_name,
+                                                      gdouble      value);
+void                  json_object_set_boolean_member (JsonObject  *object,
+                                                      const gchar *member_name,
+                                                      gboolean     value);
+void                  json_object_set_string_member  (JsonObject  *object,
+                                                      const gchar *member_name,
+                                                      const gchar *value);
+void                  json_object_set_null_member    (JsonObject  *object,
+                                                      const gchar *member_name);
+void                  json_object_set_array_member   (JsonObject  *object,
+                                                      const gchar *member_name,
+                                                      JsonArray   *value);
+void                  json_object_set_object_member  (JsonObject  *object,
+                                                      const gchar *member_name,
+                                                      JsonObject  *value);
+GList *               json_object_get_members        (JsonObject  *object);
+JsonNode *            json_object_get_member         (JsonObject  *object,
+                                                      const gchar *member_name);
+JsonNode *            json_object_dup_member         (JsonObject  *object,
+                                                      const gchar *member_name);
+gint64                json_object_get_int_member     (JsonObject  *object,
+                                                      const gchar *member_name);
+gdouble               json_object_get_double_member  (JsonObject  *object,
+                                                      const gchar *member_name);
+gboolean              json_object_get_boolean_member (JsonObject  *object,
+                                                      const gchar *member_name);
+G_CONST_RETURN gchar *json_object_get_string_member  (JsonObject  *object,
+                                                      const gchar *member_name);
+gboolean              json_object_get_null_member    (JsonObject  *object,
+                                                      const gchar *member_name);
+JsonArray *           json_object_get_array_member   (JsonObject  *object,
+                                                      const gchar *member_name);
+JsonObject *          json_object_get_object_member  (JsonObject  *object,
+                                                      const gchar *member_name);
+gboolean              json_object_has_member         (JsonObject  *object,
+                                                      const gchar *member_name);
+void                  json_object_remove_member      (JsonObject  *object,
+                                                      const gchar *member_name);
+GList *               json_object_get_values         (JsonObject  *object);
+guint                 json_object_get_size           (JsonObject  *object);
+void                  json_object_foreach_member     (JsonObject  *object,
+                                                      JsonObjectForeach func,
+                                                      gpointer     data);
+
+GType                 json_array_get_type            (void) G_GNUC_CONST;
+JsonArray *           json_array_new                 (void);
+JsonArray *           json_array_sized_new           (guint        n_elements);
+JsonArray *           json_array_ref                 (JsonArray   *array);
+void                  json_array_unref               (JsonArray   *array);
+void                  json_array_add_element         (JsonArray   *array,
+                                                      JsonNode    *node);
+void                  json_array_add_int_element     (JsonArray   *array,
+                                                      gint64       value);
+void                  json_array_add_double_element  (JsonArray   *array,
+                                                      gdouble      value);
+void                  json_array_add_boolean_element (JsonArray   *array,
+                                                      gboolean     value);
+void                  json_array_add_string_element  (JsonArray   *array,
+                                                      const gchar *value);
+void                  json_array_add_null_element    (JsonArray   *array);
+void                  json_array_add_array_element   (JsonArray   *array,
+                                                      JsonArray   *value);
+void                  json_array_add_object_element  (JsonArray   *array,
+                                                      JsonObject  *value);
+GList *               json_array_get_elements        (JsonArray   *array);
+JsonNode *            json_array_get_element         (JsonArray   *array,
+                                                      guint        index_);
+gint64                json_array_get_int_element     (JsonArray   *array,
+                                                      guint        index_);
+gdouble               json_array_get_double_element  (JsonArray   *array,
+                                                      guint        index_);
+gboolean              json_array_get_boolean_element (JsonArray   *array,
+                                                      guint        index_);
+G_CONST_RETURN gchar *json_array_get_string_element  (JsonArray   *array,
+                                                      guint        index_);
+gboolean              json_array_get_null_element    (JsonArray   *array,
+                                                      guint        index_);
+JsonArray *           json_array_get_array_element   (JsonArray   *array,
+                                                      guint        index_);
+JsonObject *          json_array_get_object_element  (JsonArray   *array,
+                                                      guint        index_);
+JsonNode *            json_array_dup_element         (JsonArray   *array,
+                                                      guint        index_);
+void                  json_array_remove_element      (JsonArray   *array,
+                                                      guint        index_);
+guint                 json_array_get_length          (JsonArray   *array);
+void                  json_array_foreach_element     (JsonArray   *array,
+                                                      JsonArrayForeach func,
+                                                      gpointer     data);
+
+G_END_DECLS
+
+#endif /* __JSON_TYPES_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-types-private.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-types-private.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-types-private.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-types-private.h	2011-03-27 09:15:30.768552999 -0600
@@ -0,0 +1,66 @@
+/* json-types-private.h - JSON data types private header
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#ifndef __JSON_TYPES_PRIVATE_H__
+#define __JSON_TYPES_PRIVATE_H__
+
+#include "json-types.h"
+
+G_BEGIN_DECLS
+
+struct _JsonNode
+{
+  /*< private >*/
+  JsonNodeType type;
+
+  union {
+    JsonObject *object;
+    JsonArray *array;
+    GValue value;
+  } data;
+
+  JsonNode *parent;
+};
+
+struct _JsonArray
+{
+  GPtrArray *elements;
+
+  volatile gint ref_count;
+};
+
+struct _JsonObject
+{
+  GHashTable *members;
+
+  /* the members of the object, ordered in reverse */
+  GList *members_ordered;
+
+  volatile gint ref_count;
+};
+
+G_CONST_RETURN gchar *json_node_type_get_name (JsonNodeType node_type);
+
+G_END_DECLS
+
+#endif /* __JSON_TYPES_PRIVATE_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-version.h pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-version.h
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-version.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-version.h	2011-03-27 09:15:30.776552999 -0600
@@ -0,0 +1,100 @@
+/* json-version.h - JSON-GLib versioning information
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_VERSION_H__
+#define __JSON_VERSION_H__
+
+/**
+ * SECTION:json-version
+ * @short_description: JSON-GLib version checking
+ *
+ * JSON-GLib provides macros to check the version of the library
+ * at compile-time
+ */
+
+/**
+ * JSON_MAJOR_VERSION:
+ *
+ * Json major version component (e.g. 1 if %JSON_VERSION is 1.2.3)
+ */
+#define JSON_MAJOR_VERSION              (0)
+
+/**
+ * JSON_MINOR_VERSION:
+ *
+ * Json minor version component (e.g. 2 if %JSON_VERSION is 1.2.3)
+ */
+#define JSON_MINOR_VERSION              (12)
+
+/**
+ * JSON_MICRO_VERSION:
+ *
+ * Json micro version component (e.g. 3 if %JSON_VERSION is 1.2.3)
+ */
+#define JSON_MICRO_VERSION              (2)
+
+/**
+ * JSON_VERSION
+ *
+ * Json version.
+ */
+#define JSON_VERSION                    (0.12.2)
+
+/**
+ * JSON_VERSION_S:
+ *
+ * Json version, encoded as a string, useful for printing and
+ * concatenation.
+ */
+#define JSON_VERSION_S                  "0.12.2"
+
+/**
+ * JSON_VERSION_HEX:
+ *
+ * Json version, encoded as an hexadecimal number, useful for
+ * integer comparisons.
+ */
+#define JSON_VERSION_HEX                (JSON_MAJOR_VERSION << 24 | \
+                                         JSON_MINOR_VERSION << 16 | \
+                                         JSON_MICRO_VERSION << 8)
+
+/**
+ * JSON_CHECK_VERSION:
+ * @major: required major version
+ * @minor: required minor version
+ * @micro: required micro version
+ *
+ * Compile-time version checking. Evaluates to %TRUE if the version
+ * of Json is greater than the required one.
+ */
+#define JSON_CHECK_VERSION(major,minor,micro)   \
+        (JSON_MAJOR_VERSION > (major) || \
+         (JSON_MAJOR_VERSION == (major) && JSON_MINOR_VERSION > (minor)) || \
+         (JSON_MAJOR_VERSION == (major) && JSON_MINOR_VERSION == (minor) && \
+          JSON_MICRO_VERSION >= (micro)))
+
+#endif /* __JSON_VERSION_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-version.h.in pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-version.h.in
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/json-version.h.in	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/json-version.h.in	2011-03-27 09:15:30.776552999 -0600
@@ -0,0 +1,100 @@
+/* json-version.h - JSON-GLib versioning information
+ * 
+ * This file is part of JSON-GLib
+ * Copyright (C) 2007  OpenedHand Ltd.
+ * Copyright (C) 2009  Intel Corp.
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library. If not, see <http://www.gnu.org/licenses/>.
+ *
+ * Author:
+ *   Emmanuele Bassi  <ebassi@linux.intel.com>
+ */
+
+#if !defined(__JSON_GLIB_INSIDE__) && !defined(JSON_COMPILATION)
+#error "Only <json-glib/json-glib.h> can be included directly."
+#endif
+
+#ifndef __JSON_VERSION_H__
+#define __JSON_VERSION_H__
+
+/**
+ * SECTION:json-version
+ * @short_description: JSON-GLib version checking
+ *
+ * JSON-GLib provides macros to check the version of the library
+ * at compile-time
+ */
+
+/**
+ * JSON_MAJOR_VERSION:
+ *
+ * Json major version component (e.g. 1 if %JSON_VERSION is 1.2.3)
+ */
+#define JSON_MAJOR_VERSION              (@JSON_MAJOR_VERSION@)
+
+/**
+ * JSON_MINOR_VERSION:
+ *
+ * Json minor version component (e.g. 2 if %JSON_VERSION is 1.2.3)
+ */
+#define JSON_MINOR_VERSION              (@JSON_MINOR_VERSION@)
+
+/**
+ * JSON_MICRO_VERSION:
+ *
+ * Json micro version component (e.g. 3 if %JSON_VERSION is 1.2.3)
+ */
+#define JSON_MICRO_VERSION              (@JSON_MICRO_VERSION@)
+
+/**
+ * JSON_VERSION
+ *
+ * Json version.
+ */
+#define JSON_VERSION                    (@JSON_VERSION@)
+
+/**
+ * JSON_VERSION_S:
+ *
+ * Json version, encoded as a string, useful for printing and
+ * concatenation.
+ */
+#define JSON_VERSION_S                  "@JSON_VERSION@"
+
+/**
+ * JSON_VERSION_HEX:
+ *
+ * Json version, encoded as an hexadecimal number, useful for
+ * integer comparisons.
+ */
+#define JSON_VERSION_HEX                (JSON_MAJOR_VERSION << 24 | \
+                                         JSON_MINOR_VERSION << 16 | \
+                                         JSON_MICRO_VERSION << 8)
+
+/**
+ * JSON_CHECK_VERSION:
+ * @major: required major version
+ * @minor: required minor version
+ * @micro: required micro version
+ *
+ * Compile-time version checking. Evaluates to %TRUE if the version
+ * of Json is greater than the required one.
+ */
+#define JSON_CHECK_VERSION(major,minor,micro)   \
+        (JSON_MAJOR_VERSION > (major) || \
+         (JSON_MAJOR_VERSION == (major) && JSON_MINOR_VERSION > (minor)) || \
+         (JSON_MAJOR_VERSION == (major) && JSON_MINOR_VERSION == (minor) && \
+          JSON_MICRO_VERSION >= (micro)))
+
+#endif /* __JSON_VERSION_H__ */
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/Makefile.am pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/Makefile.am
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/Makefile.am	2011-03-27 09:15:30.760552999 -0600
@@ -0,0 +1,122 @@
+include $(top_srcdir)/build/autotools/Makefile.am.silent
+include $(top_srcdir)/build/autotools/Makefile.am.gtest
+
+if ENABLE_GLIB_TEST
+# build this directory *before* the tests/
+SUBDIRS = . tests
+endif
+
+DIST_SUBDIRS = tests
+
+NULL =
+
+INCLUDES = -I$(top_srcdir)
+
+AM_CPPFLAGS = \
+	-DPREFIX=\""$(prefix)"\" 	\
+	-DLIBDIR=\""$(libdir)"\" 	\
+	-DJSON_COMPILATION=1		\
+	-DG_DISABLE_DEPRECATED 		\
+	-DJSON_DISABLE_DEPRECATED	\
+	-DG_LOG_DOMAIN=\"Json\" 	\
+	$(JSON_DEBUG_CFLAGS) 		\
+	$(NULL)
+
+AM_CFLAGS = $(JSON_CFLAGS) $(MAINTAINER_CFLAGS) $(GCOV_CFLAGS)
+
+BUILT_SOURCES =
+
+CLEANFILES =
+DISTCLEANFILES = json-version.h
+
+source_h = \
+	$(top_srcdir)/json-glib/json-builder.h		\
+	$(top_srcdir)/json-glib/json-generator.h 	\
+	$(top_srcdir)/json-glib/json-gobject.h 		\
+	$(top_srcdir)/json-glib/json-parser.h 		\
+	$(top_srcdir)/json-glib/json-reader.h		\
+	$(top_srcdir)/json-glib/json-types.h 		\
+	$(top_srcdir)/json-glib/json-gvariant.h		\
+	$(NULL)
+
+source_h_private = \
+	$(top_srcdir)/json-glib/json-debug.h		\
+	$(top_srcdir)/json-glib/json-gobject-private.h	\
+	$(top_srcdir)/json-glib/json-scanner.h 		\
+	$(top_srcdir)/json-glib/json-types-private.h	\
+	$(NULL)
+
+source_c = \
+	$(srcdir)/json-array.c 		\
+	$(srcdir)/json-builder.c	\
+	$(srcdir)/json-debug.c		\
+	$(srcdir)/json-gboxed.c		\
+	$(srcdir)/json-generator.c 	\
+	$(srcdir)/json-gobject.c 	\
+	$(srcdir)/json-node.c 		\
+	$(srcdir)/json-object.c 	\
+	$(srcdir)/json-parser.c 	\
+	$(srcdir)/json-reader.c		\
+	$(srcdir)/json-scanner.c 	\
+	$(srcdir)/json-serializable.c	\
+	$(srcdir)/json-gvariant.c	\
+	$(NULL)
+
+# glib-mkenums rules
+glib_enum_h = json-enum-types.h
+glib_enum_c = json-enum-types.c
+glib_enum_headers = $(source_h)
+include $(top_srcdir)/build/autotools/Makefile.am.enums
+
+# glib-genmarshal rules
+glib_marshal_list = json-marshal.list
+glib_marshal_prefix = _json_marshal
+include $(top_srcdir)/build/autotools/Makefile.am.marshal
+
+lib_LTLIBRARIES = libjson-glib-1.0.la
+
+libjson_glib_1_0_la_LIBADD = $(JSON_LIBS)
+libjson_glib_1_0_la_SOURCES = $(source_c) $(source_h) $(source_h_private) $(BUILT_SOURCES)
+libjson_glib_1_0_la_LDFLAGS = $(JSON_LT_LDFLAGS) $(GCOV_LDFLAGS) -export-dynamic -export-symbols-regex "^json.*" -rpath $(libdir)
+
+jsonincludedir = $(includedir)/json-glib-1.0/json-glib
+jsoninclude_DATA = \
+	$(source_h) 					\
+	$(top_builddir)/json-glib/json-enum-types.h 	\
+	$(top_builddir)/json-glib/json-version.h	\
+	$(top_srcdir)/json-glib/json-glib.h		\
+	$(NULL)
+
+EXTRA_DIST += json-version.h.in json-glib.h
+
+TESTS_ENVIRONMENT = srcdir="$(srcdir)" json_all_c_sources="$(source_c)"
+
+# intospection
+-include $(INTROSPECTION_MAKEFILE)
+
+if HAVE_INTROSPECTION
+INTROSPECTION_GIRS = Json-1.0.gir
+
+Json-1.0.gir: libjson-glib-1.0.la Makefile
+
+Json_1_0_gir_NAMESPACE = Json
+Json_1_0_gir_VERSION = 1.0
+Json_1_0_gir_LIBS = libjson-glib-1.0.la
+Json_1_0_gir_FILES = $(source_h) $(source_c)
+Json_1_0_gir_CFLAGS = $(INCLUDES) $(AM_CPPFLAGS) $(JSON_CFLAGS) -UJSON_DISABLE_DEPRECATED
+Json_1_0_gir_INCLUDES = GObject-2.0 Gio-2.0
+Json_1_0_gir_SCANNERFLAGS = --warn-all --pkg-export json-glib-1.0 --c-include "json-glib/json-glib.h"
+
+girdir = $(datadir)/gir-1.0
+dist_gir_DATA = Json-1.0.gir
+
+typelibsdir = $(libdir)/girepository-1.0/
+typelibs_DATA = Json-1.0.typelib
+
+CLEANFILES += $(dist_gir_DATA) $(typelibs_DATA)
+endif # HAVE_INTROSPECTION
+
+EXTRA_DIST += json-glib.symbols
+
+gcov_sources = $(source_c)
+include $(top_srcdir)/build/autotools/Makefile.am.gcov
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/array-test.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/array-test.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/array-test.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/array-test.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,122 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <glib.h>
+#include <json-glib/json-glib.h>
+
+static void
+test_empty_array (void)
+{
+  JsonArray *array = json_array_new ();
+
+  g_assert_cmpint (json_array_get_length (array), ==, 0);
+  g_assert (json_array_get_elements (array) == NULL);
+
+  json_array_unref (array);
+}
+
+static void
+test_add_element (void)
+{
+  JsonArray *array = json_array_new ();
+  JsonNode *node = json_node_new (JSON_NODE_NULL);
+
+  g_assert_cmpint (json_array_get_length (array), ==, 0);
+
+  json_array_add_element (array, node);
+  g_assert_cmpint (json_array_get_length (array), ==, 1);
+
+  node = json_array_get_element (array, 0);
+  g_assert_cmpint (JSON_NODE_TYPE (node), ==, JSON_NODE_NULL);
+
+  json_array_unref (array);
+}
+
+static void
+test_remove_element (void)
+{
+  JsonArray *array = json_array_new ();
+  JsonNode *node = json_node_new (JSON_NODE_NULL);
+
+  json_array_add_element (array, node);
+
+  json_array_remove_element (array, 0);
+  g_assert_cmpint (json_array_get_length (array), ==, 0);
+
+  json_array_unref (array);
+}
+
+typedef struct _TestForeachFixture
+{
+  GList *elements;
+  gint n_elements;
+  gint iterations;
+} TestForeachFixture;
+
+static const struct {
+  JsonNodeType element_type;
+  GType element_gtype;
+} type_verify[] = {
+  { JSON_NODE_VALUE, G_TYPE_INT64   },
+  { JSON_NODE_VALUE, G_TYPE_BOOLEAN },
+  { JSON_NODE_VALUE, G_TYPE_STRING  },
+  { JSON_NODE_NULL,  G_TYPE_INVALID }
+};
+
+static void
+verify_foreach (JsonArray *array,
+                guint      index_,
+                JsonNode  *element_node,
+                gpointer   user_data)
+{
+  TestForeachFixture *fixture = user_data;
+
+  g_assert (g_list_find (fixture->elements, element_node));
+  g_assert (json_node_get_node_type (element_node) == type_verify[index_].element_type);
+  g_assert (json_node_get_value_type (element_node) == type_verify[index_].element_gtype);
+
+  fixture->iterations += 1;
+}
+
+static void
+test_foreach_element (void)
+{
+  JsonArray *array = json_array_new ();
+  TestForeachFixture fixture = { 0, };
+
+  json_array_add_int_element (array, 42);
+  json_array_add_boolean_element (array, TRUE);
+  json_array_add_string_element (array, "hello");
+  json_array_add_null_element (array);
+
+  fixture.elements = json_array_get_elements (array);
+  g_assert (fixture.elements != NULL);
+
+  fixture.n_elements = json_array_get_length (array);
+  g_assert_cmpint (fixture.n_elements, ==, g_list_length (fixture.elements));
+
+  fixture.iterations = 0;
+
+  json_array_foreach_element (array, verify_foreach, &fixture);
+
+  g_assert_cmpint (fixture.iterations, ==, fixture.n_elements);
+
+  g_list_free (fixture.elements);
+  json_array_unref (array);
+}
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_type_init ();
+  g_test_init (&argc, &argv, NULL);
+
+  g_test_add_func ("/array/empty-array", test_empty_array);
+  g_test_add_func ("/array/add-element", test_add_element);
+  g_test_add_func ("/array/remove-element", test_remove_element);
+  g_test_add_func ("/array/foreach-element", test_foreach_element);
+
+  return g_test_run ();
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/builder-test.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/builder-test.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/builder-test.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/builder-test.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,121 @@
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <glib-object.h>
+
+#include <json-glib/json-glib.h>
+
+static const gchar *complex_object = "{\"depth1\":[1,{\"depth2\":[3,[null],\"after array\"],\"value2\":true}],\"object1\":{}}\") == 0)";
+
+static const gchar *reset_object = "{\"test\":\"reset\"}";
+static const gchar *reset_array = "[\"reset\"]";
+
+static void
+test_builder_complex (void)
+{
+  JsonBuilder *builder = json_builder_new ();
+  JsonNode *node;
+  JsonGenerator *generator;
+  gsize length;
+  gchar *data;
+
+  json_builder_begin_object (builder);
+
+  json_builder_set_member_name (builder, "depth1");
+  json_builder_begin_array (builder);
+  json_builder_add_int_value (builder, 1);
+
+  json_builder_begin_object (builder);
+
+  json_builder_set_member_name (builder, "depth2");
+  json_builder_begin_array (builder);
+  json_builder_add_int_value (builder, 3);
+
+  json_builder_begin_array (builder);
+  json_builder_add_null_value (builder);
+  json_builder_end_array (builder);
+
+  json_builder_add_string_value (builder, "after array");
+  json_builder_end_array (builder); /* depth2 */
+
+  json_builder_set_member_name (builder, "value2");
+  json_builder_add_boolean_value (builder, TRUE);
+  json_builder_end_object (builder);
+
+  json_builder_end_array (builder); /* depth1 */
+
+  json_builder_set_member_name (builder, "object1");
+  json_builder_begin_object (builder);
+  json_builder_end_object (builder);
+
+  json_builder_end_object (builder);
+
+  node = json_builder_get_root (builder);
+  g_object_unref (builder);
+
+  generator = json_generator_new ();
+  json_generator_set_root (generator, node);
+  data = json_generator_to_data (generator, &length);
+  if (g_test_verbose ())
+    {
+      g_print ("Builder complex: %*s", (int)length, data);
+    }
+  g_assert (strncmp (data, complex_object, length) == 0);
+
+  g_free (data);
+  json_node_free (node);
+  g_object_unref (generator);
+}
+
+static void
+test_builder_reset (oid)
+{
+  JsonBuilder *builder = json_builder_new ();
+  JsonGenerator *generator = json_generator_new ();
+  JsonNode *node;
+  gsize length;
+  gchar *data;
+
+  json_builder_begin_object (builder);
+  json_builder_set_member_name (builder, "test");
+  json_builder_add_string_value (builder, "reset");
+  json_builder_end_object (builder);
+
+  node = json_builder_get_root (builder);
+  json_generator_set_root (generator, node);
+  data = json_generator_to_data (generator, &length);
+  g_assert (strncmp (data, reset_object, length) == 0);
+
+  g_free (data);
+  json_node_free (node);
+
+  json_builder_reset (builder);
+
+  json_builder_begin_array (builder);
+  json_builder_add_string_value (builder, "reset");
+  json_builder_end_array (builder);
+
+  node = json_builder_get_root (builder);
+  json_generator_set_root (generator, node);
+  data = json_generator_to_data (generator, &length);
+  g_assert (strncmp (data, reset_array, length) == 0);
+
+  g_free (data);
+  json_node_free (node);
+  g_object_unref (builder);
+  g_object_unref (generator);
+}
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_type_init ();
+  g_test_init (&argc, &argv, NULL);
+
+  g_test_add_func ("/builder/complex", test_builder_complex);
+  g_test_add_func ("/builder/reset", test_builder_reset);
+
+  return g_test_run ();
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/generator-test.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/generator-test.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/generator-test.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/generator-test.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,330 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+#include <glib.h>
+
+#include <json-glib/json-glib.h>
+
+#include <locale.h>
+
+static const gchar *empty_array  = "[]";
+static const gchar *empty_object = "{}";
+
+static const gchar *simple_array = "[true,false,null,42,\"foo\"]";
+static const gchar *nested_array = "[true,[false,null],42]";
+
+static const gchar *simple_object = "{\"Bool1\":true,\"Bool2\":false,\"Null\":null,\"Int\":42,\"String\":\"foo\"}";
+/* taken from the RFC 4627, Examples section */
+static const gchar *nested_object =
+"{"
+  "\"Image\":{"
+    "\"Width\":800,"
+    "\"Height\":600,"
+    "\"Title\":\"View from 15th Floor\","
+    "\"Thumbnail\":{"
+      "\"Url\":\"http://www.example.com/image/481989943\","
+      "\"Height\":125,"
+      "\"Width\":\"100\""
+    "},"
+    "\"IDs\":[116,943,234,38793]"
+  "}"
+"}";
+
+static const struct {
+  const gchar *lang;
+  const gchar *sep;
+  guint matches : 1;
+} decimal_separator[] = {
+  { "C", ".",  TRUE },
+  { "de", ",", FALSE },
+  { "en", ".", TRUE },
+  { "fr", ",", FALSE }
+};
+
+static void
+test_empty_array (void)
+{
+  JsonGenerator *gen = json_generator_new ();
+  JsonNode *root;
+  gchar *data;
+  gsize len;
+
+  root = json_node_new (JSON_NODE_ARRAY);
+  json_node_take_array (root, json_array_new ());
+
+  json_generator_set_root (gen, root);
+  g_object_set (gen, "pretty", FALSE, NULL);
+
+  data = json_generator_to_data (gen, &len);
+
+  g_assert_cmpint (len, ==, strlen (empty_array));
+  g_assert_cmpstr (data, ==, empty_array);
+
+  g_free (data);
+  json_node_free (root);
+  g_object_unref (gen);
+}
+
+static void
+test_empty_object (void)
+{
+  JsonGenerator *gen = json_generator_new ();
+  JsonNode *root;
+  gchar *data;
+  gsize len;
+
+  root = json_node_new (JSON_NODE_OBJECT);
+  json_node_take_object (root, json_object_new ());
+
+  json_generator_set_root (gen, root);
+  g_object_set (gen, "pretty", FALSE, NULL);
+
+  data = json_generator_to_data (gen, &len);
+
+  g_assert_cmpint (len, ==, strlen (empty_object));
+  g_assert_cmpstr (data, ==, empty_object);
+
+  g_free (data);
+  json_node_free (root);
+  g_object_unref (gen);
+}
+
+static void
+test_simple_array (void)
+{
+  JsonGenerator *generator = json_generator_new ();
+  JsonNode *root;
+  JsonArray *array;
+  gchar *data;
+  gsize len;
+
+  root = json_node_new (JSON_NODE_ARRAY);
+  array = json_array_sized_new (5);
+
+  json_array_add_boolean_element (array, TRUE);
+  json_array_add_boolean_element (array, FALSE);
+  json_array_add_null_element (array);
+  json_array_add_int_element (array, 42);
+  json_array_add_string_element (array, "foo");
+
+  json_node_take_array (root, array);
+  json_generator_set_root (generator, root);
+
+  g_object_set (generator, "pretty", FALSE, NULL);
+  data = json_generator_to_data (generator, &len);
+
+  if (g_test_verbose ())
+    g_print ("checking simple array `%s' (expected: %s)\n",
+             data,
+             simple_array);
+
+  g_assert_cmpint (len, ==, strlen (simple_array));
+  g_assert_cmpstr (data, ==, simple_array);
+
+  g_free (data);
+  json_node_free (root);
+  g_object_unref (generator);
+}
+
+static void
+test_nested_array (void)
+{
+  JsonGenerator *generator = json_generator_new ();
+  JsonNode *root;
+  JsonArray *array, *nested;
+  gchar *data;
+  gsize len;
+
+  root = json_node_new (JSON_NODE_ARRAY);
+  array = json_array_sized_new (3);
+
+  json_array_add_boolean_element (array, TRUE);
+
+  {
+    nested = json_array_sized_new (2);
+
+    json_array_add_boolean_element (nested, FALSE);
+    json_array_add_null_element (nested);
+
+    json_array_add_array_element (array, nested);
+  }
+
+  json_array_add_int_element (array, 42);
+
+  json_node_take_array (root, array);
+  json_generator_set_root (generator, root);
+
+  g_object_set (generator, "pretty", FALSE, NULL);
+  data = json_generator_to_data (generator, &len);
+
+  g_assert_cmpint (len, ==, strlen (nested_array));
+  g_assert_cmpstr (data, ==, nested_array);
+
+  g_free (data);
+  json_node_free (root);
+  g_object_unref (generator);
+}
+
+static void
+test_simple_object (void)
+{
+  JsonGenerator *generator = json_generator_new ();
+  JsonNode *root;
+  JsonObject *object;
+  gchar *data;
+  gsize len;
+
+  root = json_node_new (JSON_NODE_OBJECT);
+  object = json_object_new ();
+
+  json_object_set_boolean_member (object, "Bool1", TRUE);
+  json_object_set_boolean_member (object, "Bool2", FALSE);
+  json_object_set_null_member (object, "Null");
+  json_object_set_int_member (object, "Int", 42);
+  json_object_set_string_member (object, "String", "foo");
+
+  json_node_take_object (root, object);
+  json_generator_set_root (generator, root);
+
+  g_object_set (generator, "pretty", FALSE, NULL);
+  data = json_generator_to_data (generator, &len);
+
+  if (g_test_verbose ())
+    g_print ("checking simple object `%s' (expected: %s)\n",
+             data,
+             simple_object);
+
+  g_assert_cmpint (len, ==, strlen (simple_object));
+  g_assert_cmpstr (data, ==, simple_object);
+
+  g_free (data);
+  json_node_free (root);
+  g_object_unref (generator);
+}
+
+static void
+test_nested_object (void)
+{
+  JsonGenerator *generator = json_generator_new ();
+  JsonNode *root;
+  JsonObject *object, *nested;
+  JsonArray *array;
+  gchar *data;
+  gsize len;
+
+  root = json_node_new (JSON_NODE_OBJECT);
+  object = json_object_new ();
+
+  json_object_set_int_member (object, "Width", 800);
+  json_object_set_int_member (object, "Height", 600);
+  json_object_set_string_member (object, "Title", "View from 15th Floor");
+
+  {
+    nested = json_object_new ();
+
+    json_object_set_string_member (nested, "Url", "http://www.example.com/image/481989943");
+    json_object_set_int_member (nested, "Height", 125);
+    json_object_set_string_member (nested, "Width", "100");
+
+    json_object_set_object_member (object, "Thumbnail", nested);
+  }
+
+  {
+    array = json_array_new ();
+
+    json_array_add_int_element (array, 116);
+    json_array_add_int_element (array, 943);
+    json_array_add_int_element (array, 234);
+    json_array_add_int_element (array, 38793);
+
+    json_object_set_array_member (object, "IDs", array);
+  }
+
+  nested = json_object_new ();
+  json_object_set_object_member (nested, "Image", object);
+
+  json_node_take_object (root, nested);
+  json_generator_set_root (generator, root);
+
+  g_object_set (generator, "pretty", FALSE, NULL);
+  data = json_generator_to_data (generator, &len);
+
+  if (g_test_verbose ())
+    g_print ("checking nested object `%s' (expected: %s)\n",
+             data,
+             nested_object);
+
+  g_assert_cmpint (len, ==, strlen (nested_object));
+  g_assert_cmpstr (data, ==, nested_object);
+
+  g_free (data);
+  json_node_free (root);
+  g_object_unref (generator);
+}
+
+static void
+test_decimal_separator (void)
+{
+  JsonNode *node = json_node_new (JSON_NODE_VALUE);
+  JsonGenerator *generator = json_generator_new ();
+  gchar *old_locale;
+  gint i;
+
+  json_node_set_double (node, 3.14);
+
+  json_generator_set_root (generator, node);
+
+  old_locale = setlocale (LC_NUMERIC, NULL);
+
+  for (i = 0; i < G_N_ELEMENTS (decimal_separator); i++)
+    {
+      gchar *str, *expected;
+
+      setlocale (LC_NUMERIC, decimal_separator[i].lang);
+
+      str = json_generator_to_data (generator, NULL);
+
+      if (g_test_verbose ())
+        g_print ("%s: value: %.2f - string: '%s'\n",
+                 G_STRFUNC,
+                 json_node_get_double (node),
+                 str);
+
+      g_assert (str != NULL);
+      expected = strstr (str, decimal_separator[i].sep);
+      if (decimal_separator[i].matches)
+        g_assert (expected != NULL);
+      else
+        g_assert (expected == NULL);
+
+      g_free (str);
+   }
+
+  setlocale (LC_NUMERIC, old_locale);
+
+  g_object_unref (generator);
+  json_node_free (node);
+}
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_type_init ();
+  g_test_init (&argc, &argv, NULL);
+
+  g_test_add_func ("/generator/empty-array", test_empty_array);
+  g_test_add_func ("/generator/empty-object", test_empty_object);
+  g_test_add_func ("/generator/simple-array", test_simple_array);
+  g_test_add_func ("/generator/nested-array", test_nested_array);
+  g_test_add_func ("/generator/simple-object", test_simple_object);
+  g_test_add_func ("/generator/nested-object", test_nested_object);
+  g_test_add_func ("/generator/decimal-separator", test_decimal_separator);
+
+  return g_test_run ();
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/gvariant-test.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/gvariant-test.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/gvariant-test.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/gvariant-test.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,233 @@
+#include <glib/gtestutils.h>
+#include <json-glib/json-glib.h>
+#include <string.h>
+
+typedef struct
+{
+  gchar *test_name;
+  gchar *signature;
+  gchar *variant_data;
+  gchar *json_data;
+} TestCase;
+
+/* each entry in this list spawns to a GVariant-to-JSON and
+   JSON-to-GVariant test */
+const TestCase test_cases[] =
+  {
+    /* boolean */
+    { "/boolean", "(b)", "(true,)", "[true]" },
+
+    /* byte */
+    { "/byte", "(y)", "(byte 0xff,)", "[255]" },
+
+    /* int16 */
+    { "/int16", "(n)", "(int16 -12345,)", "[-12345]" },
+
+    /* uint16 */
+    { "/uint16", "(q)", "(uint16 40001,)", "[40001]" },
+
+    /* int32 */
+    { "/int32", "(i)", "(-7654321,)", "[-7654321]" },
+
+    /* uint32 */
+    { "/uint32", "(u)", "(uint32 12345678,)", "[12345678]" },
+
+    /* int64 */
+    { "/int64", "(x)", "(int64 -666999666999,)", "[-666999666999]" },
+
+    /* uint64 */
+    { "/uint64", "(t)", "(uint64 1999999999999999,)", "[1999999999999999]" },
+
+    /* handle */
+    { "/handle", "(h)", "(handle 1,)", "[1]" },
+
+    /* double */
+    { "/double", "(d)", "(1.23,)", "[1.23]" },
+
+    /* string */
+    { "/string", "(s)", "('hello world!',)", "[\"hello world!\"]" },
+
+    /* object-path */
+    { "/object-path", "(o)", "(objectpath '/org/gtk/json_glib',)", "[\"/org/gtk/json_glib\"]" },
+
+    /* signature */
+    { "/signature", "(g)", "(signature '(asna{sv}i)',)", "[\"(asna{sv}i)\"]" },
+
+    /* maybe - null string */
+    { "/maybe/simple/null", "(ms)", "(@ms nothing,)", "[null]" },
+
+    /* maybe - simple string */
+    { "/maybe/simple/string", "(ms)", "(@ms 'maybe string',)", "[\"maybe string\"]" },
+
+    /* maybe - null container */
+    { "/maybe/container/null", "(m(sn))", "(@m(sn) nothing,)", "[null]" },
+
+    /* maybe - tuple container */
+    { "/maybe/container/tuple", "(m(sn))", "(@m(sn) ('foo', 0),)", "[[\"foo\",0]]" },
+
+    /* maybe - variant boolean */
+    { "/maybe/variant/boolean", "(mv)", "(@mv <true>,)", "[true]" },
+
+    /* empty array */
+    { "/array/empty", "as", "@as []", "[]" },
+
+    /* array of bytes */
+    { "/array/byte", "ay", "[byte 0x01, 0x0a, 0x03, 0xff]", "[1,10,3,255]" },
+
+    /* array of strings */
+    { "/array/string", "as", "['a', 'b', 'ab', 'ba']", "[\"a\",\"b\",\"ab\",\"ba\"]" },
+
+    /* array of array of int32 */
+    { "/array/array/int32", "aai", "[[1, 2], [3, 4], [5, 6]]", "[[1,2],[3,4],[5,6]]" },
+
+    /* array of variants */
+    { "/array/variant", "av", "[<true>, <int64 1>, <'oops'>, <int64 -2>, <0.5>]", "[true,1,\"oops\",-2,0.5]" },
+
+    /* tuple */
+    { "/tuple", "(bynqiuxthds)",
+      "(false, byte 0x00, int16 -1, uint16 1, -2, uint32 2, int64 429496729, uint64 3, handle 16, 2.48, 'end')",
+      "[false,0,-1,1,-2,2,429496729,3,16,2.48,\"end\"]" },
+
+    /* empty dictionary */
+    { "/dictionary/empty", "a{sv}", "@a{sv} {}", "{}" },
+
+    /* single dictionary entry */
+    { "/dictionary/single-entry", "{ss}", "{'hello', 'world'}", "{\"hello\":\"world\"}" },
+
+    /* dictionary - string : int32 */
+    { "/dictionary/string-int32", "a{si}", "{'foo': 1, 'bar': 2}", "{\"foo\":1,\"bar\":2}" },
+
+    /* dictionary - string : variant */
+    { "/dictionary/string-variant", "a{sv}", "{'str': <'hi!'>, 'bool': <true>}", "{\"str\":\"hi!\",\"bool\":true}" },
+
+    /* dictionary - int64 : variant */
+    { "/dictionary/int64-variant", "a{xv}",
+      "{int64 -5: <'minus five'>, 10: <'ten'>}", "{\"-5\":\"minus five\",\"10\":\"ten\"}" },
+
+    /* dictionary - uint64 : variant */
+    { "/dictionary/uint64-boolean", "a{tb}",
+      "{uint64 999888777666: true, 0: false}", "{\"999888777666\":true,\"0\":false}" },
+
+    /* dictionary - boolean : variant */
+    { "/dictionary/boolean-variant", "a{by}", "{true: byte 0x01, false: 0x00}", "{\"true\":1,\"false\":0}" },
+
+    /* dictionary - double : string */
+    { "/dictionary/double-string", "a{ds}", "{1.0: 'one point zero'}", "{\"1.000000\":\"one point zero\"}" },
+
+    /* variant - string */
+    { "/variant/string", "(v)", "(<'string within variant'>,)", "[\"string within variant\"]" },
+
+    /* variant - maybe null  */
+    { "/variant/maybe/null", "(v)", "(<@mv nothing>,)", "[null]" },
+
+    /* variant - dictionary */
+    { "/variant/dictionary", "v", "<{'foo': <'bar'>, 'hi': <int64 1024>}>", "{\"foo\":\"bar\",\"hi\":1024}" },
+
+    /* variant - variant - array */
+    { "/variant/variant/array", "v", "<[<'any'>, <'thing'>, <int64 0>, <int64 -1>]>", "[\"any\",\"thing\",0,-1]" },
+
+    /* deep-nesting */
+    { "/deep-nesting",
+      "a(a(a(a(a(a(a(a(a(a(s))))))))))",
+      "[([([([([([([([([([('sorprise',)],)],)],)],)],)],)],)],)],)]",
+      "[[[[[[[[[[[[[[[[[[[[\"sorprise\"]]]]]]]]]]]]]]]]]]]]" },
+
+    /* mixed1 */
+    { "/mixed1",
+      "a{s(syba(od))}",
+      "{'foo': ('bar', byte 0x64, true, [(objectpath '/baz', 1.3), ('/cat', -2.5)])}",
+      "{\"foo\":[\"bar\",100,true,[[\"/baz\",1.3],[\"/cat\",-2.5]]]}" },
+
+    /* mixed2 */
+    { "/mixed2",
+      "(a{by}amsvmaba{qm(sg)})",
+      "({true: byte 0x01, false: 0x00}, [@ms 'do', nothing, 'did'], <@av []>, @mab nothing, {uint16 10000: @m(sg) ('yes', 'august'), 0: nothing})",
+      "[{\"true\":1,\"false\":0},[\"do\",null,\"did\"],[],null,{\"10000\":[\"yes\",\"august\"],\"0\":null}]" },
+  };
+
+static void
+test_gvariant_to_json (gconstpointer test_data)
+{
+  TestCase *test_case = (TestCase *) test_data;
+  GVariant *variant;
+  gchar *json_data;
+  gsize len;
+
+  variant = g_variant_parse (G_VARIANT_TYPE (test_case->signature),
+                             test_case->variant_data,
+                             NULL,
+                             NULL,
+                             NULL);
+
+  json_data = json_gvariant_serialize_data (variant, &len);
+  g_assert (json_data != NULL);
+
+  g_assert_cmpstr (test_case->json_data, ==, json_data);
+
+  g_free (json_data);
+  g_variant_unref (variant);
+}
+
+static void
+test_json_to_gvariant (gconstpointer test_data)
+{
+  TestCase *test_case = (TestCase *) test_data;
+  GVariant *variant;
+  gchar *variant_data;
+  GError *error = NULL;
+
+  variant = json_gvariant_deserialize_data (test_case->json_data,
+                                            -1,
+                                            test_case->signature,
+                                            &error);
+
+  if (variant == NULL)
+    {
+      g_assert_no_error (error);
+      g_error_free (error);
+    }
+  else
+    {
+      variant_data = g_variant_print (variant, TRUE);
+
+      g_assert_cmpstr (test_case->variant_data, ==, variant_data);
+
+      g_free (variant_data);
+      g_variant_unref (variant);
+    }
+}
+
+gint
+main (gint argc, gchar *argv[])
+{
+  gint i;
+  TestCase test_case;
+  gchar *test_name;
+
+  g_type_init ();
+  g_test_init (&argc, &argv, NULL);
+
+  /* GVariant to JSON */
+  for (i = 0; i < sizeof (test_cases) / sizeof (TestCase); i++)
+    {
+      test_case = test_cases[i];
+      test_name = g_strdup_printf ("/gvariant/to-json/%s", test_case.test_name);
+
+      g_test_add_data_func (test_name, &test_cases[i], test_gvariant_to_json);
+
+      g_free (test_name);
+    }
+
+  /* JSON to GVariant */
+  for (i = 0; i < sizeof (test_cases) / sizeof (TestCase); i++)
+    {
+      test_case = test_cases[i];
+      test_name = g_strdup_printf ("/gvariant/from-json/%s", test_case.test_name);
+
+      g_test_add_data_func (test_name, &test_cases[i], test_json_to_gvariant);
+
+      g_free (test_name);
+    }
+
+  return g_test_run ();
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/Makefile.am pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/Makefile.am
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/Makefile.am	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,54 @@
+include $(top_srcdir)/build/autotools/Makefile.am.gtest
+include $(top_srcdir)/build/autotools/Makefile.am.silent
+
+NULL =
+
+INCLUDES = \
+	-I$(top_srcdir)			\
+	-I$(top_srcdir)/json-glib	\
+	$(NULL)
+
+AM_CPPFLAGS = $(JSON_DEBUG_CFLAGS) -DTESTS_DATA_DIR=\""$(top_srcdir)/json-glib/tests"\"
+AM_CFLAGS = -g $(JSON_CFLAGS) $(MAINTAINER_CFLAGS)
+
+EXTRA_DIST += stream-load.json
+
+DISTCLEANFILES =
+
+noinst_PROGRAMS = $(TEST_PROGS)
+progs_ldadd = $(JSON_LIBS) \
+	$(top_builddir)/json-glib/libjson-glib-1.0.la
+
+TEST_PROGS             += array-test
+array_test_SOURCES      = array-test.c
+array_test_LDADD        = $(progs_ldadd)
+
+TEST_PROGS             += object-test
+object_test_SOURCES     = object-test.c
+object_test_LDADD       = $(progs_ldadd)
+
+TEST_PROGS             += node-test
+node_test_SOURCES       = node-test.c
+node_test_LDADD         = $(progs_ldadd)
+
+TEST_PROGS             += parser-test
+parser_test_SOURCES     = parser-test.c
+parser_test_LDADD       = $(progs_ldadd)
+
+TEST_PROGS             += generator-test
+generator_test_SOURCES  = generator-test.c
+generator_test_LDADD    = $(progs_ldadd)
+
+TEST_PROGS             += builder-test
+builder_test_SOURCES    = builder-test.c
+builder_test_LDADD      = $(progs_ldadd)
+
+TEST_PROGS             += reader-test
+reader_test_SOURCES     = reader-test.c
+reader_test_LDADD       = $(progs_ldadd)
+
+TEST_PROGS             += gvariant-test
+gvariant_test_SOURCES   = gvariant-test.c
+gvariant_test_LDADD     = $(progs_ldadd)
+
+-include $(top_srcdir)/build/autotools/Makefile.am.gitignore
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/node-test.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/node-test.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/node-test.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/node-test.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,112 @@
+#include <glib/gtestutils.h>
+#include <json-glib/json-glib.h>
+#include <string.h>
+
+static void
+test_copy_null (void)
+{
+  JsonNode *node = json_node_new (JSON_NODE_NULL);
+  JsonNode *copy = json_node_copy (node);
+
+  g_assert_cmpint (json_node_get_node_type (node), ==, json_node_get_node_type (copy));
+  g_assert_cmpint (json_node_get_value_type (node), ==, json_node_get_value_type (copy));
+  g_assert_cmpstr (json_node_type_name (node), ==, json_node_type_name (copy));
+
+  json_node_free (copy);
+  json_node_free (node);
+}
+
+static void
+test_copy_value (void)
+{
+  JsonNode *node = json_node_new (JSON_NODE_VALUE);
+  JsonNode *copy;
+
+  json_node_set_string (node, "hello");
+
+  copy = json_node_copy (node);
+  g_assert_cmpint (json_node_get_node_type (node), ==, json_node_get_node_type (copy));
+  g_assert_cmpstr (json_node_type_name (node), ==, json_node_type_name (copy));
+  g_assert_cmpstr (json_node_get_string (node), ==, json_node_get_string (copy));
+
+  json_node_free (copy);
+  json_node_free (node);
+}
+
+static void
+test_copy_object (void)
+{
+  JsonObject *obj = json_object_new ();
+  JsonNode *node = json_node_new (JSON_NODE_OBJECT);
+  JsonNode *value = json_node_new (JSON_NODE_VALUE);
+  JsonNode *copy;
+
+  json_node_set_int (value, 42);
+  json_object_set_member (obj, "answer", value);
+
+  json_node_take_object (node, obj);
+
+  copy = json_node_copy (node);
+
+  g_assert_cmpint (json_node_get_node_type (node), ==, json_node_get_node_type (copy));
+  g_assert (json_node_get_object (node) == json_node_get_object (copy));
+
+  json_node_free (copy);
+  json_node_free (node);
+}
+
+static void
+test_null (void)
+{
+  JsonNode *node = json_node_new (JSON_NODE_NULL);
+
+  g_assert (JSON_NODE_HOLDS_NULL (node));
+  g_assert_cmpint (json_node_get_value_type (node), ==, G_TYPE_INVALID);
+  g_assert_cmpstr (json_node_type_name (node), ==, "NULL");
+
+  json_node_free (node);
+}
+
+static void
+test_value (void)
+{
+  JsonNode *node = json_node_new (JSON_NODE_VALUE);
+  GValue value = { 0, };
+  GValue check = { 0, };
+
+  g_assert_cmpint (JSON_NODE_TYPE (node), ==, JSON_NODE_VALUE);
+
+  g_value_init (&value, G_TYPE_INT64);
+  g_value_set_int64 (&value, 42);
+
+  g_assert_cmpint (G_VALUE_TYPE (&value), ==, G_TYPE_INT64);
+  g_assert_cmpint (g_value_get_int64 (&value), ==, 42);
+
+  json_node_set_value (node, &value);
+  json_node_get_value (node, &check);
+
+  g_assert_cmpint (G_VALUE_TYPE (&value), ==, G_VALUE_TYPE (&check));
+  g_assert_cmpint (g_value_get_int64 (&value), ==, g_value_get_int64 (&check));
+  g_assert_cmpint (G_VALUE_TYPE (&check), ==, G_TYPE_INT64);
+  g_assert_cmpint (g_value_get_int64 (&check), ==, 42);
+
+  g_value_unset (&value);
+  g_value_unset (&check);
+  json_node_free (node);
+}
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_type_init ();
+  g_test_init (&argc, &argv, NULL);
+
+  g_test_add_func ("/nodes/null-node", test_null);
+  g_test_add_func ("/nodes/copy-null", test_copy_null);
+  g_test_add_func ("/nodes/copy-value", test_copy_value);
+  g_test_add_func ("/nodes/copy-object", test_copy_object);
+  g_test_add_func ("/nodes/value", test_value);
+
+  return g_test_run ();
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/object-test.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/object-test.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/object-test.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/object-test.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,165 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <glib.h>
+#include <json-glib/json-glib.h>
+
+static void
+test_empty_object (void)
+{
+  JsonObject *object = json_object_new ();
+
+  g_assert_cmpint (json_object_get_size (object), ==, 0);
+  g_assert (json_object_get_members (object) == NULL);
+
+  json_object_unref (object);
+}
+
+static void
+test_add_member (void)
+{
+  JsonObject *object = json_object_new ();
+  JsonNode *node = json_node_new (JSON_NODE_NULL);
+
+  g_assert_cmpint (json_object_get_size (object), ==, 0);
+
+  json_object_set_member (object, "Null", node);
+  g_assert_cmpint (json_object_get_size (object), ==, 1);
+
+  node = json_object_get_member (object, "Null");
+  g_assert_cmpint (JSON_NODE_TYPE (node), ==, JSON_NODE_NULL);
+
+  json_object_unref (object);
+}
+
+static void
+test_set_member (void)
+{
+  JsonNode *node = json_node_new (JSON_NODE_VALUE);
+  JsonObject *object = json_object_new ();
+
+  g_assert_cmpint (json_object_get_size (object), ==, 0);
+
+  json_node_set_string (node, "Hello");
+
+  json_object_set_member (object, "String", node);
+  g_assert_cmpint (json_object_get_size (object), ==, 1);
+
+  node = json_object_get_member (object, "String");
+  g_assert_cmpint (JSON_NODE_TYPE (node), ==, JSON_NODE_VALUE);
+  g_assert_cmpstr (json_node_get_string (node), ==, "Hello");
+
+  json_object_set_string_member (object, "String", "World");
+  node = json_object_get_member (object, "String");
+  g_assert_cmpint (JSON_NODE_TYPE (node), ==, JSON_NODE_VALUE);
+  g_assert_cmpstr (json_node_get_string (node), ==, "World");
+
+  json_object_set_string_member (object, "String", "Goodbye");
+  g_assert_cmpstr (json_object_get_string_member (object, "String"), ==, "Goodbye");
+
+  json_object_unref (object);
+}
+
+static void
+test_remove_member (void)
+{
+  JsonObject *object = json_object_new ();
+  JsonNode *node = json_node_new (JSON_NODE_NULL);
+
+  json_object_set_member (object, "Null", node);
+
+  json_object_remove_member (object, "Null");
+  g_assert_cmpint (json_object_get_size (object), ==, 0);
+
+  json_object_unref (object);
+}
+
+typedef struct _TestForeachFixture
+{
+  gint n_members;
+} TestForeachFixture;
+
+static const struct {
+  const gchar *member_name;
+  JsonNodeType member_type;
+  GType member_gtype;
+} type_verify[] = {
+  { "integer", JSON_NODE_VALUE, G_TYPE_INT64 },
+  { "boolean", JSON_NODE_VALUE, G_TYPE_BOOLEAN },
+  { "string", JSON_NODE_VALUE, G_TYPE_STRING },
+  { "null", JSON_NODE_NULL, G_TYPE_INVALID }
+};
+
+static void
+verify_foreach (JsonObject  *object,
+                const gchar *member_name,
+                JsonNode    *member_node,
+                gpointer     user_data)
+{
+  TestForeachFixture *fixture = user_data;
+  gint i;
+
+  for (i = 0; i < G_N_ELEMENTS (type_verify); i++)
+    {
+      if (strcmp (member_name, type_verify[i].member_name) == 0)
+        {
+          g_assert (json_node_get_node_type (member_node) == type_verify[i].member_type);
+          g_assert (json_node_get_value_type (member_node) == type_verify[i].member_gtype);
+          break;
+        }
+    }
+
+  fixture->n_members += 1;
+}
+
+static void
+test_foreach_member (void)
+{
+  JsonObject *object = json_object_new ();
+  TestForeachFixture fixture = { 0, };
+
+  json_object_set_int_member (object, "integer", 42);
+  json_object_set_boolean_member (object, "boolean", TRUE);
+  json_object_set_string_member (object, "string", "hello");
+  json_object_set_null_member (object, "null");
+
+  json_object_foreach_member (object, verify_foreach, &fixture);
+
+  g_assert_cmpint (fixture.n_members, ==, json_object_get_size (object));
+
+  json_object_unref (object);
+}
+
+static void
+test_empty_member (void)
+{
+  JsonObject *object = json_object_new ();
+
+  json_object_set_string_member (object, "string", "");
+  g_assert (json_object_has_member (object, "string"));
+  g_assert_cmpstr (json_object_get_string_member (object, "string"), ==, "");
+
+  json_object_set_string_member (object, "null", NULL);
+  g_assert (json_object_has_member (object, "null"));
+  g_assert (json_object_get_string_member (object, "null") == NULL);
+
+  json_object_unref (object);
+}
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_type_init ();
+  g_test_init (&argc, &argv, NULL);
+
+  g_test_add_func ("/object/empty-object", test_empty_object);
+  g_test_add_func ("/object/add-member", test_add_member);
+  g_test_add_func ("/object/set-member", test_set_member);
+  g_test_add_func ("/object/remove-member", test_remove_member);
+  g_test_add_func ("/object/foreach-member", test_foreach_member);
+  g_test_add_func ("/object/empty-member", test_empty_member);
+
+  return g_test_run ();
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/parser-test.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/parser-test.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/parser-test.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/parser-test.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,785 @@
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <glib.h>
+
+#include <json-glib/json-glib.h>
+
+static const gchar *test_empty_string = "";
+static const gchar *test_empty_array_string = "[ ]";
+static const gchar *test_empty_object_string = "{ }";
+
+static void
+verify_int_value (JsonNode *node)
+{
+  g_assert_cmpint (42, ==, json_node_get_int (node));
+}
+
+static void
+verify_boolean_value (JsonNode *node)
+{
+  g_assert_cmpint (TRUE, ==, json_node_get_boolean (node));
+}
+
+static void
+verify_string_value (JsonNode *node)
+{
+  g_assert_cmpstr ("string", ==, json_node_get_string (node));
+}
+
+static void
+verify_double_value (JsonNode *node)
+{
+  g_assert_cmpfloat (10.2e3, ==, json_node_get_double (node));
+}
+
+static const struct {
+  const gchar *str;
+  JsonNodeType type;
+  GType gtype;
+  void (* verify_value) (JsonNode *node);
+} test_base_values[] = {
+  { "null",       JSON_NODE_NULL,  G_TYPE_INVALID, NULL, },
+  { "42",         JSON_NODE_VALUE, G_TYPE_INT64,   verify_int_value },
+  { "true",       JSON_NODE_VALUE, G_TYPE_BOOLEAN, verify_boolean_value },
+  { "\"string\"", JSON_NODE_VALUE, G_TYPE_STRING,  verify_string_value },
+  { "10.2e3",     JSON_NODE_VALUE, G_TYPE_DOUBLE,  verify_double_value }
+};
+
+static const struct {
+  const gchar *str;
+  gint len;
+  gint element;
+  JsonNodeType type;
+  GType gtype;
+} test_simple_arrays[] = {
+  { "[ true ]",                 1, 0, JSON_NODE_VALUE, G_TYPE_BOOLEAN },
+  { "[ true, false, null ]",    3, 2, JSON_NODE_NULL,  G_TYPE_INVALID },
+  { "[ 1, 2, 3.14, \"test\" ]", 4, 3, JSON_NODE_VALUE, G_TYPE_STRING  }
+};
+
+static const gchar *test_nested_arrays[] = {
+  "[ 42, [ ], null ]",
+  "[ [ ], [ true, [ true ] ] ]",
+  "[ [ false, true, 42 ], [ true, false, 3.14 ], \"test\" ]",
+  "[ true, { } ]",
+  "[ false, { \"test\" : 42 } ]",
+  "[ { \"test\" : 42 }, null ]",
+  "[ true, { \"test\" : 42 }, null ]",
+  "[ { \"channel\" : \"/meta/connect\" } ]"
+};
+
+static const struct {
+  const gchar *str;
+  gint size;
+  const gchar *member;
+  JsonNodeType type;
+  GType gtype;
+} test_simple_objects[] = {
+  { "{ \"test\" : 42 }", 1, "test", JSON_NODE_VALUE, G_TYPE_INT64 },
+  { "{ \"name\" : \"\", \"state\" : 1 }", 2, "name", JSON_NODE_VALUE, G_TYPE_STRING },
+  { "{ \"foo\" : \"bar\", \"baz\" : null }", 2, "baz", JSON_NODE_NULL, G_TYPE_INVALID },
+  { "{ \"channel\" : \"/meta/connect\" }", 1, "channel", JSON_NODE_VALUE, G_TYPE_STRING },
+  { "{ \"halign\":0.5, \"valign\":0.5 }", 2, "valign", JSON_NODE_VALUE, G_TYPE_DOUBLE }
+};
+
+static const gchar *test_nested_objects[] = {
+  "{ \"array\" : [ false, \"foo\" ], \"object\" : { \"foo\" : true } }",
+  "{ "
+    "\"type\" : \"ClutterGroup\", "
+    "\"width\" : 1, "
+    "\"children\" : [ "
+      "{ "
+        "\"type\" : \"ClutterRectangle\", "
+        "\"children\" : [ "
+          "{ \"type\" : \"ClutterText\", \"text\" : \"hello there\" }"
+        "] "
+      "}, "
+      "{ "
+        "\"type\" : \"ClutterGroup\", "
+        "\"width\" : 1, "
+        "\"children\" : [ "
+          "{ \"type\" : \"ClutterText\", \"text\" : \"hello\" }"
+        "] "
+      "} "
+    "] "
+  "}"
+};
+
+static const struct {
+  const gchar *str;
+  const gchar *var;
+} test_assignments[] = {
+  { "var foo = [ false, false, true ]", "foo" },
+  { "var bar = [ true, 42 ];", "bar" },
+  { "var baz = { \"foo\" : false }", "baz" }
+};
+
+static const struct
+{
+  const gchar *str;
+  const gchar *member;
+  const gchar *match;
+} test_unicode[] = {
+  { "{ \"test\" : \"foo \\u00e8\" }", "test", "foo " }
+};
+
+static const struct
+{
+  const gchar *str;
+  JsonParserError code;
+} test_invalid[] = {
+  { "test", JSON_PARSER_ERROR_INVALID_BAREWORD },
+  { "[ foo, ]", JSON_PARSER_ERROR_INVALID_BAREWORD },
+  { "[ true, ]", JSON_PARSER_ERROR_TRAILING_COMMA },
+  { "{ \"foo\" : true \"bar\" : false }", JSON_PARSER_ERROR_MISSING_COMMA },
+  { "[ true, [ false, ] ]", JSON_PARSER_ERROR_TRAILING_COMMA },
+  { "{ \"foo\" : { \"bar\" : false, } }", JSON_PARSER_ERROR_TRAILING_COMMA },
+  { "[ { }, { }, { }, ]", JSON_PARSER_ERROR_TRAILING_COMMA },
+  { "{ \"foo\" false }", JSON_PARSER_ERROR_MISSING_COLON }
+};
+
+static guint n_test_base_values    = G_N_ELEMENTS (test_base_values);
+static guint n_test_simple_arrays  = G_N_ELEMENTS (test_simple_arrays);
+static guint n_test_nested_arrays  = G_N_ELEMENTS (test_nested_arrays);
+static guint n_test_simple_objects = G_N_ELEMENTS (test_simple_objects);
+static guint n_test_nested_objects = G_N_ELEMENTS (test_nested_objects);
+static guint n_test_assignments    = G_N_ELEMENTS (test_assignments);
+static guint n_test_unicode        = G_N_ELEMENTS (test_unicode);
+static guint n_test_invalid        = G_N_ELEMENTS (test_invalid);
+
+static void
+test_empty (void)
+{
+  JsonParser *parser;
+  GError *error = NULL;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with empty string...\n");
+
+  if (!json_parser_load_from_data (parser, test_empty_string, -1, &error))
+    {
+      if (g_test_verbose ())
+        g_print ("Error: %s\n", error->message);
+      g_error_free (error);
+      g_object_unref (parser);
+      exit (1);
+    }
+  else
+    {
+      if (g_test_verbose ())
+        g_print ("checking json_parser_get_root...\n");
+
+      g_assert (NULL == json_parser_get_root (parser));
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_base_value (void)
+{
+  gint i;
+  JsonParser *parser;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with base-values...\n");
+
+  for (i = 0; i < n_test_base_values; i++)
+    {
+      GError *error = NULL;
+
+      if (!json_parser_load_from_data (parser, test_base_values[i].str, -1, &error))
+        {
+          if (g_test_verbose ())
+            g_print ("Error: %s\n", error->message);
+
+          g_error_free (error);
+          g_object_unref (parser);
+          exit (1);
+        }
+      else
+        {
+          JsonNode *root;
+
+          g_assert (NULL != json_parser_get_root (parser));
+
+          root = json_parser_get_root (parser);
+          g_assert (root != NULL);
+          g_assert (json_node_get_parent (root) == NULL);
+
+          if (g_test_verbose ())
+            g_print ("checking root node is of the desired type %s...\n",
+                     test_base_values[i].gtype == G_TYPE_INVALID ? "<null>"
+                                                                 : g_type_name (test_base_values[i].gtype));
+          g_assert_cmpint (JSON_NODE_TYPE (root), ==, test_base_values[i].type);
+          g_assert_cmpint (json_node_get_value_type (root), ==, test_base_values[i].gtype);
+
+          if (test_base_values[i].verify_value)
+            test_base_values[i].verify_value (root);
+       }
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_empty_array (void)
+{
+  JsonParser *parser;
+  GError *error = NULL;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with empty array...\n");
+
+  if (!json_parser_load_from_data (parser, test_empty_array_string, -1, &error))
+    {
+      if (g_test_verbose ())
+        g_print ("Error: %s\n", error->message);
+      g_error_free (error);
+      g_object_unref (parser);
+      exit (1);
+    }
+  else
+    {
+      JsonNode *root;
+      JsonArray *array;
+
+      g_assert (NULL != json_parser_get_root (parser));
+
+      if (g_test_verbose ())
+        g_print ("checking root node is an array...\n");
+      root = json_parser_get_root (parser);
+      g_assert_cmpint (JSON_NODE_TYPE (root), ==, JSON_NODE_ARRAY);
+      g_assert (json_node_get_parent (root) == NULL);
+
+      array = json_node_get_array (root);
+      g_assert (array != NULL);
+
+      if (g_test_verbose ())
+        g_print ("checking array is empty...\n");
+      g_assert_cmpint (json_array_get_length (array), ==, 0);
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_simple_array (void)
+{
+  gint i;
+  JsonParser *parser;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with simple arrays...\n");
+
+  for (i = 0; i < n_test_simple_arrays; i++)
+    {
+      GError *error = NULL;
+
+      if (g_test_verbose ())
+        g_print ("Parsing: '%s'\n", test_simple_arrays[i].str);
+
+      if (!json_parser_load_from_data (parser, test_simple_arrays[i].str, -1, &error))
+        {
+          if (g_test_verbose ())
+            g_print ("Error: %s\n", error->message);
+
+          g_error_free (error);
+          g_object_unref (parser);
+          exit (1);
+        }
+      else
+        {
+          JsonNode *root, *node;
+          JsonArray *array;
+
+          g_assert (NULL != json_parser_get_root (parser));
+
+          if (g_test_verbose ())
+            g_print ("checking root node is an array...\n");
+          root = json_parser_get_root (parser);
+          g_assert_cmpint (JSON_NODE_TYPE (root), ==, JSON_NODE_ARRAY);
+          g_assert (json_node_get_parent (root) == NULL);
+
+          array = json_node_get_array (root);
+          g_assert (array != NULL);
+
+          if (g_test_verbose ())
+            g_print ("checking array is of the desired length (%d)...\n",
+                     test_simple_arrays[i].len);
+          g_assert_cmpint (json_array_get_length (array), ==, test_simple_arrays[i].len);
+
+          if (g_test_verbose ())
+            g_print ("checking element %d is of the desired type %s...\n",
+                     test_simple_arrays[i].element,
+                     g_type_name (test_simple_arrays[i].gtype));
+          node = json_array_get_element (array, test_simple_arrays[i].element);
+          g_assert (node != NULL);
+          g_assert (json_node_get_parent (node) == root);
+          g_assert_cmpint (JSON_NODE_TYPE (node), ==, test_simple_arrays[i].type);
+          g_assert_cmpint (json_node_get_value_type (node), ==, test_simple_arrays[i].gtype);
+        }
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_nested_array (void)
+{
+  gint i;
+  JsonParser *parser;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with nested arrays...\n");
+
+  for (i = 0; i < n_test_nested_arrays; i++)
+    {
+      GError *error = NULL;
+
+      if (!json_parser_load_from_data (parser, test_nested_arrays[i], -1, &error))
+        {
+          if (g_test_verbose ())
+            g_print ("Error: %s\n", error->message);
+
+          g_error_free (error);
+          g_object_unref (parser);
+          exit (1);
+        }
+      else
+        {
+          JsonNode *root;
+          JsonArray *array;
+
+          g_assert (NULL != json_parser_get_root (parser));
+
+          if (g_test_verbose ())
+            g_print ("checking root node is an array...\n");
+          root = json_parser_get_root (parser);
+          g_assert_cmpint (JSON_NODE_TYPE (root), ==, JSON_NODE_ARRAY);
+          g_assert (json_node_get_parent (root) == NULL);
+
+          array = json_node_get_array (root);
+          g_assert (array != NULL);
+
+          if (g_test_verbose ())
+            g_print ("checking array is not empty...\n");
+          g_assert_cmpint (json_array_get_length (array), >, 0);
+        }
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_empty_object (void)
+{
+  JsonParser *parser;
+  GError *error = NULL;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with empty object...\n");
+
+  if (!json_parser_load_from_data (parser, test_empty_object_string, -1, &error))
+    {
+      if (g_test_verbose ())
+        g_print ("Error: %s\n", error->message);
+      g_error_free (error);
+      g_object_unref (parser);
+      exit (1);
+    }
+  else
+    {
+      JsonNode *root;
+      JsonObject *object;
+
+      g_assert (NULL != json_parser_get_root (parser));
+
+      if (g_test_verbose ())
+        g_print ("checking root node is an object...\n");
+      root = json_parser_get_root (parser);
+      g_assert (json_node_get_parent (root) == NULL);
+      g_assert_cmpint (JSON_NODE_TYPE (root), ==, JSON_NODE_OBJECT);
+      g_assert (json_node_get_parent (root) == NULL);
+
+      object = json_node_get_object (root);
+      g_assert (object != NULL);
+
+      if (g_test_verbose ())
+        g_print ("checking object is empty...\n");
+      g_assert_cmpint (json_object_get_size (object), ==, 0);
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_simple_object (void)
+{
+  gint i;
+  JsonParser *parser;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with simple objects...\n");
+
+  for (i = 0; i < n_test_simple_objects; i++)
+    {
+      GError *error = NULL;
+
+      if (!json_parser_load_from_data (parser, test_simple_objects[i].str, -1, &error))
+        {
+          if (g_test_verbose ())
+            g_print ("Error: %s\n", error->message);
+
+          g_error_free (error);
+          g_object_unref (parser);
+          exit (1);
+        }
+      else
+        {
+          JsonNode *root, *node;
+          JsonObject *object;
+
+          g_assert (NULL != json_parser_get_root (parser));
+
+          if (g_test_verbose ())
+            g_print ("checking root node is an object...\n");
+          root = json_parser_get_root (parser);
+          g_assert_cmpint (JSON_NODE_TYPE (root), ==, JSON_NODE_OBJECT);
+          g_assert (json_node_get_parent (root) == NULL);
+
+          object = json_node_get_object (root);
+          g_assert (object != NULL);
+
+          if (g_test_verbose ())
+            g_print ("checking object is of the desired size (%d)...\n",
+                     test_simple_objects[i].size);
+          g_assert_cmpint (json_object_get_size (object), ==, test_simple_objects[i].size);
+
+          if (g_test_verbose ())
+            g_print ("checking member '%s' is of the desired type %s...\n",
+                     test_simple_objects[i].member,
+                     g_type_name (test_simple_objects[i].gtype));
+          node = json_object_get_member (object, test_simple_objects[i].member);
+          g_assert (node != NULL);
+          g_assert (json_node_get_parent (node) == root);
+          g_assert_cmpint (JSON_NODE_TYPE (node), ==, test_simple_objects[i].type);
+          g_assert_cmpint (json_node_get_value_type (node), ==, test_simple_objects[i].gtype);
+        }
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_nested_object (void)
+{
+  gint i;
+  JsonParser *parser;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with nested objects...\n");
+
+  for (i = 0; i < n_test_nested_objects; i++)
+    {
+      GError *error = NULL;
+
+      if (!json_parser_load_from_data (parser, test_nested_objects[i], -1, &error))
+        {
+          if (g_test_verbose ())
+            g_print ("Error: %s\n", error->message);
+
+          g_error_free (error);
+          g_object_unref (parser);
+          exit (1);
+        }
+      else
+        {
+          JsonNode *root;
+          JsonObject *object;
+
+          g_assert (NULL != json_parser_get_root (parser));
+
+          if (g_test_verbose ())
+            g_print ("checking root node is an object...\n");
+          root = json_parser_get_root (parser);
+          g_assert_cmpint (JSON_NODE_TYPE (root), ==, JSON_NODE_OBJECT);
+          g_assert (json_node_get_parent (root) == NULL);
+
+          object = json_node_get_object (root);
+          g_assert (object != NULL);
+
+          if (g_test_verbose ())
+            g_print ("checking object is not empty...\n");
+          g_assert_cmpint (json_object_get_size (object), >, 0);
+        }
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_assignment (void)
+{
+  gint i;
+  JsonParser *parser;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with assignments...\n");
+
+  for (i = 0; i < n_test_assignments; i++)
+    {
+      GError *error = NULL;
+
+      if (!json_parser_load_from_data (parser, test_assignments[i].str, -1, &error))
+        {
+          if (g_test_verbose ())
+            g_print ("Error: %s\n", error->message);
+
+          g_error_free (error);
+          g_object_unref (parser);
+          exit (1);
+        }
+      else
+        {
+          gchar *var;
+
+          if (g_test_verbose ())
+            g_print ("checking assignment...\n");
+
+          g_assert (json_parser_has_assignment (parser, &var) == TRUE);
+          g_assert (var != NULL);
+          g_assert_cmpstr (var, ==, test_assignments[i].var);
+          g_assert (NULL != json_parser_get_root (parser));
+        }
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_unicode_escape (void)
+{
+  gint i;
+  JsonParser *parser;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with unicode escape...\n");
+
+  for (i = 0; i < n_test_unicode; i++)
+    {
+      GError *error = NULL;
+
+      if (!json_parser_load_from_data (parser, test_unicode[i].str, -1, &error))
+        {
+          if (g_test_verbose ())
+            g_print ("Error: %s\n", error->message);
+
+          g_error_free (error);
+          g_object_unref (parser);
+          exit (1);
+        }
+      else
+        {
+          JsonNode *root, *node;
+          JsonObject *object;
+
+          g_assert (NULL != json_parser_get_root (parser));
+
+          if (g_test_verbose ())
+            g_print ("checking root node is an object...\n");
+          root = json_parser_get_root (parser);
+          g_assert_cmpint (JSON_NODE_TYPE (root), ==, JSON_NODE_OBJECT);
+
+          object = json_node_get_object (root);
+          g_assert (object != NULL);
+
+          if (g_test_verbose ())
+            g_print ("checking object is not empty...\n");
+          g_assert_cmpint (json_object_get_size (object), >, 0);
+
+          node = json_object_get_member (object, test_unicode[i].member);
+          g_assert_cmpint (JSON_NODE_TYPE (node), ==, JSON_NODE_VALUE);
+
+          if (g_test_verbose ())
+            g_print ("checking simple string equality...\n");
+          g_assert_cmpstr (json_node_get_string (node), ==, test_unicode[i].match);
+
+          if (g_test_verbose ())
+            g_print ("checking for valid UTF-8...\n");
+          g_assert (g_utf8_validate (json_node_get_string (node), -1, NULL));
+        }
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_invalid_json (void)
+{
+  JsonParser *parser;
+  GError *error = NULL;
+  gint i;
+
+  parser = json_parser_new ();
+  g_assert (JSON_IS_PARSER (parser));
+
+  if (g_test_verbose ())
+    g_print ("checking json_parser_load_from_data with invalid data...\n");
+
+  for (i = 0; i < n_test_invalid; i++)
+    {
+      gboolean res;
+
+      if (g_test_verbose ())
+        g_print ("Parsing: '%s'\n", test_invalid[i].str);
+
+      res = json_parser_load_from_data (parser, test_invalid[i].str, -1,
+                                        &error);
+
+      g_assert (!res);
+      g_assert_error (error, JSON_PARSER_ERROR, test_invalid[i].code);
+
+      if (g_test_verbose ())
+        g_print ("Error: %s\n", error->message);
+
+      g_clear_error (&error);
+    }
+
+  g_object_unref (parser);
+}
+
+static void
+test_stream_sync (void)
+{
+  JsonParser *parser;
+  GFile *file;
+  GFileInputStream *stream;
+  GError *error = NULL;
+  JsonNode *root;
+
+  parser = json_parser_new ();
+
+  file = g_file_new_for_path (TESTS_DATA_DIR "/stream-load.json");
+  stream = g_file_read (file, NULL, &error);
+  g_assert (error == NULL);
+  g_assert (stream != NULL);
+
+  json_parser_load_from_stream (parser, G_INPUT_STREAM (stream), NULL, &error);
+  g_assert (error == NULL);
+
+  root = json_parser_get_root (parser);
+  g_assert (root != NULL);
+  g_assert (JSON_NODE_HOLDS_ARRAY (root));
+
+  g_object_unref (stream);
+  g_object_unref (file);
+  g_object_unref (parser);
+}
+
+static void
+on_load_complete (GObject      *gobject,
+                  GAsyncResult *result,
+                  gpointer      user_data)
+{
+  JsonParser *parser = JSON_PARSER (gobject);
+  GMainLoop *main_loop = user_data;
+  GError *error = NULL;
+  JsonNode *root;
+  gboolean res;
+
+  res = json_parser_load_from_stream_finish (parser, result, &error);
+  g_assert (res);
+  g_assert (error == NULL);
+
+  root = json_parser_get_root (parser);
+  g_assert (root != NULL);
+  g_assert (JSON_NODE_HOLDS_ARRAY (root));
+
+  g_main_loop_quit (main_loop);
+}
+
+static void
+test_stream_async (void)
+{
+  GMainLoop *main_loop;
+  GError *error = NULL;
+  JsonParser *parser = json_parser_new ();
+  GFile *file = g_file_new_for_path (TESTS_DATA_DIR "/stream-load.json");
+  GFileInputStream *stream = g_file_read (file, NULL, &error);
+
+  g_assert (error == NULL);
+  g_assert (stream != NULL);
+
+  main_loop = g_main_loop_new (NULL, FALSE);
+
+  json_parser_load_from_stream_async (parser, G_INPUT_STREAM (stream), NULL,
+                                      on_load_complete,
+                                      main_loop);
+
+  g_main_loop_run (main_loop);
+
+  g_main_loop_unref (main_loop);
+  g_object_unref (stream);
+  g_object_unref (file);
+  g_object_unref (parser);
+}
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_type_init ();
+  g_test_init (&argc, &argv, NULL);
+
+  g_test_add_func ("/parser/empty-string", test_empty);
+  g_test_add_func ("/parser/base-value", test_base_value);
+  g_test_add_func ("/parser/empty-array", test_empty_array);
+  g_test_add_func ("/parser/simple-array", test_simple_array);
+  g_test_add_func ("/parser/nested-array", test_nested_array);
+  g_test_add_func ("/parser/empty-object", test_empty_object);
+  g_test_add_func ("/parser/simple-object", test_simple_object);
+  g_test_add_func ("/parser/nested-object", test_nested_object);
+  g_test_add_func ("/parser/assignment", test_assignment);
+  g_test_add_func ("/parser/unicode-escape", test_unicode_escape);
+  g_test_add_func ("/parser/invalid-json", test_invalid_json);
+  g_test_add_func ("/parser/stream-sync", test_stream_sync);
+  g_test_add_func ("/parser/stream-async", test_stream_async);
+
+  return g_test_run ();
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/reader-test.c pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/reader-test.c
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/reader-test.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/reader-test.c	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1,134 @@
+#include <stdlib.h>
+#include <stdio.h>
+
+#include <glib.h>
+
+#include <json-glib/json-glib.h>
+
+static const gchar *test_base_array_data =
+"[ 0, true, null, \"foo\", 3.14, [ false ], { \"bar\" : 42 } ]";
+
+static const gchar *test_base_object_data =
+"{ \"text\" : \"hello, world!\", \"foo\" : \"bar\", \"blah\" : 47 }";
+
+static const gchar *expected_member_name[] = {
+  "text",
+  "foo",
+  "blah"
+};
+
+static void
+test_base_object (void)
+{
+  JsonParser *parser = json_parser_new ();
+  JsonReader *reader = json_reader_new (NULL);
+  GError *error = NULL;
+  gchar **members;
+  gsize n_members, i;
+
+  json_parser_load_from_data (parser, test_base_object_data, -1, &error);
+  g_assert (error == NULL);
+
+  json_reader_set_root (reader, json_parser_get_root (parser));
+
+  g_assert (json_reader_is_object (reader));
+  g_assert_cmpint (json_reader_count_members (reader), ==, 3);
+
+  members = json_reader_list_members (reader);
+  g_assert (members != NULL);
+
+  n_members = g_strv_length (members);
+  g_assert_cmpint (n_members, ==, json_reader_count_members (reader));
+
+  for (i = 0; i < n_members; i++)
+    g_assert_cmpstr (members[i], ==, expected_member_name[i]);
+
+  g_strfreev (members);
+
+  g_assert (json_reader_read_member (reader, "foo"));
+  g_assert (json_reader_is_value (reader));
+  g_assert_cmpstr (json_reader_get_string_value (reader), ==, "bar");
+  json_reader_end_member (reader);
+
+  g_assert (!json_reader_read_member (reader, "bar"));
+  g_assert (json_reader_get_error (reader) != NULL);
+  g_assert_error ((GError *) json_reader_get_error (reader),
+                  JSON_READER_ERROR,
+                  JSON_READER_ERROR_INVALID_MEMBER);
+  json_reader_end_member (reader);
+  g_assert (json_reader_get_error (reader) == NULL);
+
+  g_assert (json_reader_read_element (reader, 2));
+  g_assert_cmpstr (json_reader_get_member_name (reader), ==, "blah");
+  g_assert (json_reader_is_value (reader));
+  g_assert_cmpint (json_reader_get_int_value (reader), ==, 47);
+  json_reader_end_element (reader);
+  g_assert (json_reader_get_error (reader) == NULL);
+
+  g_object_unref (reader);
+  g_object_unref (parser);
+}
+
+static void
+test_base_array (void)
+{
+  JsonParser *parser = json_parser_new ();
+  JsonReader *reader = json_reader_new (NULL);
+  GError *error = NULL;
+
+  json_parser_load_from_data (parser, test_base_array_data, -1, &error);
+  g_assert (error == NULL);
+
+  json_reader_set_root (reader, json_parser_get_root (parser));
+
+  g_assert (json_reader_is_array (reader));
+  g_assert_cmpint (json_reader_count_elements (reader), ==, 7);
+
+  json_reader_read_element (reader, 0);
+  g_assert (json_reader_is_value (reader));
+  g_assert_cmpint (json_reader_get_int_value (reader), ==, 0);
+  json_reader_end_element (reader);
+
+  json_reader_read_element (reader, 3);
+  g_assert (json_reader_is_value (reader));
+  g_assert_cmpstr (json_reader_get_string_value (reader), ==, "foo");
+  json_reader_end_element (reader);
+
+  json_reader_read_element (reader, 5);
+  g_assert (!json_reader_is_value (reader));
+  g_assert (json_reader_is_array (reader));
+  json_reader_end_element (reader);
+
+  json_reader_read_element (reader, 6);
+  g_assert (json_reader_is_object (reader));
+
+  json_reader_read_member (reader, "bar");
+  g_assert (json_reader_is_value (reader));
+  g_assert_cmpint (json_reader_get_int_value (reader), ==, 42);
+  json_reader_end_member (reader);
+
+  json_reader_end_element (reader);
+
+  g_assert (!json_reader_read_element (reader, 7));
+  g_assert_error ((GError *) json_reader_get_error (reader),
+                  JSON_READER_ERROR,
+                  JSON_READER_ERROR_INVALID_INDEX);
+  json_reader_end_element (reader);
+  g_assert (json_reader_get_error (reader) == NULL);
+
+  g_object_unref (reader);
+}
+
+int
+main (int   argc,
+      char *argv[])
+{
+  g_type_init ();
+  g_test_init (&argc, &argv, NULL);
+  g_test_bug_base ("http://bugzilla.gnome.org/show_bug.cgi?id=");
+
+  g_test_add_func ("/reader/base-array", test_base_array);
+  g_test_add_func ("/reader/base-object", test_base_object);
+
+  return g_test_run ();
+}
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/stream-load.json pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/stream-load.json
--- pidgin-2.7.7/libpurple/protocols/facebook/json-glib/tests/stream-load.json	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/json-glib/tests/stream-load.json	2011-03-27 09:15:30.816552999 -0600
@@ -0,0 +1 @@
+[ { "hello" : "world!\n" } ]
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/libfacebook.c pidgin-2.7.7-new//libpurple/protocols/facebook/libfacebook.c
--- pidgin-2.7.7/libpurple/protocols/facebook/libfacebook.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/libfacebook.c	2011-03-27 09:15:30.892553000 -0600
@@ -0,0 +1,931 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#include "libfacebook.h"
+#include "fb_blist.h"
+#include "fb_connection.h"
+#include "fb_conversation.h"
+#include "fb_info.h"
+#include "fb_managefriends.h"
+#include "fb_messages.h"
+#include "fb_notifications.h"
+#include "fb_search.h"
+#include "fb_friendlist.h"
+#include "fb_chat.h"
+
+static void fb_login_cb(FacebookAccount *fba, const gchar *response, gsize len,
+		gpointer userdata);
+static void fb_close(PurpleConnection *pc);
+static void fb_buddy_free(PurpleBuddy *buddy);
+
+/******************************************************************************/
+/* PRPL functions */
+/******************************************************************************/
+
+static const char *fb_list_icon(PurpleAccount *account, PurpleBuddy *buddy)
+{
+	return "facebook";
+}
+
+static gchar *fb_status_text(PurpleBuddy *buddy)
+{
+	FacebookBuddy *fbuddy = buddy->proto_data;
+
+	if (fbuddy && fbuddy->status && *fbuddy->status != '\0')
+		return g_strdup(fbuddy->status);
+
+	return NULL;
+}
+
+static void fb_tooltip_text(PurpleBuddy *buddy,
+		PurpleNotifyUserInfo *userinfo, gboolean full)
+{
+	FacebookBuddy *fbuddy = buddy->proto_data;
+	gchar *status;
+
+	g_return_if_fail(fbuddy);
+
+	if (fbuddy->status && *fbuddy->status != '\0')
+	{
+		status = g_strdup_printf("%s %s",
+				fbuddy->name, fbuddy->status);
+
+		purple_notify_user_info_add_pair(userinfo,
+				_("Status"), status);
+		g_free(status);
+	}
+}
+
+static GList *fb_statuses(PurpleAccount *account)
+{
+	GList *types = NULL;
+	PurpleStatusType *status;
+
+	/* Online people have a status message and also a date when it was set */
+	status = purple_status_type_new_with_attrs(PURPLE_STATUS_AVAILABLE,
+		NULL, _("Online"), TRUE, TRUE, FALSE, "message",
+		_("Message"), purple_value_new(PURPLE_TYPE_STRING), NULL);
+	types = g_list_append(types, status);
+	
+	/* Cave into feature requests and allow people to set themselves to be idle */
+	status = purple_status_type_new_full(PURPLE_STATUS_AWAY, NULL, _("Idle"), FALSE, TRUE, FALSE);
+	types = g_list_append(types, status);
+
+	/* Offline people dont have messages */
+	status = purple_status_type_new_full(PURPLE_STATUS_OFFLINE, NULL, _("Offline"), TRUE, TRUE, FALSE);
+	types = g_list_append(types, status);
+
+	return types;
+}
+
+void fb_post_form_id_cb(FacebookAccount *fba)
+{
+	gchar *tmp;
+	
+	tmp = g_strdup_printf("visibility=true&post_form_id=%s", fba->post_form_id);
+	fb_post_or_get(fba, FB_METHOD_POST, "apps.facebook.com", "/ajax/chat/settings.php", tmp, NULL, NULL, FALSE);
+	g_free(tmp);
+	
+	if (fba->channel_number == NULL)
+	{
+		/* Grab new channel number */
+		fb_reconnect(fba);
+	} else {
+		fb_get_new_messages(fba);
+	}
+}
+
+static gboolean fb_get_messages_failsafe(FacebookAccount *fba)
+{
+	if (fba->last_messages_download_time < (time(NULL) - (60*5))) {
+		/* Messages haven't been downloaded in a while-
+		 * something is probably wrong */
+		purple_debug_warning("facebook",
+				"executing message check failsafe\n");
+		fb_get_post_form_id(fba, fb_post_form_id_cb);
+	}
+
+	return TRUE;
+}
+
+void fb_login_captcha_cancel_cb(PurpleConnection *pc, PurpleRequestFields *fields)
+{
+	purple_connection_error_reason(pc, PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
+		"Could not authenticate captcha.  Logging into the Facebook website may fix this.");
+}
+
+void fb_login_captcha_ok_cb(PurpleConnection *pc, PurpleRequestFields *fields)
+{
+	const gchar *captcha_response;
+	gchar *postdata, *encoded_username, *encoded_password, *encoded_charset_test,
+			*encoded_persist_data, *encoded_response, *encoded_extra_challenge,
+			*encoded_session;
+	FacebookAccount *fba = pc->proto_data;
+
+	captcha_response = purple_request_fields_get_string(fields, "captcha_response");
+	
+	encoded_response = g_strdup(purple_url_encode(captcha_response));
+	encoded_username = g_strdup(purple_url_encode(
+			purple_account_get_username(fba->account)));
+	encoded_password = g_strdup(purple_url_encode(
+			purple_account_get_password(fba->account)));
+	encoded_extra_challenge = g_strdup(purple_url_encode(
+			fba->extra_challenge));
+	encoded_persist_data = g_strdup(purple_url_encode(
+			fba->persist_data));
+	encoded_session = g_strdup(purple_url_encode(
+			fba->captcha_session));
+	encoded_charset_test = g_strdup(purple_url_encode(",,,,,,"));
+
+	postdata = g_strdup_printf("charset_test=%s&"
+								"version=1.0&"
+								"return_session=0&"
+								"charset_test=%s&"
+								"answered_captcha=1&"
+								"captcha_persist_data=%s&"
+								"captcha_session=%s&"
+								"extra_challenge_params=%s&"
+								"captcha_response=%s&"
+								"email=%s&pass=%s&"
+								"persistent=1",
+								encoded_charset_test, encoded_charset_test,
+								encoded_persist_data, encoded_session,
+								encoded_extra_challenge, encoded_response,
+								encoded_username, encoded_password);
+	g_free(encoded_username);
+	g_free(encoded_password);
+	g_free(encoded_charset_test);
+	g_free(encoded_extra_challenge);
+	g_free(encoded_persist_data);
+	g_free(encoded_response);
+	g_free(encoded_session);
+
+	fb_post_or_get(fba, FB_METHOD_POST | FB_METHOD_SSL, "login.facebook.com",
+			"/login.php?login_attempt=1&_fb_noscript=1", postdata, fb_login_cb, NULL, FALSE);
+	g_free(postdata);
+	
+	g_free(fba->extra_challenge);
+	g_free(fba->persist_data);
+	g_free(fba->captcha_session);
+	fba->extra_challenge = NULL;
+	fba->persist_data = NULL;
+	fba->captcha_session = NULL;
+}
+
+static void fb_login_captcha_image_cb(FacebookAccount *fba, const gchar *response, 
+		gsize len, gpointer userdata)
+{
+	PurpleRequestFields *fields;
+	PurpleRequestFieldGroup *group;
+	PurpleRequestField *field;
+	
+	fields = purple_request_fields_new();
+	group = purple_request_field_group_new(NULL);
+	purple_request_fields_add_group(fields, group);
+	
+	field = purple_request_field_image_new("captcha_image", "", response, len);
+	purple_request_field_group_add_field(group, field);
+	
+	field = purple_request_field_string_new("captcha_response", "", "", FALSE);
+	purple_request_field_group_add_field(group, field);
+	
+	purple_request_fields(fba->pc, 
+		_("Facebook Captcha"), _("Facebook Captcha"), 
+		_("Enter both words below, separated by a space"), 
+		fields, 
+		_("OK"), G_CALLBACK(fb_login_captcha_ok_cb), 
+		_("Logout"), G_CALLBACK(fb_login_captcha_cancel_cb), 
+		fba->account, NULL, NULL, fba->pc	 
+	);
+}
+
+static void fb_login_captcha_cb(FacebookAccount *fba, const gchar *response, 
+		gsize len, gpointer userdata)
+{
+	const gchar *challenge_start = "challenge : '";
+	gchar *challenge;
+	gchar *image_url;
+	
+	challenge = g_strstr_len(response, len, challenge_start);
+	if (challenge)
+	{
+		challenge += strlen(challenge_start);
+		challenge = g_strndup(challenge, strchr(challenge, '\'') - challenge);
+		
+		image_url = g_strdup_printf("/image?c=%s", challenge);
+		
+		fb_post_or_get(fba, FB_METHOD_GET | FB_METHOD_SSL, "api-secure.recaptcha.net",
+			image_url, NULL, fb_login_captcha_image_cb, NULL, FALSE);
+	}
+}
+
+static void fb_login_cb(FacebookAccount *fba, const gchar *response, gsize len,
+		gpointer userdata)
+{
+	gchar *user_cookie;
+	
+	if (len && g_strstr_len(response, len, "captcha") && !purple_account_get_bool(fba->account, "ignore-facebook-captcha", FALSE))
+	{
+		purple_debug_info("facebook", "captcha page: %s\n", response);
+
+		purple_connection_update_progress(fba->pc, _("Handling Captcha"), 2, 4);
+		
+		const gchar *persist_data_start = "<input type=\"hidden\" id=\"captcha_persist_data\" name=\"captcha_persist_data\" value=\"";
+		gchar *persist_data = g_strstr_len(response, len, persist_data_start);
+		if (persist_data)
+		{
+			persist_data += strlen(persist_data_start);
+			fba->persist_data = g_strndup(persist_data, strchr(persist_data, '"') - persist_data);
+		}
+		
+		const gchar *session_start = "<input type=\"hidden\" id=\"captcha_session\" name=\"captcha_session\" value=\"";
+		gchar *session = g_strstr_len(response, len, session_start);
+		if (session)
+		{
+			session += strlen(session_start);
+			fba->captcha_session = g_strndup(session, strchr(session, '"') - session);
+		}
+		
+		gchar *captcha_url;
+		const gchar *extra_challenge_params = "<input type=\"hidden\" id=\"extra_challenge_params\" name=\"extra_challenge_params\" value=\"";
+		gchar *extra_challenge = g_strstr_len(response, len, extra_challenge_params);
+		if (extra_challenge)
+		{
+			extra_challenge += strlen(extra_challenge_params);
+			fba->extra_challenge = g_strndup(extra_challenge, strchr(extra_challenge, '"') - extra_challenge);
+			extra_challenge = purple_unescape_html(fba->extra_challenge);
+			g_free(fba->extra_challenge);
+			fba->extra_challenge = extra_challenge;
+		}
+		
+		if (!fba->extra_challenge || !fba->persist_data || !fba->captcha_session)
+		{
+			purple_debug_info("facebook", "captcha response: %s\n", response);
+			g_free(fba->extra_challenge);
+			g_free(fba->persist_data);
+			g_free(fba->captcha_session);
+			fba->extra_challenge = NULL;
+			fba->persist_data = NULL;
+			fba->captcha_session = NULL;
+			purple_connection_error_reason(fba->pc, PURPLE_CONNECTION_ERROR_OTHER_ERROR,
+				"Could not authenticate captcha.  Logging into the Facebook website may fix this.");
+			return;
+		}
+		
+		captcha_url = g_strdup_printf("/challenge?k=" FACEBOOK_CAPTCHA_SITE "&%s",
+				fba->extra_challenge?fba->extra_challenge:"");
+		
+		fb_post_or_get(fba, FB_METHOD_GET | FB_METHOD_SSL, "api-secure.recaptcha.net",
+			captcha_url, NULL, fb_login_captcha_cb, NULL, FALSE);
+		
+		g_free(captcha_url);
+		
+		return;
+	}
+
+	
+	/* Check for new 'device login' security setting */
+	if (g_hash_table_lookup(fba->cookie_table, "lgnntfy") && !g_hash_table_lookup(fba->cookie_table, "c_user"))
+	{
+		purple_debug_info("facebook", "Registering computer name\n");
+		/* Facebook may need us to identify ourselves */
+		fb_post_or_get(fba, FB_METHOD_POST | FB_METHOD_SSL, "login.facebook.com",
+			"/loginnotify/setup_machine.php", "machinename=libpurple&remembercomputer=1", fb_login_cb, NULL, FALSE);
+		return;
+	}	
+
+	purple_connection_update_progress(fba->pc, _("Authenticating"), 2, 3);
+
+	/* Look for our uid */
+	user_cookie = g_hash_table_lookup(fba->cookie_table, "c_user");
+	if (user_cookie == NULL) {
+		/*
+		 * Server didn't set the c_user cookie, so we must have given
+		 * them a bad username or password
+		 */
+		purple_connection_error_reason(fba->pc,
+				PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
+				_("Incorrect username or password."));
+		return;
+	}
+	fba->uid = atoll(user_cookie);
+	purple_debug_info("facebook", "uid %" G_GINT64_FORMAT "\n", fba->uid);
+
+	/* ok, we're logged in now! */
+	purple_connection_set_state(fba->pc, PURPLE_CONNECTED);
+
+	/* Download a list of all group-chat's we belong to */
+	fb_get_groups(fba);
+
+	/* This will kick off our long-poll message retrieval loop */
+	fb_get_post_form_id(fba, &fb_post_form_id_cb);
+	fb_check_friend_requests(fba);
+
+	/* periodically check for people adding you to their facebook friend list */
+	fba->friend_request_timer = purple_timeout_add_seconds(60 * 5,
+			fb_check_friend_requests, fba);
+
+	/* periodically check for new notifications */
+	fba->notifications_timer = purple_timeout_add_seconds(60,
+			(GSourceFunc)fb_get_notifications_feed, fba);
+
+	/* Periodically check for new messages.  NOTE: This MUST exist,
+	 * regardless of other other mechanisms for checking messages.  This
+	 * is because the code needs a failsafe checker in case other one of
+	 * the other retrieval mechanisms dies due to a bad request, etc.
+	 * Without such a failsafe, a user will receive no messages, which is
+	 * one of hardest bugs to debug and get reports about.  Hence, the
+	 * importance of this loop.
+	 * That said, there is room for tweaking this loop and possibly even
+	 * setting it such that it is the primary or only message checker.
+	 * The key is that the method must NEVER die until logout.
+	 */
+	fba->perpetual_messages_timer = purple_timeout_add_seconds(15,
+			(GSourceFunc)fb_get_messages_failsafe, fba);
+
+	/* init blist subsystem */
+	fb_blist_init(fba);
+
+	/* init conversation subsystem */
+	fb_conversation_init(fba);
+}
+
+gboolean fb_do_http_login(FacebookAccount *fba, 
+		FacebookProxyCallbackFunc callback_func, gpointer user_data)
+{
+	gchar *postdata, *encoded_username, *encoded_password, *encoded_charset_test;
+	const gchar* const *languages;
+	const gchar *locale;
+	
+	if (fba == NULL)
+		return FALSE;
+	
+	/* Error localized in libpurple jabber.c */
+	if (!purple_ssl_is_supported()) {
+		purple_connection_error_reason (fba->pc,
+										PURPLE_CONNECTION_ERROR_NO_SSL_SUPPORT,
+										_("Server requires TLS/SSL for login.  No TLS/SSL support found."));
+		return FALSE;
+	}
+	
+	if (fba->cookie_table == NULL)
+		fba->cookie_table = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	if (fba->hostname_ip_cache == NULL)
+		fba->hostname_ip_cache = g_hash_table_new_full(g_str_hash, g_str_equal, g_free, g_free);
+	if (fba->waiting_conns == NULL)
+		fba->waiting_conns = g_queue_new();
+	
+	g_hash_table_replace(fba->cookie_table, g_strdup("test_cookie"), g_strdup("1"));
+	g_hash_table_replace(fba->cookie_table, g_strdup("lsd"), g_strdup("abcde"));
+	
+	encoded_username = g_strdup(purple_url_encode(purple_account_get_username(fba->account)));
+	encoded_password = g_strdup(purple_url_encode(purple_account_get_password(fba->account)));
+	encoded_charset_test = g_strdup(purple_url_encode(",,,,,,"));
+	languages = g_get_language_names();
+	locale = languages[0];
+	if (locale == NULL || g_str_equal(locale, "C"))
+		locale = "en_US";
+	
+	postdata = g_strdup_printf("charset_test=%s&locale=%s&email=%s&pass=%s&"
+							   "pass_placeHolder=Password&persistent=1&"
+							   "login=Login&charset_test=%s&lsd=abcde",
+							   encoded_charset_test, locale, encoded_username, 
+							   encoded_password, encoded_charset_test);
+	g_free(encoded_username);
+	g_free(encoded_password);
+	g_free(encoded_charset_test);
+	
+	fb_post_or_get(fba, FB_METHOD_POST | FB_METHOD_SSL, "login.facebook.com",
+				   "/login.php?login_attempt=1&_fb_noscript=1", postdata, callback_func, user_data, FALSE);
+	g_free(postdata);
+	
+	return TRUE;
+}
+
+static void fb_login(PurpleAccount *account)
+{
+	FacebookAccount *fba;
+	
+	/* Force disable captcha */
+	purple_account_set_bool(account, "ignore-facebook-captcha", TRUE);
+	
+	/* Create account and initialize state */
+	fba = g_new0(FacebookAccount, 1);
+	fba->account = account;
+	fba->pc = purple_account_get_connection(account);
+	fba->uid = -1;
+	fba->last_messages_download_time = time(NULL) - 60; /* 60 secs is a safe buffer */
+	fba->cookie_table = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, g_free);
+	fba->hostname_ip_cache = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, g_free);
+	fba->sent_messages_hash = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, NULL);
+	fba->auth_buddies = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, NULL);
+
+	account->gc->proto_data = fba;
+
+	purple_connection_set_state(fba->pc, PURPLE_CONNECTING);
+	purple_connection_update_progress(fba->pc, _("Connecting"), 1, 3);
+
+	fb_do_http_login(fba, fb_login_cb, NULL);
+}
+
+static void fb_close(PurpleConnection *pc)
+{
+	FacebookAccount *fba;
+	GSList *buddies;
+
+	purple_debug_info("facebook", "disconnecting account\n");
+
+	g_return_if_fail(pc != NULL);
+	g_return_if_fail(pc->proto_data != NULL);
+	
+	fba = pc->proto_data;
+
+	purple_debug_info("facebook", "unloading plugin\n");
+
+	/* destroy blist subsystem */
+	fb_blist_destroy(fba);
+
+	/* destroy conversation subsystem */
+	fb_conversation_destroy(fba);
+
+	buddies = purple_find_buddies(fba->account, NULL);
+	while(buddies) {
+		PurpleBuddy *b = buddies->data;
+		fb_buddy_free(b);
+		buddies = g_slist_delete_link(buddies, buddies);
+	}
+
+	if (fba->friend_request_timer) {
+		purple_timeout_remove(fba->friend_request_timer);
+	}
+	if (fba->notifications_timer) {
+		purple_timeout_remove(fba->notifications_timer);
+	}
+	if (fba->new_messages_check_timer) {
+		purple_timeout_remove(fba->new_messages_check_timer);
+	}
+	if (fba->perpetual_messages_timer) {
+		purple_timeout_remove(fba->perpetual_messages_timer);
+	}
+	
+	purple_debug_info("facebook", "destroying %d waiting connections\n",
+					  g_queue_get_length(fba->waiting_conns));
+	
+	while (!g_queue_is_empty(fba->waiting_conns))
+		fb_connection_destroy(g_queue_pop_tail(fba->waiting_conns));
+	g_queue_free(fba->waiting_conns);
+	
+	purple_debug_info("facebook", "destroying %d incomplete connections\n",
+			g_slist_length(fba->conns));
+
+	while (fba->conns != NULL)
+		fb_connection_destroy(fba->conns->data);
+
+	while (fba->dns_queries != NULL) {
+		PurpleDnsQueryData *dns_query = fba->dns_queries->data;
+		purple_debug_info("facebook", "canceling dns query for %s\n",
+					purple_dnsquery_get_host(dns_query));
+		fba->dns_queries = g_slist_remove(fba->dns_queries, dns_query);
+		purple_dnsquery_destroy(dns_query);
+	}
+	
+	if (fba->resending_messages != NULL) {
+		fb_cancel_resending_messages(fba);
+	}
+
+	g_hash_table_destroy(fba->sent_messages_hash);
+	g_hash_table_destroy(fba->cookie_table);
+	g_hash_table_destroy(fba->hostname_ip_cache);
+	g_hash_table_destroy(fba->auth_buddies);
+	g_free(fba->post_form_id);
+	g_free(fba->dtsg);
+	g_free(fba->channel_number);
+	g_free(fba->last_status_message);
+	g_free(fba->extra_challenge);
+	g_free(fba->captcha_session);
+	g_free(fba->persist_data);
+	g_free(fba);
+}
+
+static unsigned int fb_send_typing(PurpleConnection *pc, const gchar *name,
+		PurpleTypingState state)
+{
+	int typing_state;
+	gchar *postdata;
+	FacebookAccount *fba = pc->proto_data;
+	gchar *encoded_name;
+
+	g_return_val_if_fail(fba != NULL, 0);
+	g_return_val_if_fail(fba->post_form_id != NULL, 0);
+
+	typing_state = (state == PURPLE_TYPING) ? 1 : 0;
+
+	/* Don't send typing notifications to self */
+	if (atoll(name) != fba->uid)
+	{
+		encoded_name = g_strdup(purple_url_encode(name));
+		postdata = g_strdup_printf("typ=%d&to=%s&post_form_id=%s",
+				typing_state, encoded_name, fba->post_form_id);
+		g_free(encoded_name);
+		fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/chat/typ.php?__a=1",
+				postdata, NULL, NULL, FALSE);
+		g_free(postdata);
+	} else {
+		serv_got_typing(pc, name, 10, state);
+	}
+
+	/* 7 is the number of seconds before sending the new typing state.  It
+	 * corresponds with the default value that Facebook waits. */
+	return 7;
+}
+
+static void fb_set_status_ok_cb(gpointer data, const gchar *status_text)
+{
+	PurpleConnection *pc = data;
+	FacebookAccount *fba = pc->proto_data;
+	gchar *postdata;
+	gchar *status_tmp;
+	gchar *status_text_new;
+
+	g_return_if_fail(fba->post_form_id != NULL);
+
+	status_text_new = g_strstrip(g_strdup(status_text));
+
+	/* don't set the status if it's idential to what we've already set */
+	if (fba->last_status_message && g_str_equal(fba->last_status_message,
+				status_text_new)) {
+		g_free(status_text_new);
+		return;
+	}
+
+	g_free(fba->last_status_message);
+	fba->last_status_message = status_text_new;
+
+	if (*status_text_new != '\0')
+	{
+		status_tmp = g_strdup(purple_url_encode(status_text_new));
+		postdata = g_strdup_printf("profile_id=%" G_GINT64_FORMAT "&status=%s&post_form_id=%s&fb_dtsg=%s",
+				fba->uid, status_tmp, fba->post_form_id, fba->dtsg);
+		g_free(status_tmp);
+	}
+	else
+		postdata = g_strdup_printf("profile_id=%" G_GINT64_FORMAT "&clear=1&post_form_id=%s&fb_dtsg=%s",
+				fba->uid, fba->post_form_id, fba->dtsg);
+
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, "/ajax/updatestatus.php?__a=1",
+			postdata, NULL, NULL, FALSE);
+
+	g_free(postdata);
+}
+
+static void fb_set_status_p(PurpleAccount *account, PurpleStatus *status)
+{
+	const gchar *message;
+	gchar *stripped;
+	FacebookAccount *fba = account->gc->proto_data;
+
+	/* if "away" set idle */
+	if (purple_status_type_get_primitive(purple_status_get_type(status)) == PURPLE_STATUS_AWAY)
+	{
+		if (fba)
+		{
+			fba->is_idle = TRUE;
+		}
+		return;
+	}
+
+	/* first check that we actually want to set this through Pidgin */
+	if (!purple_account_get_bool(account,
+				"facebook_set_status_through_pidgin", FALSE))
+	{
+		return;
+	}
+
+	message = purple_status_get_attr_string(status, "message");
+	if (message == NULL)
+		message = "";
+
+	stripped = purple_markup_strip_html(message);
+	fb_set_status_ok_cb(account->gc, stripped);
+	g_free(stripped);
+}
+
+static void fb_buddy_free(PurpleBuddy *buddy)
+{
+	FacebookBuddy *fbuddy = buddy->proto_data;
+	if (fbuddy != NULL)
+	{
+		buddy->proto_data = NULL;
+
+		g_free(fbuddy->name);
+		g_free(fbuddy->status);
+		g_free(fbuddy->thumb_url);
+		g_free(fbuddy);
+	}
+}
+
+#if PURPLE_MAJOR_VERSION >= 2 && PURPLE_MINOR_VERSION >= 5
+static GHashTable *fb_get_account_text_table(PurpleAccount *account)
+{
+	GHashTable *table;
+
+	table = g_hash_table_new(g_str_hash, g_str_equal);
+
+	g_hash_table_insert(table, "login_label", (gpointer)_("Email Address..."));
+
+	return table;
+}
+#endif
+
+/******************************************************************************/
+/* Plugin functions */
+/******************************************************************************/
+
+static gboolean plugin_load(PurplePlugin *plugin)
+{
+	return TRUE;
+}
+
+static gboolean plugin_unload(PurplePlugin *plugin)
+{
+	return TRUE;
+}
+
+static void fb_set_status_cb(PurplePluginAction *action)
+{
+	PurpleConnection *pc = action->context;
+	FacebookAccount *fba = pc->proto_data;
+	gchar *uid_str;
+
+	uid_str = g_strdup_printf("%" G_GINT64_FORMAT, fba->uid);
+
+	purple_request_input(pc, NULL, _("Set your Facebook status"),
+			purple_account_get_alias(pc->account), "is ",
+			FALSE, FALSE, NULL, _("OK"),
+			G_CALLBACK(fb_set_status_ok_cb), _("Cancel"),
+			NULL, pc->account, uid_str, NULL, pc);
+
+	g_free(uid_str);
+}
+
+static void fb_display_plugin_info(PurplePluginAction *action)
+{
+	purple_notify_info(action->context, _("About Facebook for Pidgin"),
+			_("Version"), FACEBOOK_PLUGIN_VERSION);
+}
+
+static void fb_refresh_blist(PurplePluginAction *action)
+{
+	PurpleConnection *pc;
+	FacebookAccount *fba;
+
+	pc = (PurpleConnection *) action->context;
+	fba = pc->proto_data;
+
+	fb_get_buddy_list(fba);
+}
+
+static GList *fb_actions(PurplePlugin *plugin, gpointer context)
+{
+	GList *m = NULL;
+	PurplePluginAction *act;
+
+	act = purple_plugin_action_new(_("About Facebook for Pidgin"),
+			fb_display_plugin_info);
+	m = g_list_append(m, act);
+
+	act = purple_plugin_action_new(_("Set Facebook status..."),
+			fb_set_status_cb);
+	m = g_list_append(m, act);
+
+	act = purple_plugin_action_new(_("Search for buddies..."),
+			fb_search_users);
+	m = g_list_append(m, act);
+
+	// TODO: remove, this is for testing.  REMOVE.
+	act = purple_plugin_action_new(_("Refresh buddy list..."),
+			fb_refresh_blist);
+	m = g_list_append(m, act);
+
+	return m;
+}
+
+static GList *fb_node_menu(PurpleBlistNode *node)
+{
+	GList *m = NULL;
+	PurpleMenuAction *act;
+	PurpleBuddy *buddy;
+	
+	if(PURPLE_BLIST_NODE_IS_BUDDY(node))
+	{
+		buddy = (PurpleBuddy *)node;
+		
+		act = purple_menu_action_new(_("_Poke"),
+				PURPLE_CALLBACK(fb_blist_poke_buddy),
+				NULL, NULL);
+		m = g_list_append(m, act);
+	}
+	return m;
+}
+
+static void fb_set_idle(PurpleConnection *gc, int time)
+{
+	FacebookAccount *fba = gc->proto_data;
+	
+	g_return_if_fail(fba != NULL);
+	
+	if (time)
+	{
+		fba->is_idle = TRUE;
+	} else {
+		fba->is_idle = FALSE;
+	}
+}
+
+static void plugin_init(PurplePlugin *plugin)
+{
+	PurpleAccountOption *option;
+	PurplePluginInfo *info = plugin->info;
+	PurplePluginProtocolInfo *prpl_info = info->extra_info;
+
+	/* Add options to the advanced screen in the account settings */
+	option = purple_account_option_bool_new(
+		_("Show history in new conversations"),
+		"facebook_show_history", TRUE);
+	prpl_info->protocol_options = g_list_append(
+		prpl_info->protocol_options, option);
+
+	
+	option = purple_account_option_bool_new(
+		_("Use Facebook friend-lists as Pidgin groups"),
+		"facebook_use_groups", TRUE);
+	prpl_info->protocol_options = g_list_append(
+		prpl_info->protocol_options, option);
+	
+	option = purple_account_option_bool_new(
+		_("Hide myself in the Buddy List"),
+		"facebook_hide_self", TRUE);
+	prpl_info->protocol_options = g_list_append(
+		prpl_info->protocol_options, option);
+
+	option = purple_account_option_bool_new(
+		_("Set Facebook status through Pidgin status"),
+		"facebook_set_status_through_pidgin", FALSE);
+	prpl_info->protocol_options = g_list_append(
+		prpl_info->protocol_options, option);
+
+	option = purple_account_option_bool_new(
+		_("Show Facebook notifications as e-mails in Pidgin"),
+		"facebook_get_notifications", TRUE);
+	prpl_info->protocol_options = g_list_append(
+		prpl_info->protocol_options, option);
+	
+	option = purple_account_option_string_new(
+		_("Notifications RSS Feed URL"),
+		"notifications_feed_url", "");
+	prpl_info->protocol_options = g_list_append(
+		prpl_info->protocol_options, option);
+
+	option = purple_account_option_bool_new(
+		_("Edit Facebook friends from Pidgin"),
+		"facebook_manage_friends", FALSE);
+	prpl_info->protocol_options = g_list_append(
+		prpl_info->protocol_options, option);
+
+	option = purple_account_option_bool_new(
+		_("Always use HTTPS"),
+		"use-https", FALSE);
+	prpl_info->protocol_options = g_list_append(
+		prpl_info->protocol_options, option);
+}
+
+static PurplePluginProtocolInfo prpl_info = {
+	/* options */
+	OPT_PROTO_MAIL_CHECK,
+
+	NULL,                   /* user_splits */
+	NULL,                   /* protocol_options */
+	/* NO_BUDDY_ICONS */    /* icon_spec */
+	{"jpg", 0, 0, 50, 50, -1, PURPLE_ICON_SCALE_SEND}, /* icon_spec */
+	fb_list_icon,           /* list_icon */
+	NULL,                   /* list_emblems */
+	fb_status_text,         /* status_text */
+	fb_tooltip_text,        /* tooltip_text */
+	fb_statuses,            /* status_types */
+	fb_node_menu,           /* blist_node_menu */
+	fb_chat_info,           /* chat_info */
+	fb_chat_info_defaults,  /* chat_info_defaults */
+	fb_login,               /* login */
+	fb_close,               /* close */
+	fb_send_im,             /* send_im */
+	NULL,                   /* set_info */
+	fb_send_typing,         /* send_typing */
+	fb_get_info,            /* get_info */
+	fb_set_status_p,        /* set_status */
+	fb_set_idle,            /* set_idle */
+	NULL,                   /* change_passwd */
+	fb_add_buddy,           /* add_buddy */
+	NULL,                   /* add_buddies */
+	fb_buddy_remove,        /* remove_buddy */
+	NULL,                   /* remove_buddies */
+	NULL,                   /* add_permit */
+	NULL,                   /* add_deny */
+	NULL,                   /* rem_permit */
+	NULL,                   /* rem_deny */
+	NULL,                   /* set_permit_deny */
+	fb_fake_join_chat,      /* join_chat */
+	NULL,                   /* reject chat invite */
+	fb_get_chat_name,       /* get_chat_name */
+	NULL,                   /* chat_invite */
+	fb_chat_fake_leave,     /* chat_leave */
+	NULL,                   /* chat_whisper */
+	fb_chat_send,           /* chat_send */
+	NULL,                   /* keepalive */
+	NULL,                   /* register_user */
+	NULL,                   /* get_cb_info */
+	NULL,                   /* get_cb_away */
+	NULL,                   /* alias_buddy */
+	fb_group_buddy_move,    /* group_buddy */
+	fb_group_rename,        /* rename_group */
+	fb_buddy_free,          /* buddy_free */
+	fb_conversation_closed, /* convo_closed */
+	purple_normalize_nocase,/* normalize */
+	NULL,                   /* set_buddy_icon */
+	fb_group_remove,        /* remove_group */
+	NULL,                   /* get_cb_real_name */
+	NULL,                   /* set_chat_topic */
+	NULL,                   /* find_blist_chat */
+	NULL,                   /* roomlist_get_list */
+	NULL,                   /* roomlist_cancel */
+	NULL,                   /* roomlist_expand_category */
+	NULL,                   /* can_receive_file */
+	NULL,                   /* send_file */
+	NULL,                   /* new_xfer */
+	NULL,                   /* offline_message */
+	NULL,                   /* whiteboard_prpl_ops */
+	NULL,                   /* send_raw */
+	NULL,                   /* roomlist_room_serialize */
+	NULL,                   /* unregister_user */
+	NULL,                   /* send_attention */
+	NULL,                   /* attention_types */
+#if PURPLE_MAJOR_VERSION >= 2 && PURPLE_MINOR_VERSION >= 5
+	sizeof(PurplePluginProtocolInfo), /* struct_size */
+	fb_get_account_text_table, /* get_account_text_table */
+#else
+	(gpointer) sizeof(PurplePluginProtocolInfo)
+#endif
+};
+
+static PurplePluginInfo info = {
+	PURPLE_PLUGIN_MAGIC,
+	2,						/* major_version */
+	3, 						/* minor version */
+	PURPLE_PLUGIN_PROTOCOL, 			/* type */
+	NULL, 						/* ui_requirement */
+	0, 						/* flags */
+	NULL, 						/* dependencies */
+	PURPLE_PRIORITY_DEFAULT, 			/* priority */
+	FACEBOOK_PLUGIN_ID,				/* id */
+	"Facebook", 					/* name */
+	FACEBOOK_PLUGIN_VERSION, 			/* version */
+	N_("Facebook Protocol Plugin"), 		/* summary */
+	N_("Facebook Protocol Plugin"), 		/* description */
+	"Eion Robb <eionrobb@gmail.com>", 		/* author */
+	"http://pidgin-facebookchat.googlecode.com/",	/* homepage */
+	plugin_load, 					/* load */
+	plugin_unload, 					/* unload */
+	NULL, 						/* destroy */
+	NULL, 						/* ui_info */
+	&prpl_info, 					/* extra_info */
+	NULL, 						/* prefs_info */
+	fb_actions, 					/* actions */
+
+							/* padding */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+PURPLE_INIT_PLUGIN(facebook, plugin_init, info);
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/libfacebook.h pidgin-2.7.7-new//libpurple/protocols/facebook/libfacebook.h
--- pidgin-2.7.7/libpurple/protocols/facebook/libfacebook.h	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/libfacebook.h	2011-03-27 09:15:30.936552999 -0600
@@ -0,0 +1,136 @@
+/*
+ * libfacebook
+ *
+ * libfacebook is the property of its developers.  See the COPYRIGHT file
+ * for more details.
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef LIBFACEBOOK_H
+#define LIBFACEBOOK_H
+
+#define FACEBOOK_PLUGIN_VERSION "1.69"
+#define FACEBOOK_PLUGIN_ID "prpl-bigbrownchunx-facebookim"
+#define FACEBOOK_CAPTCHA_SITE "6LezHAAAAAAAADqVjseQ3ctG3ocfQs2Elo1FTa_a"
+
+/* Maximum number of simultaneous connections to a server */
+#define FB_MAX_CONNECTIONS 16
+
+#include <glib.h>
+
+#include <errno.h>
+#include <string.h>
+#include <glib/gi18n.h>
+#include <sys/types.h>
+#include <unistd.h>
+
+#ifndef G_GNUC_NULL_TERMINATED
+#	if __GNUC__ >= 4
+#		define G_GNUC_NULL_TERMINATED __attribute__((__sentinel__))
+#	else
+#		define G_GNUC_NULL_TERMINATED
+#	endif /* __GNUC__ >= 4 */
+#endif /* G_GNUC_NULL_TERMINATED */
+
+#ifdef _WIN32
+#	include "win32dep.h"
+#	define dlopen(a,b) LoadLibrary(a)
+#	define RTLD_LAZY
+#	define dlsym(a,b) GetProcAddress(a,b)
+#	define dlclose(a) FreeLibrary(a)
+#else
+#	include <arpa/inet.h>
+#	include <dlfcn.h>
+#	include <netinet/in.h>
+#	include <sys/socket.h>
+#endif
+
+#ifndef PURPLE_PLUGINS
+#	define PURPLE_PLUGINS
+#endif
+
+#include "accountopt.h"
+#include "connection.h"
+#include "debug.h"
+#include "dnsquery.h"
+#include "proxy.h"
+#include "prpl.h"
+#include "request.h"
+#include "sslconn.h"
+#include "version.h"
+
+#if GLIB_MAJOR_VERSION >= 2 && GLIB_MINOR_VERSION >= 12
+#	define atoll(a) g_ascii_strtoll(a, NULL, 0)
+#endif
+
+#define FB_MAX_MSG_RETRY 2
+
+typedef struct _FacebookAccount FacebookAccount;
+typedef struct _FacebookBuddy FacebookBuddy;
+
+typedef void (*FacebookProxyCallbackFunc)(FacebookAccount *fba, const gchar *data, gsize data_len, gpointer user_data);
+typedef void (*FacebookFunc)(FacebookAccount *fba);
+
+struct _FacebookAccount {
+	PurpleAccount *account;
+	PurpleConnection *pc;
+	GSList *conns; /**< A list of all active FacebookConnections */
+	GQueue *waiting_conns; /**< A list of all FacebookConnections waiting to process */
+	GSList *dns_queries;
+	GHashTable *cookie_table;
+	gchar *post_form_id;
+	gint64 uid;
+	guint buddy_list_timer; 		/* handled by fb_blist */
+	GHashTable *friend_lists;		/* handled by fb_friendlist */
+	GHashTable *friend_lists_reverse;	/* handled by fb_friendlist */
+	guint friend_request_timer;
+	gchar *channel_number;
+	guint message_fetch_sequence;
+	gint64 last_message_time;		/* handled by fb_conversation */
+	GSList *resending_messages;
+	GHashTable *auth_buddies;
+	GHashTable *hostname_ip_cache;
+	guint notifications_timer;
+	time_t last_messages_download_time;
+	guint new_messages_check_timer;
+	guint perpetual_messages_timer;
+	gchar *last_status_message;
+	gboolean is_idle;
+	GHashTable *sent_messages_hash;
+	gint last_inbox_count;
+	gchar *extra_challenge;
+	gchar *persist_data;
+	gchar *captcha_session;
+	gint last_status_timestamp;
+	guint bad_buddy_list_count;
+	gchar *dtsg;
+};
+
+struct _FacebookBuddy {
+	FacebookAccount *fba;
+	PurpleBuddy *buddy;
+	gint64 uid;
+	gchar *name;
+	gchar *status;
+	gchar *thumb_url;
+};
+
+
+gboolean fb_do_http_login(FacebookAccount *fba, 
+		FacebookProxyCallbackFunc callback_func, gpointer user_data);
+
+/* These functions here are public for libfbxmpp.c */
+
+#endif /* LIBFACEBOOK_H */
Binary files pidgin-2.7.7/libpurple/protocols/facebook/libfacebook.so and pidgin-2.7.7-new//libpurple/protocols/facebook/libfacebook.so differ
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/libfbxmpp.c pidgin-2.7.7-new//libpurple/protocols/facebook/libfbxmpp.c
--- pidgin-2.7.7/libpurple/protocols/facebook/libfbxmpp.c	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/libfbxmpp.c	2011-03-27 09:15:30.736552999 -0600
@@ -0,0 +1,584 @@
+/* purple
+ *
+ * Purple is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+
+/* libxmpp is the XMPP protocol plugin. It is linked against libjabbercommon,
+ * which may be used to support other protocols (Bonjour) which may need to
+ * share code.
+ */
+
+#include "libfacebook.h"
+#include "fb_util.h"
+#include "fb_connection.h"
+#include "fb_messages.h"
+#include "jabber.h"
+
+#define FACEBOOK_APP_ID "107899262577150"
+#define FACEBOOK_API_KEY "ff26b9e09239e33babaeaf747c778926"
+#define FACEBOOK_SECRET "57a7da14aa16458ab1490fd305b6f545"
+
+#define FACEBOOK_XMPP_PLUGIN_ID "prpl-bigbrownchunx-facebookxmpp"
+
+/*
+http://www.facebook.com/connect/prompt_permissions.php?api_key=ff26b9e09239e33babaeaf747c778926&v=1.0&next=http%3A%2F%2Fwww.facebook.com%2Fconnect%2Flogin_success.html&cancel=http%3A%2F%2Fwww.facebook.com%2Fconnect%2Flogin_failure.html&ext_perm=xmpp_login%2Cread_stream%2Cpublish_stream%2Cread_mailbox%2Coffline_access&channel_url=&display=page&canvas=0&return_session=1&source=login&fbconnect=1&offline_access=0&required=1
+charset_test	,,,,?,?,?
+fb_dtsg	1Oi8s
+post_form_id	7c5917b2dfc9c709d03c10e0d45b631b
+ext_perm	64,16384,32768,524288,32
+perms_granted	{"32":["800753867"],"64":["800753867"],"16384":["800753867"],"32768":["800753867"],"524288":["800753867"]}
+session_version	
+data_perms_user	0
+data_perms_friends	0
+
+Location	http://www.facebook.com/connect/login_success.html?session=%7B%22session_key%22%3A%22f665d3b753064a328f8c0372-800753867%22%2C%22uid%22%3A800753867%2C%22expires%22%3A0%2C%22secret%22%3A%225b07b330e4d9754b8476927830b462e8%22%2C%22sig%22%3A%22573dd1e21d1f8f22450cba4ea060f3fb%22%7D
+*/
+
+
+
+static void fb_cookie_foreach_cb(gchar *cookie_name,
+								 gchar *cookie_value, GString *str)
+{
+	/* TODO: Need to escape name and value? */
+	g_string_append_printf(str, "%s=%s;", cookie_name, cookie_value);
+}
+
+/**
+ * Serialize the fba->cookie_table hash table to a string.
+ */
+static gchar *fb_cookies_to_string(FacebookAccount *fba)
+{
+	GString *str;
+	
+	str = g_string_new(NULL);
+	
+	g_hash_table_foreach(fba->cookie_table,
+						 (GHFunc)fb_cookie_foreach_cb, str);
+	
+	return g_string_free(str, FALSE);
+}
+
+void fb_authorise_app_cb(FacebookAccount *fba, const gchar *response, gsize len,
+						 gpointer userdata)
+{
+	// session_key is stored in cookies somehow
+	if (len && g_str_equal(response, "Success"))
+	{
+		purple_debug_info("facebookxmpp", "Autorised app cookies: %s", fb_cookies_to_string(fba));
+	}
+}
+
+void fb_authorise_app(FacebookAccount *fba)
+{
+	gchar *postdata;
+	gchar *url;
+	gchar *encoded_charset_test;
+	
+	url = g_strdup_printf("/connect/prompt_permissions.php?api_key=" FACEBOOK_API_KEY "&v=1.0&"
+						  "next=http%%3A%%2F%%2Fwww.facebook.com%%2Fconnect%%2Flogin_success.html&"
+						  "cancel=http%%3A%%2F%%2Fwww.facebook.com%%2Fconnect%%2Flogin_failure.html&"
+						  "ext_perm=xmpp_login%%2Cread_stream%%2Cpublish_stream%%2Cread_mailbox%%2Coffline_access&"
+						  "channel_url=&display=page&canvas=0&return_session=1&source=login&"
+						  "fbconnect=1&offline_access=0&required=1");
+	
+	
+	encoded_charset_test = g_strdup(purple_url_encode(",,,,,,"));
+	postdata = g_strdup_printf("charset_test=%s&fb_dtsg=%s&post_form_id=%s&"
+							   "ext_perm=64,16384,32768,524288,32&"
+							   "perms_granted={\"32\":[\"%" G_GINT64_FORMAT "\"],\"64\":[\"%" G_GINT64_FORMAT "\"],\"16384\":[\"%" G_GINT64_FORMAT "\"],\"32768\":[\"%" G_GINT64_FORMAT "\"],\"524288\":[\"%" G_GINT64_FORMAT "\"]}&"
+							   "session_version=&data_perms_user=0&data_perms_friends=0",
+							   encoded_charset_test, (fba->dtsg?fba->dtsg:"(null)"),
+							   (fba->post_form_id?fba->post_form_id:"(null)"),
+							   fba->uid, fba->uid, fba->uid, fba->uid, fba->uid);
+	fb_post_or_get(fba, FB_METHOD_POST, NULL, url, postdata, fb_authorise_app_cb, NULL, FALSE);
+	
+	g_free(url);
+	g_free(postdata);
+	g_free(encoded_charset_test);
+}
+
+gboolean api_request_traverse_func(gchar *key, gchar *value, GString *ret)
+{
+	ret = g_string_append(ret, purple_url_encode(key));
+	ret = g_string_append_c(ret, '=');
+	ret = g_string_append(ret, purple_url_encode(value));
+	ret = g_string_append_c(ret, '&');
+	return FALSE;
+}
+
+static gchar *prepare_api_request(GTree *request_vars, const gchar *method, const gchar *secret)
+{
+	gchar *ret, *sig, *temp;
+	GString *retstring = g_string_new("");
+	
+	g_tree_replace(request_vars, "api_key", g_strdup(FACEBOOK_API_KEY));
+	g_tree_replace(request_vars, "call_id", g_strdup_printf("%d", (int) time(NULL)));
+	if (method)
+	{
+		g_tree_replace(request_vars, "method", g_strdup(method));
+	}
+	g_tree_replace(request_vars, "v", g_strdup("1.0"));
+	g_tree_foreach(request_vars, (GTraverseFunc)api_request_traverse_func, ret);
+	ret = g_string_free(retstring, FALSE);
+	
+	// Compute the 'sig' value
+	sig = g_strdup(ret);
+	purple_str_strip_char(sig, '&');
+	temp = g_strconcat(purple_url_decode(sig), secret, NULL);
+	g_free(sig);
+	sig = fb_md5_encode(temp);
+	g_free(temp);
+	
+	temp = g_strconcat(ret, "sig=", sig, NULL);
+	g_free(ret);
+	g_free(sig);
+	
+	return temp;
+}
+
+void fb_fbconnect_request(FacebookAccount *fba, char *fb_method,
+		GTree *request_vars,
+		FacebookProxyCallbackFunc callback_func, gpointer user_data,
+		gboolean keepalive)
+{
+	gchar *postdata;
+	
+	postdata = prepare_api_request(request_vars, fb_method, 
+								   purple_account_get_string(fba->account, "session_key", ""));
+	
+	fb_post_or_get(fba, FB_METHOD_POST,
+		"api.facebook.com", "/restserver.php", postdata,
+		callback_func, user_data, keepalive);
+	
+	g_free(postdata);
+}
+
+static void handle_jabber_receiving_xmlnode_signal(PurpleConnection *gc, xmlnode **packet, gpointer userdata) 
+{
+	JabberStream *js = userdata;
+	xmlnode *mechnode;
+	
+	if(xmlnode_get_child(*packet, "mechanisms"))
+	{
+		//hack the JabberStream to only use our mech
+		mechnode = xmlnode_get_child(*packet, "mechanisms");
+		xmlnode_insert_data(mechnode, "X-FACEBOOK-PLATFORM", -1);
+		js->auth_mech = facebook_mech;
+	}
+}
+				   
+static void fb_jabber_http_login_cb(FacebookAccount *fba, const gchar *response, gsize len,
+										   gpointer userdata)
+{
+	gchar *user_cookie;
+	
+	purple_connection_update_progress(fba->pc, _("Authenticating"), 2, 3);
+	
+	/* Look for our uid */
+	user_cookie = g_hash_table_lookup(fba->cookie_table, "c_user");
+	if (user_cookie == NULL) 
+	{
+		/*
+		 * Server didn't set the c_user cookie, so we must have given
+		 * them a bad username or password
+		 */
+		purple_connection_error_reason(fba->pc,
+									   PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED,
+									   _("Incorrect username or password."));
+		return;
+	}
+	fba->uid = atoll(user_cookie);
+	purple_debug_info("facebook", "uid %" G_GINT64_FORMAT "\n", fba->uid);
+
+	fb_get_post_form_id(fba, fb_authorise_app);
+}
+				   
+static void fb_jabber_login(PurpleAccount *account)
+{
+	FacebookAccount *fba;
+	PurpleConnection *pc = purple_account_get_connection(account);
+	JabberStream *js;
+	PurpleStoredImage *image;
+	const gchar *old_username;
+	gchar *new_username;
+
+	purple_account_set_bool(account, "require_tls", FALSE);
+	purple_account_set_bool(account, "old_ssl", FALSE);
+	purple_account_set_bool(account, "auth_plain_in_clear", TRUE);
+	purple_account_set_int(account, "port", 5222);
+	purple_account_set_string(account, "connect_server", "chat.facebook.com");
+	purple_account_set_string(account, "ft_proxies", "");
+	purple_account_set_bool(account, "custom_smileys", FALSE);
+
+	/* Hack the username so that it's a valid XMPP username */
+	old_username = account->username;
+	new_username = g_strconcat(purple_url_encode(old_username), "@", "chat.facebook.com", "/", "Pidgin", NULL);
+	account->username = new_username;
+	js = jabber_stream_new(account);
+	account->username = old_username;
+	g_free(new_username);
+	
+	if (js == NULL)
+		return;
+	
+	fba = g_new0(FacebookAccount, 1);
+	fba->account = account;
+	fba->pc = pc;
+	fba->uid = -1;
+	
+	purple_connection_set_state(pc, PURPLE_CONNECTING);
+	purple_connection_update_progress(pc, _("Connecting"), 1, 3);
+	
+	//we want to hook into the "jabber-receiving-xmlnode" signal to be able to listen to our connect event
+	purple_signal_connect(pc, "jabber-receiving-xmlnode", js,
+						  PURPLE_CALLBACK(handle_jabber_receiving_xmlnode_signal), js);
+	
+	
+	/* Have we authorised access to Facebook on this account? */
+	if (purple_account_get_string(account, "session_key", NULL) == NULL)
+	{
+		fb_do_http_login(fba, fb_jabber_http_login_cb, js);
+		/* Need to wait for the logins to happen before connecting to jabber */
+		return;
+	}
+	
+	jabber_stream_connect(js);
+}
+
+static void fb_jabber_close(PurpleConnection *pc)
+{
+	purple_signals_unregister_by_instance(pc);
+	fb_close(pc);
+	jabber_close(pc);
+}
+
+static PurplePluginProtocolInfo prpl_info =
+{
+	OPT_PROTO_CHAT_TOPIC | OPT_PROTO_UNIQUE_CHATNAME | OPT_PROTO_MAIL_CHECK |
+	OPT_PROTO_PASSWORD_OPTIONAL |
+	OPT_PROTO_SLASH_COMMANDS_NATIVE,
+	NULL,							/* user_splits */
+	NULL,							/* protocol_options */
+	{"png", 32, 32, 96, 96, 0, PURPLE_ICON_SCALE_SEND | PURPLE_ICON_SCALE_DISPLAY}, /* icon_spec */
+	fb_list_icon,				/* list_icon */
+	NULL,			/* list_emblems */
+	fb_status_text,				/* status_text */
+	fb_tooltip_text,			/* tooltip_text */
+	jabber_status_types,			/* status_types */
+	jabber_blist_node_menu,			/* blist_node_menu */
+	NULL,				/* chat_info */
+	NULL,		/* chat_info_defaults */
+	fb_jabber_login,					/* login */
+	fb_jabber_close,					/* close */
+	jabber_message_send_im,			/* send_im */
+	NULL,				/* set_info */
+	jabber_send_typing,				/* send_typing */
+	jabber_buddy_get_info,			/* get_info */
+	fb_set_status_p,				/* set_status */
+	jabber_idle_set,				/* set_idle */
+	NULL,							/* change_passwd */
+	fb_add_buddy,		/* add_buddy */
+	NULL,							/* add_buddies */
+	fb_remove_buddy,		/* remove_buddy */
+	NULL,							/* remove_buddies */
+	NULL,							/* add_permit */
+	NULL,				/* add_deny */
+	NULL,							/* rem_permit */
+	NULL,				/* rem_deny */
+	NULL,							/* set_permit_deny */
+	NULL,				/* join_chat */
+	NULL,							/* reject_chat */
+	NULL,			/* get_chat_name */
+	NULL,				/* chat_invite */
+	NULL,				/* chat_leave */
+	NULL,							/* chat_whisper */
+	NULL,		/* chat_send */
+	jabber_keepalive,				/* keepalive */
+	NULL,		/* register_user */
+	NULL,							/* get_cb_info */
+	NULL,							/* get_cb_away */
+	jabber_roster_alias_change,		/* alias_buddy */
+	fb_group_buddy_move,		/* group_buddy */
+	fb_group_rename,		/* rename_group */
+	fb_buddy_free,							/* buddy_free */
+	jabber_convo_closed,			/* convo_closed */
+	jabber_normalize,				/* normalize */
+	NULL,			/* set_buddy_icon */
+	fb_group_remove,							/* remove_group */
+	NULL,	/* get_cb_real_name */
+	NULL,			/* set_chat_topic */
+	NULL,			/* find_blist_chat */
+	NULL,		/* roomlist_get_list */
+	NULL,			/* roomlist_cancel */
+	NULL,							/* roomlist_expand_category */
+	NULL,		/* can_receive_file */
+	NULL,			/* send_file */
+	NULL,				/* new_xfer */
+	NULL,			/* offline_message */
+	NULL,							/* whiteboard_prpl_ops */
+	jabber_prpl_send_raw,			/* send_raw */
+	NULL, /* roomlist_room_serialize */
+	NULL,		/* unregister_user */
+	NULL,			/* send_attention */
+	NULL,			/* attention_types */
+#if PURPLE_MAJOR_VERSION > 2 || PURPLE_MAJOR_VERSION >= 2 && PURPLE_MINOR_VERSION >= 5
+	sizeof(PurplePluginProtocolInfo),       /* struct_size */
+	fb_get_account_text_table, /* get_account_text_table */
+	NULL,          /* initiate_media */
+	NULL,                  /* get_media_caps */
+#else
+	(gpointer) sizeof(PurplePluginProtocolInfo)
+#endif
+};
+
+static gboolean load_plugin(PurplePlugin *plugin)
+{
+	purple_signal_register(plugin, "jabber-receiving-xmlnode",
+			purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new_outgoing(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	purple_signal_register(plugin, "jabber-sending-xmlnode",
+			purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new_outgoing(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	/*
+	 * Do not remove this or the plugin will fail. Completely. You have been
+	 * warned!
+	 */
+	purple_signal_connect_priority(plugin, "jabber-sending-xmlnode",
+			plugin, PURPLE_CALLBACK(jabber_send_signal_cb),
+			NULL, PURPLE_SIGNAL_PRIORITY_HIGHEST);
+
+	purple_signal_register(plugin, "jabber-sending-text",
+			     purple_marshal_VOID__POINTER_POINTER, NULL, 2,
+			     purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			     purple_value_new_outgoing(PURPLE_TYPE_STRING));
+
+	purple_signal_register(plugin, "jabber-receiving-message",
+			purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER_POINTER,
+			purple_value_new(PURPLE_TYPE_BOOLEAN), 6,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new(PURPLE_TYPE_STRING), /* type */
+			purple_value_new(PURPLE_TYPE_STRING), /* id */
+			purple_value_new(PURPLE_TYPE_STRING), /* from */
+			purple_value_new(PURPLE_TYPE_STRING), /* to */
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	purple_signal_register(plugin, "jabber-receiving-iq",
+			purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER,
+			purple_value_new(PURPLE_TYPE_BOOLEAN), 5,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new(PURPLE_TYPE_STRING), /* type */
+			purple_value_new(PURPLE_TYPE_STRING), /* id */
+			purple_value_new(PURPLE_TYPE_STRING), /* from */
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	purple_signal_register(plugin, "jabber-watched-iq",
+			purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER_POINTER,
+			purple_value_new(PURPLE_TYPE_BOOLEAN), 5,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new(PURPLE_TYPE_STRING), /* type */
+			purple_value_new(PURPLE_TYPE_STRING), /* id */
+			purple_value_new(PURPLE_TYPE_STRING), /* from */
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE)); /* child */
+
+	/* Modifying these? Look at jabber_init_plugin for the ipc versions */
+	purple_signal_register(plugin, "jabber-register-namespace-watcher",
+			purple_marshal_VOID__POINTER_POINTER,
+			NULL, 2,
+			purple_value_new(PURPLE_TYPE_STRING),  /* node */
+			purple_value_new(PURPLE_TYPE_STRING)); /* namespace */
+
+	purple_signal_register(plugin, "jabber-unregister-namespace-watcher",
+			purple_marshal_VOID__POINTER_POINTER,
+			NULL, 2,
+			purple_value_new(PURPLE_TYPE_STRING),  /* node */
+			purple_value_new(PURPLE_TYPE_STRING)); /* namespace */
+
+	purple_signal_connect(plugin, "jabber-register-namespace-watcher",
+			plugin, PURPLE_CALLBACK(jabber_iq_signal_register), NULL);
+	purple_signal_connect(plugin, "jabber-unregister-namespace-watcher",
+			plugin, PURPLE_CALLBACK(jabber_iq_signal_unregister), NULL);
+
+	purple_signal_register(plugin, "jabber-receiving-presence",
+			purple_marshal_BOOLEAN__POINTER_POINTER_POINTER_POINTER,
+			purple_value_new(PURPLE_TYPE_BOOLEAN), 4,
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_CONNECTION),
+			purple_value_new(PURPLE_TYPE_STRING), /* type */
+			purple_value_new(PURPLE_TYPE_STRING), /* from */
+			purple_value_new(PURPLE_TYPE_SUBTYPE, PURPLE_SUBTYPE_XMLNODE));
+
+	return TRUE;
+}
+
+static gboolean unload_plugin(PurplePlugin *plugin)
+{
+	purple_signals_unregister_by_instance(plugin);
+
+	/* reverse order of init_plugin */
+	jabber_data_uninit();
+	jabber_si_uninit();
+	jabber_ibb_uninit();
+	/* PEP things should be uninit via jabber_pep_uninit, not here */
+	jabber_pep_uninit();
+	jabber_caps_uninit();
+	jabber_iq_uninit();
+
+	jabber_unregister_commands();
+
+	/* Stay on target...stay on target... Almost there... */
+	jabber_uninit_plugin(plugin);
+
+	return TRUE;
+}
+
+static PurplePluginInfo info =
+{
+	PURPLE_PLUGIN_MAGIC,
+	2,
+	3,
+	PURPLE_PLUGIN_PROTOCOL,                             /**< type           */
+	NULL,                                             /**< ui_requirement */
+	0,                                                /**< flags          */
+	NULL,                                             /**< dependencies   */
+	PURPLE_PRIORITY_DEFAULT,                            /**< priority       */
+
+	FACEBOOK_XMPP_PLUGIN_ID,                                    /**< id             */
+	"Facebook (XMPP)", 					/* name */
+	FACEBOOK_PLUGIN_VERSION, 			/* version */
+	N_("Facebook Protocol Plugin"), 		/* summary */
+	N_("Facebook Protocol Plugin"), 		/* description */
+	"Eion Robb <eionrobb@gmail.com>", 		/* author */
+	"http://pidgin-facebookchat.googlecode.com/",	/* homepage */
+
+	load_plugin,                                      /**< load           */
+	unload_plugin,                                    /**< unload         */
+	NULL,                                             /**< destroy        */
+
+	NULL,                                             /**< ui_info        */
+	&prpl_info,                                       /**< extra_info     */
+	NULL,                                             /**< prefs_info     */
+	fb_actions,
+
+	/* padding */
+	NULL,
+	NULL,
+	NULL,
+	NULL
+};
+
+
+static JabberSaslState
+fb_facebook_mech_start(JabberStream *js, xmlnode *packet, xmlnode **response,
+                 char **error)
+{
+	xmlnode *auth = xmlnode_new("auth");
+	xmlnode_set_namespace(auth, NS_XMPP_SASL);
+	xmlnode_set_attrib(auth, "mechanism", "X-FACEBOOK-PLATFORM");
+
+	*response = auth;
+	return JABBER_SASL_STATE_CONTINUE;
+}
+
+/* Parts of this algorithm are inspired by stuff in libgsasl */
+static GHashTable* parse_challenge(const char *challenge)
+{
+	GHashTable *ret = g_hash_table_new_full(g_str_hash, g_str_equal,
+			g_free, g_free);
+	
+	return ret;
+}
+
+static JabberSaslState
+fb_facebook_handle_challenge(JabberStream *js, xmlnode *packet,
+                            xmlnode **response, char **msg)
+{
+	xmlnode *reply = NULL;
+	char *enc_in = xmlnode_get_data(packet);
+	char *dec_in;
+	char *enc_out;
+	GHashTable *parts;
+	JabberSaslState state = JABBER_SASL_STATE_CONTINUE;
+	GTree *response_tree;
+	FacebookAccount *fba;
+
+	if (!enc_in) {
+		*msg = g_strdup(_("Invalid response from server"));
+		return JABBER_SASL_STATE_FAIL;
+	}
+
+	dec_in = (char *)purple_base64_decode(enc_in, NULL);
+	purple_debug_misc("jabber", "decoded challenge (%"
+			G_GSIZE_FORMAT "): %s\n", strlen(dec_in), dec_in);
+			
+	parts = parse_challenge(dec_in);
+	
+	response_tree = g_tree_new_full((GCompareDataFunc)strcmp, NULL, NULL, g_free);
+	g_tree_insert(response_tree, "nonce", g_strdup(g_hash_table_lookup(parts, "nonce")));
+	g_tree_insert(response_tree, "session_key", g_strdup(purple_account_get_string(js->account, "session_key", "")));
+	
+	//method, api_key, call_id, sig, v already sent
+	prepare_api_request(response_tree, g_hash_table_lookup(parts, "method"), FACEBOOK_SECRET);
+	
+	g_hash_table_destroy(parts);
+}
+
+static JabberSaslMech facebook_mech = {
+	20, /* priority - needs to be more important than the DIGEST-MD5 priority */
+	"X-FACEBOOK-PLATFORM", /* name */
+	fb_facebook_mech_start,
+	fb_facebook_handle_challenge, /* handle_challenge */
+	NULL, /* handle_success */
+	NULL, /* handle_failure */
+	NULL  /* dispose */
+};
+
+JabberSaslMech *fb_auth_get_facebook_mech(void)
+{
+	return &facebook_mech;
+}
+
+static void
+init_plugin(PurplePlugin *plugin)
+{
+	
+	auth_mechs = g_slist_insert_sorted(auth_mechs, fb_auth_get_facebook_mech(), compare_mech);
+
+
+	my_protocol = plugin;
+	jabber_init_plugin(plugin);
+
+	purple_prefs_remove("/plugins/prpl/facebook");
+	jabber_register_commands();
+
+	/* reverse order of unload_plugin */
+	jabber_iq_init();
+	jabber_caps_init();
+	/* PEP things should be init via jabber_pep_init, not here */
+	jabber_pep_init();
+	jabber_data_init();
+
+	jabber_si_init();
+}
+
+
+PURPLE_INIT_PLUGIN(facebookxmpp, init_plugin, info);
Binary files pidgin-2.7.7/libpurple/protocols/facebook/libjson-glib-1.0.dll and pidgin-2.7.7-new//libpurple/protocols/facebook/libjson-glib-1.0.dll differ
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/login.facebook.com.pem pidgin-2.7.7-new//libpurple/protocols/facebook/login.facebook.com.pem
--- pidgin-2.7.7/libpurple/protocols/facebook/login.facebook.com.pem	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/login.facebook.com.pem	2011-03-27 09:15:30.720552999 -0600
@@ -0,0 +1,20 @@
+-----BEGIN CERTIFICATE-----
+MIIDUTCCArqgAwIBAgIDBRtMMA0GCSqGSIb3DQEBBAUAMFoxCzAJBgNVBAYTAlVT
+MRwwGgYDVQQKExNFcXVpZmF4IFNlY3VyZSBJbmMuMS0wKwYDVQQDEyRFcXVpZmF4
+IFNlY3VyZSBHbG9iYWwgZUJ1c2luZXNzIENBLTEwHhcNMDYxMjEzMDczMTQ5WhcN
+MTAwMTEyMDczMTQ5WjCBwDELMAkGA1UEBhMCVVMxGzAZBgNVBAoTEmxvZ2luLmZh
+Y2Vib29rLmNvbTETMBEGA1UECxMKR1QwNDQ4MjQ1MjExMC8GA1UECxMoU2VlIHd3
+dy5nZW90cnVzdC5jb20vcmVzb3VyY2VzL2NwcyAoYykwNjEvMC0GA1UECxMmRG9t
+YWluIENvbnRyb2wgVmFsaWRhdGVkIC0gUXVpY2tTU0woUikxGzAZBgNVBAMTEmxv
+Z2luLmZhY2Vib29rLmNvbTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1R9N
+IM5CJpFurag3pBa3ZOahUvLgh9sGa2Ur0MT3+5tWJYw5ay2r74WK6dYv2bcrqDLU
+uyHWJWCeJewglGs2VZ3cOPxN9x68OPxuTP0IPpAJDpphFne3zTH5njkfitrV2oaW
+UgzbkbUEaFnVOpeScy9U4Ks6uVTgV+KNsZFEsCkCAwEAAaOBvTCBujAOBgNVHQ8B
+Af8EBAMCBPAwHQYDVR0OBBYEFM627PadoUPV4GdpPT8AbJOxchf+MDsGA1UdHwQ0
+MDIwMKAuoCyGKmh0dHA6Ly9jcmwuZ2VvdHJ1c3QuY29tL2NybHMvZ2xvYmFsY2Ex
+LmNybDAfBgNVHSMEGDAWgBS+qKB0clBrRLfJI9j7qP+zV2tobDAdBgNVHSUEFjAU
+BggrBgEFBQcDAQYIKwYBBQUHAwIwDAYDVR0TAQH/BAIwADANBgkqhkiG9w0BAQQF
+AAOBgQBRlplWgG9NU89FVKCDkUNCoTqkdPJw4Nl7Ypdpf6WhPk3dq57teOseTKCf
+O3XxHLqz+EYslUO4K5l88RgF+dK+dlESmjmewAtADpkrSC4DHKg6fdFywObnD9b9
+TqibCw82YJ3b7v6G3Ec4ApD0sqiQqrz59pWjdFrZwagyT42YFw==
+-----END CERTIFICATE-----
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/Makefile.am pidgin-2.7.7-new//libpurple/protocols/facebook/Makefile.am
--- pidgin-2.7.7/libpurple/protocols/facebook/Makefile.am	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/Makefile.am	2011-03-27 09:15:30.700553000 -0600
@@ -0,0 +1,56 @@
+pkgdir = $(libdir)/purple-$(PURPLE_MAJOR_VERSION)
+
+FACEBOOKSOURCES = \
+fb_blist.c \
+fb_blist.h \
+fb_chat.c \
+fb_chat.h \
+fb_connection.c \
+fb_connection.h \
+fb_conversation.c \
+fb_conversation.h \
+fb_friendlist.c \
+fb_friendlist.h \
+fb_info.c \
+fb_info.h \
+fb_json.c \
+fb_json.h \
+fb_managefriends.c \
+fb_managefriends.h \
+fb_messages.c \
+fb_messages.h \
+fb_notifications.c \
+fb_notifications.h \
+fb_search.c \
+fb_search.h \
+fb_util.c \
+fb_util.h \
+libfacebook.c \
+libfacebook.h \
+libfbxmpp.c 
+
+AM_CFLAGS = $(st)
+
+libmsn_la_LDFLAGS = -module -avoid-version
+
+if STATIC_FACEBOOK
+
+st = -DPURPLE_STATIC_PRPL
+noinst_LTLIBRARIES = libfacebookchat.la
+libmsn_la_SOURCES  = $(FACEBOOKSOURCES)
+libmsn_la_CFLAGS   = $(AM_CFLAGS)
+
+else
+
+st =
+pkg_LTLIBRARIES   = libfacebookchat.la
+libmsn_la_SOURCES = $(FACEBOOKSOURCES)
+libmsn_la_LIBADD  = $(GLIB_LIBS)
+
+endif
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/libpurple \
+	-I$(top_builddir)/libpurple \
+	$(GLIB_CFLAGS) \
+	$(DEBUG_CFLAGS)
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/Makefile.in pidgin-2.7.7-new//libpurple/protocols/facebook/Makefile.in
--- pidgin-2.7.7/libpurple/protocols/facebook/Makefile.in	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/Makefile.in	2011-03-27 09:15:30.828553000 -0600
@@ -0,0 +1,1088 @@
+# Makefile.in generated by automake 1.11.1 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
+# 2003, 2004, 2005, 2006, 2007, 2008, 2009  Free Software Foundation,
+# Inc.
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+VPATH = @srcdir@
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+subdir = libpurple/protocols/msn
+DIST_COMMON = $(srcdir)/Makefile.am $(srcdir)/Makefile.in
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+mkinstalldirs = $(SHELL) $(top_srcdir)/mkinstalldirs
+CONFIG_HEADER = $(top_builddir)/config.h
+CONFIG_CLEAN_FILES =
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__installdirs = "$(DESTDIR)$(pkgdir)"
+LTLIBRARIES = $(noinst_LTLIBRARIES) $(pkg_LTLIBRARIES)
+am__DEPENDENCIES_1 =
+@STATIC_MSN_FALSE@libmsn_la_DEPENDENCIES = $(am__DEPENDENCIES_1)
+am__libmsn_la_SOURCES_DIST = cmdproc.c cmdproc.h command.c command.h \
+	contact.c contact.h directconn.c directconn.h error.c error.h \
+	group.c group.h history.c history.h httpconn.c httpconn.h \
+	msg.c msg.h msn.c msn.h nexus.c nexus.h notification.c \
+	notification.h object.c object.h oim.c oim.h p2p.c p2p.h \
+	page.c page.h servconn.c servconn.h session.c session.h slp.c \
+	slp.h slpcall.c slpcall.h slplink.c slplink.h slpmsg.c \
+	slpmsg.h slpmsg_part.c slpmsg_part.h soap.c soap.h state.c \
+	state.h sbconn.c sbconn.h switchboard.c switchboard.h table.c \
+	table.h transaction.c transaction.h user.c user.h userlist.c \
+	userlist.h xfer.c xfer.h msnutils.c msnutils.h
+am__objects_1 = libmsn_la-cmdproc.lo libmsn_la-command.lo \
+	libmsn_la-contact.lo libmsn_la-directconn.lo \
+	libmsn_la-error.lo libmsn_la-group.lo libmsn_la-history.lo \
+	libmsn_la-httpconn.lo libmsn_la-msg.lo libmsn_la-msn.lo \
+	libmsn_la-nexus.lo libmsn_la-notification.lo \
+	libmsn_la-object.lo libmsn_la-oim.lo libmsn_la-p2p.lo \
+	libmsn_la-page.lo libmsn_la-servconn.lo libmsn_la-session.lo \
+	libmsn_la-slp.lo libmsn_la-slpcall.lo libmsn_la-slplink.lo \
+	libmsn_la-slpmsg.lo libmsn_la-slpmsg_part.lo libmsn_la-soap.lo \
+	libmsn_la-state.lo libmsn_la-sbconn.lo \
+	libmsn_la-switchboard.lo libmsn_la-table.lo \
+	libmsn_la-transaction.lo libmsn_la-user.lo \
+	libmsn_la-userlist.lo libmsn_la-xfer.lo libmsn_la-msnutils.lo
+@STATIC_MSN_FALSE@am_libmsn_la_OBJECTS = $(am__objects_1)
+@STATIC_MSN_TRUE@am_libmsn_la_OBJECTS = $(am__objects_1)
+libmsn_la_OBJECTS = $(am_libmsn_la_OBJECTS)
+AM_V_lt = $(am__v_lt_$(V))
+am__v_lt_ = $(am__v_lt_$(AM_DEFAULT_VERBOSITY))
+am__v_lt_0 = --silent
+libmsn_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(libmsn_la_CFLAGS) \
+	$(CFLAGS) $(libmsn_la_LDFLAGS) $(LDFLAGS) -o $@
+@STATIC_MSN_FALSE@am_libmsn_la_rpath = -rpath $(pkgdir)
+@STATIC_MSN_TRUE@am_libmsn_la_rpath =
+DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__depfiles_maybe = depfiles
+am__mv = mv -f
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_$(V))
+am__v_CC_ = $(am__v_CC_$(AM_DEFAULT_VERBOSITY))
+am__v_CC_0 = @echo "  CC    " $@;
+AM_V_at = $(am__v_at_$(V))
+am__v_at_ = $(am__v_at_$(AM_DEFAULT_VERBOSITY))
+am__v_at_0 = @
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_$(V))
+am__v_CCLD_ = $(am__v_CCLD_$(AM_DEFAULT_VERBOSITY))
+am__v_CCLD_0 = @echo "  CCLD  " $@;
+AM_V_GEN = $(am__v_GEN_$(V))
+am__v_GEN_ = $(am__v_GEN_$(AM_DEFAULT_VERBOSITY))
+am__v_GEN_0 = @echo "  GEN   " $@;
+SOURCES = $(libmsn_la_SOURCES)
+DIST_SOURCES = $(am__libmsn_la_SOURCES_DIST)
+ETAGS = etags
+CTAGS = ctags
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
+ALL_LINGUAS = @ALL_LINGUAS@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AVAHI_CFLAGS = @AVAHI_CFLAGS@
+AVAHI_LIBS = @AVAHI_LIBS@
+AWK = @AWK@
+CATALOGS = @CATALOGS@
+CATOBJEXT = @CATOBJEXT@
+CC = @CC@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CHECK_CFLAGS = @CHECK_CFLAGS@
+CHECK_LIBS = @CHECK_LIBS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DATADIRNAME = @DATADIRNAME@
+DBUS_CFLAGS = @DBUS_CFLAGS@
+DBUS_LIBS = @DBUS_LIBS@
+DBUS_SERVICES_DIR = @DBUS_SERVICES_DIR@
+DEBUG_CFLAGS = @DEBUG_CFLAGS@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DOT = @DOT@
+DOXYGEN = @DOXYGEN@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+DYNALOADER_A = @DYNALOADER_A@
+DYNAMIC_PRPLS = @DYNAMIC_PRPLS@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EVOLUTION_ADDRESSBOOK_CFLAGS = @EVOLUTION_ADDRESSBOOK_CFLAGS@
+EVOLUTION_ADDRESSBOOK_LIBS = @EVOLUTION_ADDRESSBOOK_LIBS@
+EXEEXT = @EXEEXT@
+FARSIGHT_CFLAGS = @FARSIGHT_CFLAGS@
+FARSIGHT_LIBS = @FARSIGHT_LIBS@
+FGREP = @FGREP@
+GADU_CFLAGS = @GADU_CFLAGS@
+GADU_LIBS = @GADU_LIBS@
+GCONFTOOL = @GCONFTOOL@
+GCONF_SCHEMA_CONFIG_SOURCE = @GCONF_SCHEMA_CONFIG_SOURCE@
+GCONF_SCHEMA_FILE_DIR = @GCONF_SCHEMA_FILE_DIR@
+GETTEXT_PACKAGE = @GETTEXT_PACKAGE@
+GLIB_CFLAGS = @GLIB_CFLAGS@
+GLIB_GENMARSHAL = @GLIB_GENMARSHAL@
+GLIB_LIBS = @GLIB_LIBS@
+GMOFILES = @GMOFILES@
+GMSGFMT = @GMSGFMT@
+GNT_CFLAGS = @GNT_CFLAGS@
+GNT_LIBS = @GNT_LIBS@
+GNT_LT_VERSION_INFO = @GNT_LT_VERSION_INFO@
+GNT_MAJOR_VERSION = @GNT_MAJOR_VERSION@
+GNT_MICRO_VERSION = @GNT_MICRO_VERSION@
+GNT_MINOR_VERSION = @GNT_MINOR_VERSION@
+GNT_VERSION = @GNT_VERSION@
+GNUTLS_CFLAGS = @GNUTLS_CFLAGS@
+GNUTLS_LIBS = @GNUTLS_LIBS@
+GREP = @GREP@
+GSTINTERFACES_CFLAGS = @GSTINTERFACES_CFLAGS@
+GSTINTERFACES_LIBS = @GSTINTERFACES_LIBS@
+GSTREAMER_CFLAGS = @GSTREAMER_CFLAGS@
+GSTREAMER_LIBS = @GSTREAMER_LIBS@
+GTKSPELL_CFLAGS = @GTKSPELL_CFLAGS@
+GTKSPELL_LIBS = @GTKSPELL_LIBS@
+GTK_CFLAGS = @GTK_CFLAGS@
+GTK_LIBS = @GTK_LIBS@
+IDN_CFLAGS = @IDN_CFLAGS@
+IDN_LIBS = @IDN_LIBS@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+INSTOBJEXT = @INSTOBJEXT@
+INTLLIBS = @INTLLIBS@
+INTLTOOL_EXTRACT = @INTLTOOL_EXTRACT@
+INTLTOOL_MERGE = @INTLTOOL_MERGE@
+INTLTOOL_PERL = @INTLTOOL_PERL@
+INTLTOOL_UPDATE = @INTLTOOL_UPDATE@
+KRB4_CFLAGS = @KRB4_CFLAGS@
+KRB4_LDFLAGS = @KRB4_LDFLAGS@
+KRB4_LIBS = @KRB4_LIBS@
+LD = @LD@
+LDADD = @LDADD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBPERL_A = @LIBPERL_A@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIBXML_CFLAGS = @LIBXML_CFLAGS@
+LIBXML_LIBS = @LIBXML_LIBS@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+MAKEINFO = @MAKEINFO@
+MEANWHILE_CFLAGS = @MEANWHILE_CFLAGS@
+MEANWHILE_LIBS = @MEANWHILE_LIBS@
+MKDIR_P = @MKDIR_P@
+MKINSTALLDIRS = @MKINSTALLDIRS@
+MONO_CFLAGS = @MONO_CFLAGS@
+MONO_LIBS = @MONO_LIBS@
+MSGFMT = @MSGFMT@
+MSGFMT_OPTS = @MSGFMT_OPTS@
+MSGMERGE = @MSGMERGE@
+NETWORKMANAGER_CFLAGS = @NETWORKMANAGER_CFLAGS@
+NETWORKMANAGER_LIBS = @NETWORKMANAGER_LIBS@
+NM = @NM@
+NMEDIT = @NMEDIT@
+NSS_CFLAGS = @NSS_CFLAGS@
+NSS_LIBS = @NSS_LIBS@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PANGO_CFLAGS = @PANGO_CFLAGS@
+PANGO_LIBS = @PANGO_LIBS@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PERL = @PERL@
+PERL_CFLAGS = @PERL_CFLAGS@
+PERL_LIBS = @PERL_LIBS@
+PKG_CONFIG = @PKG_CONFIG@
+PKG_CONFIG_LIBDIR = @PKG_CONFIG_LIBDIR@
+PKG_CONFIG_PATH = @PKG_CONFIG_PATH@
+PLUGINS_DEFINE = @PLUGINS_DEFINE@
+POFILES = @POFILES@
+POSUB = @POSUB@
+PO_IN_DATADIR_FALSE = @PO_IN_DATADIR_FALSE@
+PO_IN_DATADIR_TRUE = @PO_IN_DATADIR_TRUE@
+PURPLE_LT_VERSION_INFO = @PURPLE_LT_VERSION_INFO@
+PURPLE_MAJOR_VERSION = @PURPLE_MAJOR_VERSION@
+PURPLE_MICRO_VERSION = @PURPLE_MICRO_VERSION@
+PURPLE_MINOR_VERSION = @PURPLE_MINOR_VERSION@
+PURPLE_VERSION = @PURPLE_VERSION@
+PYTHON = @PYTHON@
+PY_CFLAGS = @PY_CFLAGS@
+PY_LIBS = @PY_LIBS@
+RANLIB = @RANLIB@
+SASL_LIBS = @SASL_LIBS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+SILC_CFLAGS = @SILC_CFLAGS@
+SILC_LIBS = @SILC_LIBS@
+SM_LIBS = @SM_LIBS@
+SQLITE3_CFLAGS = @SQLITE3_CFLAGS@
+SQLITE3_LIBS = @SQLITE3_LIBS@
+SSL_CERTIFICATES_DIR = @SSL_CERTIFICATES_DIR@
+STARTUP_NOTIFICATION_CFLAGS = @STARTUP_NOTIFICATION_CFLAGS@
+STARTUP_NOTIFICATION_LIBS = @STARTUP_NOTIFICATION_LIBS@
+STATIC_LINK_LIBS = @STATIC_LINK_LIBS@
+STATIC_PRPLS = @STATIC_PRPLS@
+STRIP = @STRIP@
+TCL_CFLAGS = @TCL_CFLAGS@
+TCL_LIBS = @TCL_LIBS@
+TK_LIBS = @TK_LIBS@
+USE_NLS = @USE_NLS@
+VERSION = @VERSION@
+X11_CFLAGS = @X11_CFLAGS@
+X11_LIBS = @X11_LIBS@
+XGETTEXT = @XGETTEXT@
+XMKMF = @XMKMF@
+XSLTPROC = @XSLTPROC@
+XSS_LIBS = @XSS_LIBS@
+X_CFLAGS = @X_CFLAGS@
+X_EXTRA_LIBS = @X_EXTRA_LIBS@
+X_LIBS = @X_LIBS@
+X_PRE_LIBS = @X_PRE_LIBS@
+ZEPHYR_CFLAGS = @ZEPHYR_CFLAGS@
+ZEPHYR_LDFLAGS = @ZEPHYR_LDFLAGS@
+ZEPHYR_LIBS = @ZEPHYR_LIBS@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+enable_dbus = @enable_dbus@
+enable_devhelp = @enable_devhelp@
+enable_dot = @enable_dot@
+enable_doxygen = @enable_doxygen@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+lt_ECHO = @lt_ECHO@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+perlpath = @perlpath@
+pidginpath = @pidginpath@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+sbindir = @sbindir@
+sedpath = @sedpath@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sysconfdir = @sysconfdir@
+target_alias = @target_alias@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+EXTRA_DIST = \
+	directconn.c \
+	directconn.h \
+	Makefile.mingw
+
+pkgdir = $(libdir)/purple-$(PURPLE_MAJOR_VERSION)
+MSNSOURCES = \
+	cmdproc.c \
+	cmdproc.h \
+	command.c \
+	command.h \
+	contact.c\
+	contact.h\
+	directconn.c \
+	directconn.h \
+	error.c \
+	error.h \
+	group.c \
+	group.h \
+	history.c \
+	history.h \
+	httpconn.c \
+	httpconn.h \
+	msg.c \
+	msg.h \
+	msn.c \
+	msn.h \
+	nexus.c \
+	nexus.h \
+	notification.c \
+	notification.h \
+	object.c \
+	object.h \
+	oim.c\
+	oim.h\
+	p2p.c \
+	p2p.h \
+	page.c \
+	page.h \
+	servconn.c \
+	servconn.h \
+	session.c \
+	session.h \
+	slp.c \
+	slp.h \
+	slpcall.c \
+	slpcall.h \
+	slplink.c \
+	slplink.h \
+	slpmsg.c \
+	slpmsg.h \
+	slpmsg_part.c \
+	slpmsg_part.h \
+	soap.c \
+	soap.h \
+	state.c \
+	state.h \
+	sbconn.c \
+	sbconn.h \
+	switchboard.c \
+	switchboard.h \
+	table.c \
+	table.h \
+	transaction.c \
+	transaction.h \
+	user.c \
+	user.h \
+	userlist.c \
+	userlist.h \
+	xfer.c \
+	xfer.h \
+	msnutils.c \
+	msnutils.h
+
+AM_CFLAGS = $(st)
+libmsn_la_LDFLAGS = -module -avoid-version
+@STATIC_MSN_FALSE@st = 
+@STATIC_MSN_TRUE@st = -DPURPLE_STATIC_PRPL
+@STATIC_MSN_TRUE@noinst_LTLIBRARIES = libmsn.la
+@STATIC_MSN_FALSE@libmsn_la_SOURCES = $(MSNSOURCES)
+@STATIC_MSN_TRUE@libmsn_la_SOURCES = $(MSNSOURCES)
+@STATIC_MSN_TRUE@libmsn_la_CFLAGS = $(AM_CFLAGS)
+@STATIC_MSN_FALSE@pkg_LTLIBRARIES = libmsn.la
+@STATIC_MSN_FALSE@libmsn_la_LIBADD = $(GLIB_LIBS)
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/libpurple \
+	-I$(top_builddir)/libpurple \
+	$(GLIB_CFLAGS) \
+	$(DEBUG_CFLAGS)
+
+all: all-am
+
+.SUFFIXES:
+.SUFFIXES: .c .lo .o .obj
+$(srcdir)/Makefile.in:  $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \
+	        && { if test -f $@; then exit 0; else break; fi; }; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --gnu libpurple/protocols/msn/Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --gnu libpurple/protocols/msn/Makefile
+.PRECIOUS: Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+
+$(top_srcdir)/configure:  $(am__configure_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(ACLOCAL_M4):  $(am__aclocal_m4_deps)
+	cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh
+$(am__aclocal_m4_deps):
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+install-pkgLTLIBRARIES: $(pkg_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	test -z "$(pkgdir)" || $(MKDIR_P) "$(DESTDIR)$(pkgdir)"
+	@list='$(pkg_LTLIBRARIES)'; test -n "$(pkgdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(pkgdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(pkgdir)"; \
+	}
+
+uninstall-pkgLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(pkg_LTLIBRARIES)'; test -n "$(pkgdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(pkgdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(pkgdir)/$$f"; \
+	done
+
+clean-pkgLTLIBRARIES:
+	-test -z "$(pkg_LTLIBRARIES)" || rm -f $(pkg_LTLIBRARIES)
+	@list='$(pkg_LTLIBRARIES)'; for p in $$list; do \
+	  dir="`echo $$p | sed -e 's|/[^/]*$$||'`"; \
+	  test "$$dir" != "$$p" || dir=.; \
+	  echo "rm -f \"$${dir}/so_locations\""; \
+	  rm -f "$${dir}/so_locations"; \
+	done
+libmsn.la: $(libmsn_la_OBJECTS) $(libmsn_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libmsn_la_LINK) $(am_libmsn_la_rpath) $(libmsn_la_OBJECTS) $(libmsn_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-cmdproc.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-command.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-contact.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-directconn.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-error.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-group.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-history.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-httpconn.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-msg.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-msn.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-msnutils.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-nexus.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-notification.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-object.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-oim.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-p2p.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-page.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-sbconn.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-servconn.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-session.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-slp.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-slpcall.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-slplink.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-slpmsg.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-slpmsg_part.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-soap.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-state.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-switchboard.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-table.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-transaction.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-user.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-userlist.Plo@am__quote@
+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libmsn_la-xfer.Plo@am__quote@
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(COMPILE) -c `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LTCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LTCOMPILE) -c -o $@ $<
+
+libmsn_la-cmdproc.lo: cmdproc.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-cmdproc.lo -MD -MP -MF $(DEPDIR)/libmsn_la-cmdproc.Tpo -c -o libmsn_la-cmdproc.lo `test -f 'cmdproc.c' || echo '$(srcdir)/'`cmdproc.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-cmdproc.Tpo $(DEPDIR)/libmsn_la-cmdproc.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='cmdproc.c' object='libmsn_la-cmdproc.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-cmdproc.lo `test -f 'cmdproc.c' || echo '$(srcdir)/'`cmdproc.c
+
+libmsn_la-command.lo: command.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-command.lo -MD -MP -MF $(DEPDIR)/libmsn_la-command.Tpo -c -o libmsn_la-command.lo `test -f 'command.c' || echo '$(srcdir)/'`command.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-command.Tpo $(DEPDIR)/libmsn_la-command.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='command.c' object='libmsn_la-command.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-command.lo `test -f 'command.c' || echo '$(srcdir)/'`command.c
+
+libmsn_la-contact.lo: contact.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-contact.lo -MD -MP -MF $(DEPDIR)/libmsn_la-contact.Tpo -c -o libmsn_la-contact.lo `test -f 'contact.c' || echo '$(srcdir)/'`contact.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-contact.Tpo $(DEPDIR)/libmsn_la-contact.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='contact.c' object='libmsn_la-contact.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-contact.lo `test -f 'contact.c' || echo '$(srcdir)/'`contact.c
+
+libmsn_la-directconn.lo: directconn.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-directconn.lo -MD -MP -MF $(DEPDIR)/libmsn_la-directconn.Tpo -c -o libmsn_la-directconn.lo `test -f 'directconn.c' || echo '$(srcdir)/'`directconn.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-directconn.Tpo $(DEPDIR)/libmsn_la-directconn.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='directconn.c' object='libmsn_la-directconn.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-directconn.lo `test -f 'directconn.c' || echo '$(srcdir)/'`directconn.c
+
+libmsn_la-error.lo: error.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-error.lo -MD -MP -MF $(DEPDIR)/libmsn_la-error.Tpo -c -o libmsn_la-error.lo `test -f 'error.c' || echo '$(srcdir)/'`error.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-error.Tpo $(DEPDIR)/libmsn_la-error.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='error.c' object='libmsn_la-error.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-error.lo `test -f 'error.c' || echo '$(srcdir)/'`error.c
+
+libmsn_la-group.lo: group.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-group.lo -MD -MP -MF $(DEPDIR)/libmsn_la-group.Tpo -c -o libmsn_la-group.lo `test -f 'group.c' || echo '$(srcdir)/'`group.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-group.Tpo $(DEPDIR)/libmsn_la-group.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='group.c' object='libmsn_la-group.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-group.lo `test -f 'group.c' || echo '$(srcdir)/'`group.c
+
+libmsn_la-history.lo: history.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-history.lo -MD -MP -MF $(DEPDIR)/libmsn_la-history.Tpo -c -o libmsn_la-history.lo `test -f 'history.c' || echo '$(srcdir)/'`history.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-history.Tpo $(DEPDIR)/libmsn_la-history.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='history.c' object='libmsn_la-history.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-history.lo `test -f 'history.c' || echo '$(srcdir)/'`history.c
+
+libmsn_la-httpconn.lo: httpconn.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-httpconn.lo -MD -MP -MF $(DEPDIR)/libmsn_la-httpconn.Tpo -c -o libmsn_la-httpconn.lo `test -f 'httpconn.c' || echo '$(srcdir)/'`httpconn.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-httpconn.Tpo $(DEPDIR)/libmsn_la-httpconn.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='httpconn.c' object='libmsn_la-httpconn.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-httpconn.lo `test -f 'httpconn.c' || echo '$(srcdir)/'`httpconn.c
+
+libmsn_la-msg.lo: msg.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-msg.lo -MD -MP -MF $(DEPDIR)/libmsn_la-msg.Tpo -c -o libmsn_la-msg.lo `test -f 'msg.c' || echo '$(srcdir)/'`msg.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-msg.Tpo $(DEPDIR)/libmsn_la-msg.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='msg.c' object='libmsn_la-msg.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-msg.lo `test -f 'msg.c' || echo '$(srcdir)/'`msg.c
+
+libmsn_la-msn.lo: msn.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-msn.lo -MD -MP -MF $(DEPDIR)/libmsn_la-msn.Tpo -c -o libmsn_la-msn.lo `test -f 'msn.c' || echo '$(srcdir)/'`msn.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-msn.Tpo $(DEPDIR)/libmsn_la-msn.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='msn.c' object='libmsn_la-msn.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-msn.lo `test -f 'msn.c' || echo '$(srcdir)/'`msn.c
+
+libmsn_la-nexus.lo: nexus.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-nexus.lo -MD -MP -MF $(DEPDIR)/libmsn_la-nexus.Tpo -c -o libmsn_la-nexus.lo `test -f 'nexus.c' || echo '$(srcdir)/'`nexus.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-nexus.Tpo $(DEPDIR)/libmsn_la-nexus.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='nexus.c' object='libmsn_la-nexus.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-nexus.lo `test -f 'nexus.c' || echo '$(srcdir)/'`nexus.c
+
+libmsn_la-notification.lo: notification.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-notification.lo -MD -MP -MF $(DEPDIR)/libmsn_la-notification.Tpo -c -o libmsn_la-notification.lo `test -f 'notification.c' || echo '$(srcdir)/'`notification.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-notification.Tpo $(DEPDIR)/libmsn_la-notification.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='notification.c' object='libmsn_la-notification.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-notification.lo `test -f 'notification.c' || echo '$(srcdir)/'`notification.c
+
+libmsn_la-object.lo: object.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-object.lo -MD -MP -MF $(DEPDIR)/libmsn_la-object.Tpo -c -o libmsn_la-object.lo `test -f 'object.c' || echo '$(srcdir)/'`object.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-object.Tpo $(DEPDIR)/libmsn_la-object.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='object.c' object='libmsn_la-object.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-object.lo `test -f 'object.c' || echo '$(srcdir)/'`object.c
+
+libmsn_la-oim.lo: oim.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-oim.lo -MD -MP -MF $(DEPDIR)/libmsn_la-oim.Tpo -c -o libmsn_la-oim.lo `test -f 'oim.c' || echo '$(srcdir)/'`oim.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-oim.Tpo $(DEPDIR)/libmsn_la-oim.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='oim.c' object='libmsn_la-oim.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-oim.lo `test -f 'oim.c' || echo '$(srcdir)/'`oim.c
+
+libmsn_la-p2p.lo: p2p.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-p2p.lo -MD -MP -MF $(DEPDIR)/libmsn_la-p2p.Tpo -c -o libmsn_la-p2p.lo `test -f 'p2p.c' || echo '$(srcdir)/'`p2p.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-p2p.Tpo $(DEPDIR)/libmsn_la-p2p.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='p2p.c' object='libmsn_la-p2p.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-p2p.lo `test -f 'p2p.c' || echo '$(srcdir)/'`p2p.c
+
+libmsn_la-page.lo: page.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-page.lo -MD -MP -MF $(DEPDIR)/libmsn_la-page.Tpo -c -o libmsn_la-page.lo `test -f 'page.c' || echo '$(srcdir)/'`page.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-page.Tpo $(DEPDIR)/libmsn_la-page.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='page.c' object='libmsn_la-page.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-page.lo `test -f 'page.c' || echo '$(srcdir)/'`page.c
+
+libmsn_la-servconn.lo: servconn.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-servconn.lo -MD -MP -MF $(DEPDIR)/libmsn_la-servconn.Tpo -c -o libmsn_la-servconn.lo `test -f 'servconn.c' || echo '$(srcdir)/'`servconn.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-servconn.Tpo $(DEPDIR)/libmsn_la-servconn.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='servconn.c' object='libmsn_la-servconn.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-servconn.lo `test -f 'servconn.c' || echo '$(srcdir)/'`servconn.c
+
+libmsn_la-session.lo: session.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-session.lo -MD -MP -MF $(DEPDIR)/libmsn_la-session.Tpo -c -o libmsn_la-session.lo `test -f 'session.c' || echo '$(srcdir)/'`session.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-session.Tpo $(DEPDIR)/libmsn_la-session.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='session.c' object='libmsn_la-session.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-session.lo `test -f 'session.c' || echo '$(srcdir)/'`session.c
+
+libmsn_la-slp.lo: slp.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-slp.lo -MD -MP -MF $(DEPDIR)/libmsn_la-slp.Tpo -c -o libmsn_la-slp.lo `test -f 'slp.c' || echo '$(srcdir)/'`slp.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-slp.Tpo $(DEPDIR)/libmsn_la-slp.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='slp.c' object='libmsn_la-slp.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-slp.lo `test -f 'slp.c' || echo '$(srcdir)/'`slp.c
+
+libmsn_la-slpcall.lo: slpcall.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-slpcall.lo -MD -MP -MF $(DEPDIR)/libmsn_la-slpcall.Tpo -c -o libmsn_la-slpcall.lo `test -f 'slpcall.c' || echo '$(srcdir)/'`slpcall.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-slpcall.Tpo $(DEPDIR)/libmsn_la-slpcall.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='slpcall.c' object='libmsn_la-slpcall.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-slpcall.lo `test -f 'slpcall.c' || echo '$(srcdir)/'`slpcall.c
+
+libmsn_la-slplink.lo: slplink.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-slplink.lo -MD -MP -MF $(DEPDIR)/libmsn_la-slplink.Tpo -c -o libmsn_la-slplink.lo `test -f 'slplink.c' || echo '$(srcdir)/'`slplink.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-slplink.Tpo $(DEPDIR)/libmsn_la-slplink.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='slplink.c' object='libmsn_la-slplink.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-slplink.lo `test -f 'slplink.c' || echo '$(srcdir)/'`slplink.c
+
+libmsn_la-slpmsg.lo: slpmsg.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-slpmsg.lo -MD -MP -MF $(DEPDIR)/libmsn_la-slpmsg.Tpo -c -o libmsn_la-slpmsg.lo `test -f 'slpmsg.c' || echo '$(srcdir)/'`slpmsg.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-slpmsg.Tpo $(DEPDIR)/libmsn_la-slpmsg.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='slpmsg.c' object='libmsn_la-slpmsg.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-slpmsg.lo `test -f 'slpmsg.c' || echo '$(srcdir)/'`slpmsg.c
+
+libmsn_la-slpmsg_part.lo: slpmsg_part.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-slpmsg_part.lo -MD -MP -MF $(DEPDIR)/libmsn_la-slpmsg_part.Tpo -c -o libmsn_la-slpmsg_part.lo `test -f 'slpmsg_part.c' || echo '$(srcdir)/'`slpmsg_part.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-slpmsg_part.Tpo $(DEPDIR)/libmsn_la-slpmsg_part.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='slpmsg_part.c' object='libmsn_la-slpmsg_part.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-slpmsg_part.lo `test -f 'slpmsg_part.c' || echo '$(srcdir)/'`slpmsg_part.c
+
+libmsn_la-soap.lo: soap.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-soap.lo -MD -MP -MF $(DEPDIR)/libmsn_la-soap.Tpo -c -o libmsn_la-soap.lo `test -f 'soap.c' || echo '$(srcdir)/'`soap.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-soap.Tpo $(DEPDIR)/libmsn_la-soap.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='soap.c' object='libmsn_la-soap.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-soap.lo `test -f 'soap.c' || echo '$(srcdir)/'`soap.c
+
+libmsn_la-state.lo: state.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-state.lo -MD -MP -MF $(DEPDIR)/libmsn_la-state.Tpo -c -o libmsn_la-state.lo `test -f 'state.c' || echo '$(srcdir)/'`state.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-state.Tpo $(DEPDIR)/libmsn_la-state.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='state.c' object='libmsn_la-state.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-state.lo `test -f 'state.c' || echo '$(srcdir)/'`state.c
+
+libmsn_la-sbconn.lo: sbconn.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-sbconn.lo -MD -MP -MF $(DEPDIR)/libmsn_la-sbconn.Tpo -c -o libmsn_la-sbconn.lo `test -f 'sbconn.c' || echo '$(srcdir)/'`sbconn.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-sbconn.Tpo $(DEPDIR)/libmsn_la-sbconn.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='sbconn.c' object='libmsn_la-sbconn.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-sbconn.lo `test -f 'sbconn.c' || echo '$(srcdir)/'`sbconn.c
+
+libmsn_la-switchboard.lo: switchboard.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-switchboard.lo -MD -MP -MF $(DEPDIR)/libmsn_la-switchboard.Tpo -c -o libmsn_la-switchboard.lo `test -f 'switchboard.c' || echo '$(srcdir)/'`switchboard.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-switchboard.Tpo $(DEPDIR)/libmsn_la-switchboard.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='switchboard.c' object='libmsn_la-switchboard.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-switchboard.lo `test -f 'switchboard.c' || echo '$(srcdir)/'`switchboard.c
+
+libmsn_la-table.lo: table.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-table.lo -MD -MP -MF $(DEPDIR)/libmsn_la-table.Tpo -c -o libmsn_la-table.lo `test -f 'table.c' || echo '$(srcdir)/'`table.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-table.Tpo $(DEPDIR)/libmsn_la-table.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='table.c' object='libmsn_la-table.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-table.lo `test -f 'table.c' || echo '$(srcdir)/'`table.c
+
+libmsn_la-transaction.lo: transaction.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-transaction.lo -MD -MP -MF $(DEPDIR)/libmsn_la-transaction.Tpo -c -o libmsn_la-transaction.lo `test -f 'transaction.c' || echo '$(srcdir)/'`transaction.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-transaction.Tpo $(DEPDIR)/libmsn_la-transaction.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='transaction.c' object='libmsn_la-transaction.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-transaction.lo `test -f 'transaction.c' || echo '$(srcdir)/'`transaction.c
+
+libmsn_la-user.lo: user.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-user.lo -MD -MP -MF $(DEPDIR)/libmsn_la-user.Tpo -c -o libmsn_la-user.lo `test -f 'user.c' || echo '$(srcdir)/'`user.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-user.Tpo $(DEPDIR)/libmsn_la-user.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='user.c' object='libmsn_la-user.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-user.lo `test -f 'user.c' || echo '$(srcdir)/'`user.c
+
+libmsn_la-userlist.lo: userlist.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-userlist.lo -MD -MP -MF $(DEPDIR)/libmsn_la-userlist.Tpo -c -o libmsn_la-userlist.lo `test -f 'userlist.c' || echo '$(srcdir)/'`userlist.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-userlist.Tpo $(DEPDIR)/libmsn_la-userlist.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='userlist.c' object='libmsn_la-userlist.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-userlist.lo `test -f 'userlist.c' || echo '$(srcdir)/'`userlist.c
+
+libmsn_la-xfer.lo: xfer.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-xfer.lo -MD -MP -MF $(DEPDIR)/libmsn_la-xfer.Tpo -c -o libmsn_la-xfer.lo `test -f 'xfer.c' || echo '$(srcdir)/'`xfer.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-xfer.Tpo $(DEPDIR)/libmsn_la-xfer.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='xfer.c' object='libmsn_la-xfer.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-xfer.lo `test -f 'xfer.c' || echo '$(srcdir)/'`xfer.c
+
+libmsn_la-msnutils.lo: msnutils.c
+@am__fastdepCC_TRUE@	$(AM_V_CC)$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -MT libmsn_la-msnutils.lo -MD -MP -MF $(DEPDIR)/libmsn_la-msnutils.Tpo -c -o libmsn_la-msnutils.lo `test -f 'msnutils.c' || echo '$(srcdir)/'`msnutils.c
+@am__fastdepCC_TRUE@	$(AM_V_at)$(am__mv) $(DEPDIR)/libmsn_la-msnutils.Tpo $(DEPDIR)/libmsn_la-msnutils.Plo
+@am__fastdepCC_FALSE@	$(AM_V_CC) @AM_BACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	source='msnutils.c' object='libmsn_la-msnutils.lo' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(libmsn_la_CFLAGS) $(CFLAGS) -c -o libmsn_la-msnutils.lo `test -f 'msnutils.c' || echo '$(srcdir)/'`msnutils.c
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+
+ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)
+	list='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	mkid -fID $$unique
+tags: TAGS
+
+TAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	set x; \
+	here=`pwd`; \
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: CTAGS
+CTAGS:  $(HEADERS) $(SOURCES)  $(TAGS_DEPENDENCIES) \
+		$(TAGS_FILES) $(LISP)
+	list='$(SOURCES) $(HEADERS)  $(LISP) $(TAGS_FILES)'; \
+	unique=`for i in $$list; do \
+	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+	  done | \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+
+distdir: $(DISTFILES)
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+check-am: all-am
+check: check-am
+all-am: Makefile $(LTLIBRARIES)
+installdirs:
+	for dir in "$(DESTDIR)$(pkgdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-am
+install-exec: install-exec-am
+install-data: install-data-am
+uninstall: uninstall-am
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-am
+install-strip:
+	$(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	  install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	  `test -z '$(STRIP)' || \
+	    echo "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'"` install
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-am
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	clean-pkgLTLIBRARIES mostlyclean-am
+
+distclean: distclean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-tags
+
+dvi: dvi-am
+
+dvi-am:
+
+html: html-am
+
+html-am:
+
+info: info-am
+
+info-am:
+
+install-data-am: install-pkgLTLIBRARIES
+
+install-dvi: install-dvi-am
+
+install-dvi-am:
+
+install-exec-am:
+
+install-html: install-html-am
+
+install-html-am:
+
+install-info: install-info-am
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-am
+
+install-pdf-am:
+
+install-ps: install-ps-am
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-am
+	-rm -rf ./$(DEPDIR)
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-am
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-am
+
+pdf-am:
+
+ps: ps-am
+
+ps-am:
+
+uninstall-am: uninstall-pkgLTLIBRARIES
+
+.MAKE: install-am install-strip
+
+.PHONY: CTAGS GTAGS all all-am check check-am clean clean-generic \
+	clean-libtool clean-noinstLTLIBRARIES clean-pkgLTLIBRARIES \
+	ctags distclean distclean-compile distclean-generic \
+	distclean-libtool distclean-tags distdir dvi dvi-am html \
+	html-am info info-am install install-am install-data \
+	install-data-am install-dvi install-dvi-am install-exec \
+	install-exec-am install-html install-html-am install-info \
+	install-info-am install-man install-pdf install-pdf-am \
+	install-pkgLTLIBRARIES install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags uninstall uninstall-am uninstall-pkgLTLIBRARIES
+
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/pidgin-facebookchat.rc pidgin-2.7.7-new//libpurple/protocols/facebook/pidgin-facebookchat.rc
--- pidgin-2.7.7/libpurple/protocols/facebook/pidgin-facebookchat.rc	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/pidgin-facebookchat.rc	2011-03-27 09:15:30.884553000 -0600
@@ -0,0 +1,28 @@
+
+1 VERSIONINFO
+FILEVERSION 1,69,0,0
+PRODUCTVERSION 1,69,0,0
+FILEOS 0x40004 // VOS_NT_WINDOWS32
+FILETYPE 0x2 // VFT_DLL
+{
+BLOCK "StringFileInfo"
+{
+	BLOCK "040904B0" // U.S. English, Unicode
+	{
+		VALUE "CompanyName", "Eion Robb\0"
+		VALUE "FileDescription",  "Facebook Chat plugin for Pidgin\0"
+		VALUE "ProductName", "pidgin-facebookchat\0"
+		VALUE "FileVersion", "1.69\0"
+		VALUE "ProductVersion", "1.69\0"
+		VALUE "InternalName", "pidgin-facebookchat\0"
+		VALUE "OriginalFilename", "libfacebook.dll\0"
+		VALUE "Comments", "http://pidgin-facebookchat.googlecode.com/\0"
+	}
+}
+
+BLOCK "VarFileInfo"
+{
+	VALUE "Translation", 0x0409, 0x04B0 // U.S. English, Unicode
+}
+}
+
diff -rupN pidgin-2.7.7/libpurple/protocols/facebook/rss.xml pidgin-2.7.7-new//libpurple/protocols/facebook/rss.xml
--- pidgin-2.7.7/libpurple/protocols/facebook/rss.xml	1969-12-31 18:00:00.000000000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/facebook/rss.xml	2011-03-27 09:15:30.912552999 -0600
@@ -0,0 +1,280 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
+	<channel>
+		<title>pidgin-facebookchat Changelog</title>
+		<atom:link href="http://pidgin-facebookchat.googlecode.com/svn/trunk/rss.xml" rel="self" type="application/rss+xml" />
+		<link>http://code.google.com/p/pidgin-facebookchat/wiki/Changelog</link>
+		<description>Recent updates for the Facebook plugin for Pidgin</description>
+		<language>en-NZ</language>
+		<image>
+			<title>pidgin-facebookchat Changelog</title>
+			<url>http://pidgin-facebookchat.googlecode.com/svn/trunk/facebook48.png</url>
+			<link>http://code.google.com/p/pidgin-facebookchat/</link>
+			<width>48</width><height>48</height>
+		</image>
+		<item>
+			<title>Version 1.69</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c56</link>
+			<description><![CDATA[Fix for buddy list not downloading/all friends showing as offline.  (If you're reading the RSS feeds then you also missed out on the version with multi-user group chat support)]]></description>
+			<pubDate>Sat 27 Nov 2010 23:59:58 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c58</guid>
+		</item>
+		<item>
+			<title>Version 1.67</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c56</link>
+			<description><![CDATA[Just wanted to squeeze out one more quick change to the plugin.  It now works with the new 'Account Security'/'device login'/'register your computer' thing.<br/>
+			<br/>
+			Download v1.67 from<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Downloads">http://code.google.com/p/pidgin-facebookchat/wiki/Downloads</a><br/>
+			<br/>			
+			(Please don't post comments in this thread :) )]]></description>
+			<pubDate>Tue 1 Jun 2010 15:56:00 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c56</guid>
+		</item>
+		<item>
+			<title>Version 1.66</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c54</link>
+			<description><![CDATA[I've just pushed out what will hopefully be the last of the 1.x series of the plugin.<br/>
+			Fixes a crash-on-connect and the status messages.<br/>
+			Download from<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Downloads">http://code.google.com/p/pidgin-facebookchat/wiki/Downloads</a><br/>
+			<br/>			
+			Thanks all for your patience while I get v2.0 of the plugin sorted]]></description>
+			<pubDate>Tue 1 Jun 2010 08:30:00 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c54</guid>
+		</item>
+		<item>
+			<title>Version 1.65</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c53</link>
+			<description><![CDATA[Hi all. Been a wee while since the last version of the plugin.  This version has a 
+			fix for newer buddy icons being too small, and also downloads all your offline 
+			buddies as well as your online ones.<br/>
+			Download from usual place<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Downloads">http://code.google.com/p/pidgin-facebookchat/wiki/Downloads</a><br/>
+			<br/>
+			Also, in case you haven't heard, Facebook has come out with an XMPP interface (so 
+			you dont *have* to use this plugin to connect to FB anymore).  I'm currently 
+			working on rewriting a new, more stable version 2.0 of the plugin, which will use 
+			XMPP, while filling in some of the gaps of features that you're all used to by now :)<br/>]]></description>
+			<pubDate>Fri 26 Feb 2010 14:40:29 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c53</guid>
+		</item>
+		<item>
+			<title>Version 1.64</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c52</link>
+			<description><![CDATA[I've just dropped v1.64 out for download at<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Downloads">http://code.google.com/p/pidgin-facebookchat/wiki/Downloads</a><br/>
+			<br/>
+			It fixes up some really annoying things like buddy icons not working and some strange status message stuffs.<br/>
+			<br/>
+			Changelog:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Changelog">http://code.google.com/p/pidgin-facebookchat/wiki/Changelog</a><br/>
+			<br/>
+			(Apologies to rss feed subscribers for the slow post) ]]></description>
+			<pubDate>Fri 4 December 2009 17:43:30 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c52</guid>
+		</item>
+		<item>
+			<title>Version 1.63</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c51</link>
+			<description><![CDATA[Just pushed out v1.63 which fixes up a few of the little annoying things that didn't 
+			work since the last update.<br/>
+			Status messages are back, inbox notifications are back, friend accept/reject/add is 
+			back.<br/>
+			<br/>
+			Download as usual from<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Downloads">
+			http://code.google.com/p/pidgin-facebookchat/wiki/Downloads</a>
+			]]></description>
+			<pubDate>Sat, 14 November 2009 12:21:52 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c51</guid>
+		</item>
+		<item>
+			<title>Version 1.62</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c50</link>
+			<description><![CDATA[Some of you fancy people might have noticed that the plugin hasn't been doing too well over the last few hours.<br/>
+			Fortunately, I've been hard at work to quickly push out a new version.<br/>
+			<br/>
+			Grab it from<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Downloads">http://code.google.com/p/pidgin-facebookchat/wiki/Downloads</a><br/>
+			while it's still hot]]></description>
+			<pubDate>Wed, 4 November 2009 18:49:10 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c50</guid>
+		</item>
+		<item>
+			<title>Version 1.61</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c49</link>
+			<description><![CDATA[Against all odds, I've just put out a new version 1.61 of the plugin.  It should fix up the problems with messages arriving from weird numbers, but it also now requires version 0.7.6 of json-glib to work.  It might or might not also have the option to disable friends lists, depending on who you ask :)<br/><br/>
+			Changelog:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Changelog">http://code.google.com/p/pidgin-facebookchat/wiki/Changelog</a><br/>
+			Download:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a><br/>]]></description>
+			<pubDate>Tue, 8 September 2009 17:38:16 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c49</guid>
+		</item>
+		<item>
+			<title>Version 1.60</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c48</link>
+			<description><![CDATA[Hi all, sorry for the recent weirdness with the plugin.  v1.60 is out which addresses the major bit of these problems.<br/>
+			Changelog:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Changelog">http://code.google.com/p/pidgin-facebookchat/wiki/Changelog</a><br/>
+			Download:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a><br/>
+			(apologies to you RSS readers out there who missed out on v1.54)]]></description>
+			<pubDate>Fri, 17 July 2009 22:05:20 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c48</guid>
+		</item>
+		<item>
+			<title>Version 1.53</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c46</link>
+			<description><![CDATA[<a href="http://www.pidgin.im">Pidgin 2.5.8</a> is available and so is 1.53 of pidgin-facebookchat.
+			<br/><br/>
+			We've fixed some important things such as no more missing messages, and buddy names working.  You can see all the neat things we've done at:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Changelog">http://code.google.com/p/pidgin-facebookchat/wiki/Changelog</a>
+			<br/><br/>
+			Thank you all for using the plugin!  If you feel like helping me pay for my fiances $300/month medication bills I'd really appreciate a donation.  Even one or two dollars can go a long way.  You can donate at:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Donate">http://code.google.com/p/pidgin-facebookchat/wiki/Donate</a>
+			<br/><br/>
+			Otherwise, go grab the update from the usual place:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a>]]></description>
+			<pubDate>Mon, 29 June 2009 20:56:20 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c46</guid>
+		</item>
+		<item>
+			<title>Version 1.52</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c45</link>
+			<description><![CDATA[Just uploaded version 1.52 which fixes an annoying crash sometimes.  Don't forget to download 2.5.7 of Pidgin while you're at it
+			<br/><br/>
+			Download pidgin-facebookchat from:<br/>
+			http://code.google.com/p/pidgin-facebookchat/downloads/list]]></description>
+			<pubDate>Mon, 22 June 2009 19:04:56 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c45</guid>
+		</item>
+		<item>
+			<title>Version 1.51</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c44</link>
+			<description><![CDATA[Version 1.51 of the pidgin-facebookchat plugin is available for download.<br/>
+			<br/>
+			Download (as usual) from:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">
+			http://code.google.com/p/pidgin-facebookchat/downloads/list</a><br/>
+			<br/>
+			A list of the changes to the plugin is at:<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Changelog">
+			http://code.google.com/p/pidgin-facebookchat/wiki/Changelog</a><br/>
+			<br/>
+			If you're a package maintainer, you'll want to look at my blog post:<br/>
+			<a href="http://eion.robbmob.com/blog/2009/06/12/pidgin-facebookchat-v1-51-important-changes/">
+			http://eion.robbmob.com/blog/2009/06/12/pidgin-facebookchat-v1-51-important-changes/</a><br/>
+			(Shameless plug)<br/>
+			<br/>
+			And of course, if you like this plugin feel free to leave a comment or donation at<br/>
+			<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Donate">
+			http://code.google.com/p/pidgin-facebookchat/wiki/Donate</a>
+			]]></description>
+			<pubDate>Sat, 13 June 2009 19:24:19 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c44</guid>
+		</item>
+		<item>
+			<title>Version 1.50</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c42</link>
+			<description><![CDATA[So its been a while since the last version so I've bumped it up to v1.50.
+			<br/><br/>
+			This version should (hopefully) fix the bandwidth issues that people are having, as well as a crash-on-quit issue.			
+			<br/><br/>
+			Oh, and some people may be interested to try setting their status to 'idle' when they set their status to 'away'.  Maybe.  Haven't tried it :)
+			<br/><br/>
+			Download v1.50 of the plugin from:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a>]]></description>
+			<pubDate>Mon, 13 Apr 2009 00:03:29 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c42</guid>
+		</item>	
+		<item>
+			<title>Version 1.47</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c41</link>
+			<description><![CDATA[v1.47 Gets rid of the "(via Pidgin)" but when setting status message and fixes some rare crashes
+			<br/><br/>
+			Download v1.47 of the plugin from:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a>]]></description>
+			<pubDate>Wed, 31 Dec 2008 18:18:18 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c41</guid>
+		</item>	
+		<item>
+			<title>Version 1.46</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c40</link>
+			<description><![CDATA[v1.46 is out, and for once we didn't have any crashes to fix :)
+			<br/><br/>
+We've added support for Pokes, we've made the idle/away stuff work properly, the buddy icons are larger for everyone, and aliases work better on buddies.
+			<br/><br/>
+Just a bit of news: this Facebook plugin is now in Meebo, thanks to Mark Doliner from Meebo who is a "Project Member" of this plugin.  Also, Casey Ho (who has been doing a fantastic job of triaging issues) has been promoted to "Project Owner" so that he can mess around with the page a bit.
+			<br/><br/>
+I just wanted to say a big public thanks to both these people for their hard work.  This plugin gets thousands of downloads and it's so exciting for me to see the plugin in Meebo so that thousands more people can enjoy the plugin :)
+			<br/><br/>
+Without futher ado, grab v1.46 of the plugin from:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a>]]></description>
+			<pubDate>Mon, 29 Dec 2008 23:00:00 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c40</guid>
+		</item>
+		<item>
+			<title>Version 1.45</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c39</link>
+			<description><![CDATA[v1.45 Fixes a couple more crashes and some memory leaks.
+			<br/><br/>
+Go get v1.45 from:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a>]]></description>
+			<pubDate>Fri, 19 Dec 2008 00:00:00 +1300</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c39</guid>
+		</item>
+		<item>
+			<title>Version 1.44</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c38</link>
+			<description><![CDATA[v1.44 Fixes a couple of crashes and might help you if you're experiencing any problems.
+			<br/><br/>
+Go get v1.44 from:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a>]]></description>
+			<pubDate>Tue, 11 Dec 2008 00:00:00 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c38</guid>
+		</item>
+		<item>
+			<title>Version 1.43</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c37</link>
+			<description><![CDATA[v1.43 is available for download.
+			<br/><br/>
+It fixes 2 major crashes, and the status message now updates properly.  Also, the .deb package should work for Finch or libpurple installs now, and not just Pidgin.
+			<br/><br/>
+Go get v1.43 from:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a>
+			<br/><br/>
+Send us developers some hard-earned love at:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/wiki/Donate">http://code.google.com/p/pidgin-facebookchat/wiki/Donate</a> ]]></description>
+			<pubDate>Mon, 8 Dec 2008 00:00:00 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c37</guid>
+		</item>
+		<item>
+			<title>Version 1.41</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c35</link>
+			<description><![CDATA[v1.41 is out, hot on the heels of version 1.40... two releases in one day.
+			<br/><br/>
+The only real reason for this update is to address a couple of minor bugs and some annoying crashes.  That should be all of them.
+Also new to the table is an RSS feed at <a href="http://pidgin-facebookchat.googlecode.com/svn/trunk/rss.xml">http://pidgin-facebookchat.googlecode.com/svn/trunk/rss.xml</a>.  I'll keep updating the issue, so that you can still be kept up-to-date by email, but now you have another option.
+			<br/><br/>
+From now on, the minimum version of Pidgin you'll need is 2.3.0.  Also, the source package has changed slightly, so if you've got any automated build scripts you might want to update them.
+			<br/><br/>
+Go download v1.41 from:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a> ]]></description>
+			<pubDate>Wed, 3 Dec 2008 17:41:09 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c36</guid>
+		</item>
+		<item>
+			<title>Version 1.40</title>
+			<link>http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c35</link>
+			<description><![CDATA[So thanks to the fantastic efforts of Mark and Casey, v1.40 is now available for download.  They've fixed most of the crashes and made the plugin really really stable.
+		<br/><br/>
+Go download v1.40 from:<br/>
+<a href="http://code.google.com/p/pidgin-facebookchat/downloads/list">http://code.google.com/p/pidgin-facebookchat/downloads/list</a> ]]></description>
+			<pubDate>Wed, 3 Dec 2008 07:31:09 +1200</pubDate>
+			<guid isPermaLink="true">http://code.google.com/p/pidgin-facebookchat/issues/detail?id=24#c35</guid>
+		</item>
+	</channel>
+</rss>
+
diff -rupN pidgin-2.7.7/libpurple/protocols/jabber/roster.c pidgin-2.7.7-new//libpurple/protocols/jabber/roster.c
--- pidgin-2.7.7/libpurple/protocols/jabber/roster.c	2011-03-27 09:05:48.152553000 -0600
+++ pidgin-2.7.7-new//libpurple/protocols/jabber/roster.c	2011-03-27 09:15:30.288552999 -0600
@@ -216,6 +216,10 @@ void jabber_roster_parse(JabberStream *j
 		if(!jid)
 			continue;
 
+		if((strchr(jid, '@')) == NULL)
+		        continue;
+
+
 		if(!(jb = jabber_buddy_find(js, jid, TRUE)))
 			continue;
 
