diff -rupN imlibpurpleservice-1.0/inc/PalmImCommon.h imlibpurpleservice-1.0-new//inc/PalmImCommon.h
--- imlibpurpleservice-1.0/inc/PalmImCommon.h	2011-03-25 10:45:40.648552999 -0600
+++ imlibpurpleservice-1.0-new//inc/PalmImCommon.h	2011-03-27 09:10:06.064552999 -0600
@@ -40,6 +40,7 @@
 #define SERVICENAME_ICQ "type_icq"
 #define SERVICENAME_JABBER "type_jabber"
 #define SERVICENAME_LIVE "type_live"
+#define SERVICENAME_WLM "type_wlm"
 #define SERVICENAME_MYSPACE "type_myspace"
 #define SERVICENAME_QQ "type_qq"
 #define SERVICENAME_SAMETIME "type_sametime"
@@ -57,6 +58,7 @@
 #define CAPABILITY_ICQ "org.webosinternals.messaging.icq"
 #define CAPABILITY_JABBER "org.webosinternals.messaging.jabber"
 #define CAPABILITY_LIVE "org.webosinternals.messaging.live"
+#define CAPABILITY_WLM "org.webosinternals.messaging.wlm"
 #define CAPABILITY_MYSPACE "org.webosinternals.messaging.myspace"
 #define CAPABILITY_QQ "org.webosinternals.messaging.qq"
 #define CAPABILITY_SAMETIME "org.webosinternals.messaging.sametime"
diff -rupN imlibpurpleservice-1.0/Makefile imlibpurpleservice-1.0-new//Makefile
--- imlibpurpleservice-1.0/Makefile	2011-03-25 10:45:40.672552999 -0600
+++ imlibpurpleservice-1.0-new//Makefile	2011-03-27 09:10:06.108553000 -0600
@@ -7,7 +7,7 @@ LOCAL_INCLUDES := -I$(QPEDIR)/include/mo
 					-I./inc \
 					-I$(STAGING_INCDIR) \
 					-I.
-LOCAL_CFLAGS := $(CFLAGS) -Wall -Werror -DMOJ_LINUX -DBOOST_NO_TYPEID $(LOCAL_INCLUDES) $(shell pkg-config --cflags glib-2.0 purple)
+LOCAL_CFLAGS := $(CFLAGS) -Wall -Werror -DMOJ_LINUX -DBOOST_NO_TYPEID $(LOCAL_INCLUDES) $(shell pkg-config --cflags glib-2.0 purple) -march=armv7-a
 LOCAL_CPPFLAGS := $(CPPFLAGS) -fno-rtti
 
-include Makefile.inc
\ No newline at end of file
+include Makefile.inc
diff -rupN imlibpurpleservice-1.0/Makefile.inc imlibpurpleservice-1.0-new//Makefile.inc
--- imlibpurpleservice-1.0/Makefile.inc	2011-03-25 10:45:39.596552999 -0600
+++ imlibpurpleservice-1.0-new//Makefile.inc	2011-03-27 09:10:04.848552999 -0600
@@ -1,5 +1,6 @@
+CXX = g++
 LIBS := -llunaservice  -lmojoluna -lmojodb -lmojocore -lpurple -lsanitize
-LOCAL_LDFLAGS := $(LDFLAGS) $(LIBS) -Llib/armv6 -Llib/armv7 -Llib/x86 -Wl,-R/media/cryptofs/apps/usr/palm/applications/org.webosinternals.messaging/sysfiles/usr/lib -Wl,-Rlib/x86 -Wl,-Rlib/armv6 -Wl,-Rlib/armv7
+LOCAL_LDFLAGS := -Wl,-Rlib/armv7 -Llib/armv7 $(LDFLAGS) $(LIBS) -Wl,-R/media/cryptofs/apps/usr/palm/applications/org.webosinternals.messaging/sysfiles/usr/lib
 
 IM_SOURCES := \
 	BuddyListConsolidator.cpp \
@@ -27,7 +28,7 @@ IM_OBJECTS := $(IM_SOURCES:%.cpp=$(OBJDI
 all: setup $(IM_TARGET)
 		
 $(IM_TARGET): $(IM_OBJECTS) 
-	$(CXX) -o $(IM_TARGET) $(IM_OBJECTS) $(LOCAL_LDFLAGS) 
+	$(CXX) -o $(IM_TARGET) $(IM_OBJECTS) $(LOCAL_LDFLAGS) lib/armv7/libstdc++.so.6
 	
 $(OBJDIR)/%.o: %.cpp
 	$(CXX) -MMD $(INCLUDES) $(LOCAL_CFLAGS) $(LOCAL_CPPFLAGS) -c $< -o $@
diff -rupN imlibpurpleservice-1.0/src/IMLoginState.cpp imlibpurpleservice-1.0-new//src/IMLoginState.cpp
--- imlibpurpleservice-1.0/src/IMLoginState.cpp	2011-03-25 10:45:40.740553000 -0600
+++ imlibpurpleservice-1.0-new//src/IMLoginState.cpp	2011-03-27 09:10:06.156553000 -0600
@@ -1413,6 +1413,9 @@ void IMLoginSyncStateHandler::updateSync
 	else if (strcmp(serviceName, SERVICENAME_LIVE) == 0){
 		m_capabilityId.assign(CAPABILITY_LIVE);
 	}
+	else if (strcmp(serviceName, SERVICENAME_WLM) == 0){
+		m_capabilityId.assign(CAPABILITY_WLM);
+	}
 	else if (strcmp(serviceName, SERVICENAME_MYSPACE) == 0){
 		m_capabilityId.assign(CAPABILITY_MYSPACE);
 	}
diff -rupN imlibpurpleservice-1.0/src/IMLoginState.cpp~ imlibpurpleservice-1.0-new//src/IMLoginState.cpp~
--- imlibpurpleservice-1.0/src/IMLoginState.cpp~	1969-12-31 18:00:00.000000000 -0600
+++ imlibpurpleservice-1.0-new//src/IMLoginState.cpp~	2011-03-27 09:10:06.124553000 -0600
@@ -0,0 +1,1538 @@
+/*
+ * IMLoginState.h
+ *
+ * Copyright 2010 Palm, Inc. All rights reserved.
+ *
+ * This program is free software and licensed under the terms of the GNU
+ * General Public License Version 2 as published by the Free
+ * Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License,
+ * Version 2 along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-
+ * 1301, USA
+ *
+ * IMLibpurpleservice uses libpurple.so to implement a fully functional IM
+ * Transport service for use on a mobile device.
+ *
+ * IMLoginState class handles changes in user login status
+ */
+
+#include "IMLoginState.h"
+#include "db/MojDbQuery.h"
+#include "PalmImCommon.h"
+#include "IMDefines.h"
+#include "IMServiceApp.h"
+#include "ConnectionStateHandler.h"
+#include "DisplayController.h"
+#include "LibpurpleAdapter.h"
+
+/*
+ * IMLoginState
+ */
+IMLoginState::IMLoginState(MojService* service)
+: m_loginStateRevision(0),
+  m_signalHandler(NULL),
+  m_service(service)
+{
+	// Register for login callbacks
+	LibpurpleAdapter::assignIMLoginState(this);
+	// Register for connection changed callbacks.
+	ConnectionState::setLoginStateCallback(this);
+}
+
+IMLoginState::~IMLoginState()
+{
+	LibpurpleAdapter::assignIMLoginState(NULL);
+	ConnectionState::setLoginStateCallback(NULL);
+}
+
+void IMLoginState::handlerDone(IMLoginStateHandlerInterface* handler)
+{
+	// this gets called from "handler's" destructor
+	if (m_signalHandler != handler)
+	{
+		MojLogError(IMServiceApp::s_log, _T("handlerDone doesn't match. ours=%p, theirs=%p being destroyed"), m_signalHandler, handler);
+	}
+	else
+	{
+		m_signalHandler = NULL;
+	}
+}
+
+void IMLoginState::loginForTesting(MojServiceMessage* serviceMsg, const MojObject payload)
+{
+	m_signalHandler = new IMLoginStateHandler(m_service, m_loginStateRevision, this);
+	m_signalHandler->loginForTesting(serviceMsg, payload);
+}
+
+/*
+ * LoginState DB watch was triggered
+ */
+MojErr IMLoginState::handleLoginStateChange(MojServiceMessage* serviceMsg, const MojObject payload)
+{
+	// we should not be orphaning an existing handler...
+	if (NULL != m_signalHandler) {
+		MojLogError(IMServiceApp::s_log, _T("handleLoginStateChange: called when signal handler already existed."));
+	}
+
+	m_signalHandler = new IMLoginStateHandler(m_service, m_loginStateRevision, this);
+	return m_signalHandler->handleLoginStateChange(serviceMsg, payload);
+}
+
+/*
+ * Connection Manager subscription watch was triggered
+ */
+MojErr IMLoginState::handleConnectionChanged(const MojObject& payload)
+{
+	//TODO: this should be its own ConnectionChangedHandler
+	if (m_signalHandler == NULL)
+	{
+		MojLogWarning(IMServiceApp::s_log, _T("handleConnectionChanged needed to create a signal handler"));
+		m_signalHandler = new IMLoginStateHandler(m_service, m_loginStateRevision, this);
+	}
+	return m_signalHandler->handleConnectionChanged(payload);
+}
+
+/*
+ * Callback from libpurple when the account is signed on or off
+ */
+void IMLoginState::loginResult(const char* serviceName, const char* username, LoginResult type, bool loggedOut, const char* errCode, bool noRetry)
+{
+	if (m_signalHandler == NULL)
+	{
+		MojLogWarning(IMServiceApp::s_log, _T("loginResult needed to create a signal handler"));
+		m_signalHandler = new IMLoginStateHandler(m_service, m_loginStateRevision, this);
+	}
+	m_signalHandler->loginResult(serviceName, username, type, loggedOut, errCode, noRetry);
+}
+
+/*
+ * Callback from libpurple when buddy list is synced
+ */
+void IMLoginState::buddyListResult(const char* serviceName, const char* username, MojObject& buddyList, bool fullList)
+{
+	// fullList == false means it is just changes to an individual buddy
+	if (fullList == false)
+	{
+		MojLogError(IMServiceApp::s_log, _T("buddyListResult: fullList is false. Doing nothing."));
+		//TODO: Query com.palm.contact for this buddy to see if it needs to be updated (picture or name changed)
+		//TODO: Merge (with query) com.palm.imbuddystatus to update this buddy's availability and custom message
+	}
+	else
+	{
+		if (m_signalHandler == NULL)
+		{
+			MojLogError(IMServiceApp::s_log, _T("buddyListResult called but m_signalHandler == NULL. Doing nothing."));
+		}
+		else
+		{
+			m_signalHandler->fullBuddyListResult(serviceName, username, buddyList);
+		}
+	}
+}
+
+
+bool IMLoginState::getLoginStateData(const MojString& key, LoginStateData& state)
+{
+	bool found = (m_loginState.find(key) != m_loginState.end());
+	if (found)
+	{
+		state = m_loginState[key];
+	}
+	return found;
+}
+
+bool IMLoginState::getLoginStateData(const MojString& serviceName, const MojString& username, LoginStateData& state)
+{
+	std::map<MojString, LoginStateData>::iterator itr = m_loginState.begin();
+	bool found = false;
+	while (!found && itr != m_loginState.end())
+	{
+		state = itr->second;
+		found = (state.getServiceName() == serviceName && state.getUsername() == username);
+		if (!found)
+		{
+			itr++;
+		}
+	}
+
+	return found;
+}
+
+void IMLoginState::putLoginStateData(const MojString& key, LoginStateData& newState)
+{
+	m_loginState[key] = newState;
+}
+
+
+/*
+ * IMLoginStateHandler -- signal handler
+ */
+IMLoginStateHandler::IMLoginStateHandler(MojService* service, MojInt64 loginStateRevision, IMLoginState* loginStateController)
+: m_activityAdoptSlot(this, &IMLoginStateHandler::activityAdoptResult),
+  m_activityCompleteSlot(this, &IMLoginStateHandler::activityCompleteResult),
+  m_setWatchSlot(this, &IMLoginStateHandler::setWatchResult),
+  m_loginStateQuerySlot(this, &IMLoginStateHandler::loginStateQueryResult),
+  m_getCredentialsSlot(this, &IMLoginStateHandler::getCredentialsResult),
+  m_updateLoginStateSlot(this, &IMLoginStateHandler::updateLoginStateResult),
+  m_ignoreUpdateLoginStateSlot(this, &IMLoginStateHandler::ignoreUpdateLoginStateResult),
+  m_queryForContactsSlot(this, &IMLoginStateHandler::queryForContactsResult),
+  m_queryForBuddyStatusSlot(this, &IMLoginStateHandler::queryForBuddyStatusResult),
+  m_markBuddiesAsOfflineSlot(this, &IMLoginStateHandler::markBuddiesAsOfflineResult),
+  m_moveMessagesToPendingSlot(this, &IMLoginStateHandler::moveMessagesToPendingResult),
+  m_moveCommandsToPendingSlot(this, &IMLoginStateHandler::moveCommandsToPendingResult),
+  m_service(service),
+  m_dbClient(service, MojDbServiceDefs::ServiceName),
+  m_tempdbClient(service, MojDbServiceDefs::TempServiceName),
+  m_loginStateController(loginStateController),
+  m_activityId(-1),
+  m_workingLoginStateRev(loginStateRevision),
+  m_buddyListConsolidator(NULL)
+{
+}
+
+
+IMLoginStateHandler::~IMLoginStateHandler()
+{
+	// Tell IMLoginState that this handler is destroyed
+	m_loginStateController->handlerDone(this);
+}
+
+void IMLoginStateHandler::loginForTesting(MojServiceMessage* serviceMsg, const MojObject payload)
+{
+	LoginParams loginParams;
+
+	// your username and password go here!
+	loginParams.username = "xxx@aol.com";
+	loginParams.password = "xxx";
+	loginParams.serviceName = "type_aim";
+
+	loginParams.availability = PalmAvailability::ONLINE;
+	loginParams.customMessage = "";
+	loginParams.connectionType = "wan";
+	loginParams.localIpAddress = NULL;
+	loginParams.accountId = "";
+	LibpurpleAdapter::login(&loginParams, m_loginStateController);
+	serviceMsg->replySuccess();
+}
+/*
+ * This is an entry point into the IMLoginStateHandler machine. This is triggered when the db changes.
+ */
+MojErr IMLoginStateHandler::handleLoginStateChange(MojServiceMessage* serviceMsg, const MojObject payload)
+{
+	MojLogTrace(IMServiceApp::s_log);
+
+	m_activityId = -1;
+	// get the $activity object
+	MojObject activityObj;
+	bool found = payload.get("$activity", activityObj);
+	if (found)
+	{
+		found = activityObj.get("activityId", m_activityId);
+	}
+
+	if (!found)
+	{
+		MojLogError(IMServiceApp::s_log, _T("handleLoginStateChange parameter has no activityId"));
+		//TODO No activity, so query the activity manager to see if we've got one. If not, create/start one.
+		// For now, just do the query
+		queryLoginState();
+	}
+	else
+	{
+		adoptActivity();
+	}
+
+	serviceMsg->replySuccess();
+	return MojErrNone;
+}
+
+/*
+ * This is an entry point into the IMLoginStateHandler machine. This is triggered by connection changes
+ */
+MojErr IMLoginStateHandler::handleConnectionChanged(const MojObject payload)
+{
+	MojLogTrace(IMServiceApp::s_log);
+	MojErr err;
+	// Things to check:
+	// + no connection - ensure all logged out
+	// + specific interface dropped - ensure all accounts on that interface are logged off
+	// + wifi is available - log out any accounts on wan so they switch to wifi
+
+	// If there's not internet connection, set all records to offline
+	bool wanConnected = ConnectionState::wanConnected();
+	bool wifiConnected = ConnectionState::wifiConnected();
+	if (!ConnectionState::hasInternetConnection())
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("handleConnectionChanged no connection. setting all accounts offline"));
+		MojDbQuery query; // intentionally empty query since we want all records changed
+		query.from(IM_LOGINSTATE_KIND);
+		MojObject mergeProps;
+		mergeProps.putString("state", LOGIN_STATE_OFFLINE);
+		mergeProps.putString("ipAddress", "");
+		err = m_dbClient.merge(m_ignoreUpdateLoginStateSlot, query, mergeProps);
+
+		// Mark all buddies so they look offline to us
+		MojString empty;
+		empty.assign("");
+		markBuddiesAsOffline(empty);
+
+		// Also tell libpurple to disconnect
+		LibpurpleAdapter::deviceConnectionClosed(true, NULL);
+	}
+	// Two reasons for disconnecting from WAN: it went down or WiFi came up.
+	// WiFi connection is preferred over WAN
+	else if (wanConnected == false || (wanConnected == true && wifiConnected == true))
+	{
+		//NOTE don't need to mark the buddies as offline since we're just switching to WiFi
+
+		MojLogInfo(IMServiceApp::s_log, _T("handleConnectionChanged wan off, but wifi on. setting all wan accounts offline"));
+		MojDbQuery query;
+		query.where("ipAddress", MojDbQuery::OpEq, ConnectionState::wanIpAddress());
+		query.from(IM_LOGINSTATE_KIND);
+		MojObject mergeProps;
+		mergeProps.putString("state", LOGIN_STATE_OFFLINE);
+		mergeProps.putString("ipAddress", "");
+		err = m_dbClient.merge(m_ignoreUpdateLoginStateSlot, query, mergeProps);
+
+		// Also tell libpurple to disconnect
+		LibpurpleAdapter::deviceConnectionClosed(false, ConnectionState::wanIpAddress());
+	}
+	else if (wifiConnected == false)
+	{
+		//NOTE don't need to mark the buddies as offline since we're just switching to WAN
+
+		MojLogInfo(IMServiceApp::s_log, _T("handleConnectionChanged wifi off, setting them offline"));
+		MojDbQuery query;
+		query.where("ipAddress", MojDbQuery::OpEq, ConnectionState::wifiIpAddress());
+		query.from(IM_LOGINSTATE_KIND);
+		MojObject mergeProps;
+		mergeProps.putString("state", LOGIN_STATE_OFFLINE);
+		mergeProps.putString("ipAddress", "");
+		err = m_dbClient.merge(m_ignoreUpdateLoginStateSlot, query, mergeProps);
+
+		// Also tell libpurple to disconnect
+		LibpurpleAdapter::deviceConnectionClosed(false, ConnectionState::wifiIpAddress());
+	}
+
+	return MojErrNone;
+}
+
+MojErr IMLoginStateHandler::activityAdoptResult(MojObject& payload, MojErr resultErr)
+{
+	MojLogTrace(IMServiceApp::s_log);
+
+	if (resultErr != MojErrNone)
+	{
+		// adopt failed
+		MojString error;
+		MojErrToString(resultErr, error);
+		MojLogError(IMServiceApp::s_log, _T("activity manager adopt FAILED. error %d - %s"), resultErr, error.data());
+	}
+	else
+	{
+		//IMServiceHandler::logMojObjectJsonString(_T("activityAdoptResult payload: %s"), payload);
+		bool adopted = false;
+		payload.get("adopted", adopted); //TODO: check for "orphan"?
+
+		// we currently get 2 notifications from the adopt call. ignore the first one
+		if (adopted)
+		{
+			MojLogInfo(IMServiceApp::s_log, _T("Activity adopted. Querying Login State"));
+			queryLoginState();
+		}
+	}
+
+	return MojErrNone;
+}
+
+MojErr IMLoginStateHandler::activityCompleteResult(MojObject& payload, MojErr resultErr)
+{
+	//TODO: log if there are errors
+	m_activityAdoptSlot.cancel();
+	//setWatch();
+	return MojErrNone;
+}
+
+MojErr IMLoginStateHandler::setWatchResult(MojObject& payload, MojErr resultErr)
+{
+	//TODO: log if there are errors
+	return MojErrNone;
+}
+
+MojErr IMLoginStateHandler::loginStateQueryResult(MojObject& payload, MojErr resultErr)
+{
+	MojLogTrace(IMServiceApp::s_log);
+
+	if (resultErr != MojErrNone)
+	{
+		MojString error;
+		MojErrToString(resultErr, error);
+		MojLogError(IMServiceApp::s_log, _T("loginStateQuery failed. error %d - %s"), resultErr, error.data());
+	}
+	else
+	{
+		IMServiceHandler::logMojObjectJsonString(_T("loginStateQuery success: %s"), payload);
+		// result is in the form {results:[{_id, _rev, username, serviceName, state, availability, customMessage}]}
+		MojObject results;
+		payload.get("results", results);
+
+		processLoginStates(results);
+	}
+
+	return MojErrNone;
+}
+
+
+MojErr IMLoginStateHandler::updateLoginStateResult(MojObject& payload, MojErr resultErr)
+{
+	// DB state is updated so complete the activity and reset the watch so it
+	// can fire again and start the next state transition
+	completeAndResetWatch();
+	return MojErrNone;
+}
+
+MojErr IMLoginStateHandler::ignoreUpdateLoginStateResult(MojObject& payload, MojErr resultErr)
+{
+	// This is for intermediate changes to login state (like "logging in") so the result
+	// is not actionable.
+	if (resultErr != MojErrNone)
+	{
+		MojString error;
+		MojErrToString(resultErr, error);
+		MojLogError(IMServiceApp::s_log, _T("ERROR Intermediate UpdateLoginState. error %d - %s"), resultErr, error.data());
+	}
+	return MojErrNone;
+}
+
+// Set the state & availability to offline and set errorCode
+// dbmerge will then complete and reset the activity
+MojErr IMLoginStateHandler::handleBadCredentials(const MojString& serviceName, const MojString& username, const char* err)
+{
+	MojDbQuery query;
+	query.where("serviceName", MojDbQuery::OpEq, serviceName);
+	query.where("username", MojDbQuery::OpEq, username);
+	query.from(IM_LOGINSTATE_KIND);
+	MojObject mergeProps;
+	mergeProps.putInt("availability", PalmAvailability::OFFLINE);
+	mergeProps.putString("state", LOGIN_STATE_OFFLINE);
+	mergeProps.putString("ipAddress", "");
+	if (err != NULL)
+	{
+		mergeProps.putString("errorCode", err);
+	}
+	m_dbClient.merge(m_updateLoginStateSlot, query, mergeProps);
+
+	// update the syncState record for this account so account dashboard can display errors
+	// first we need to find our account id
+	LoginStateData state;
+	MojString accountId, service, user;
+	service.assign(serviceName);
+	user.assign(username);
+	bool found = m_loginStateController->getLoginStateData(service, user, state);
+	if (found) {
+		accountId = state.getAccountId();
+		MojRefCountedPtr<IMLoginSyncStateHandler> syncStateHandler(new IMLoginSyncStateHandler(m_service));
+		syncStateHandler->updateSyncStateRecord(serviceName, accountId, LoginCallbackInterface::LOGIN_FAILED, err);
+	}
+	else {
+		MojLogError(IMServiceApp::s_log, _T("loginResult: could not find account Id in cached login states map. No syncState record created."));
+		// can we do anything here??
+	}
+
+	return MojErrNone;
+}
+
+MojErr IMLoginStateHandler::getCredentialsResult(MojObject& payload, MojErr resultErr)
+{
+	MojLogError(IMServiceApp::s_log, _T("getCredentialsResult:  wanConnected:%d  wifiConnected:%d"),ConnectionState::wanConnected(),ConnectionState::wifiConnected());
+	if (resultErr != MojErrNone)
+	{
+		// Failed to get credentials, so log the issue and set the state to offlnie
+		MojString serviceName = m_workingLoginState.getServiceName();
+		MojString username = m_workingLoginState.getUsername();
+
+		MojString error;
+		MojErrToString(resultErr, error);
+		MojLogError(IMServiceApp::s_log, _T("Failed to get credentials on %s. error %d - %s"), serviceName.data(), resultErr, error.data());
+
+		handleBadCredentials(serviceName, username, ERROR_BAD_PASSWORD);
+	}
+	// About to login so this is the time to make a final check for internet connection
+	else if (!ConnectionState::hasInternetConnection())
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("No internet connection available!"));
+		// No internet so mark this activity complete and reset the watch
+		// which will fire next time there's a stable connection
+		completeAndResetWatch();
+	}
+	else
+	{
+		//TODO: get rid of m_workingLoginState: what in the credentials response can tie it back to its corresponding m_loginState?
+		
+		// Now get the login params and request login
+		MojObject credentials;
+		MojErr err = payload.getRequired("credentials", credentials);
+
+		LoginParams loginParams;
+		MojString password;
+		err = credentials.getRequired("password", password);
+		if (password.empty())
+		{
+			MojLogError(IMServiceApp::s_log, _T("Password is empty. I think this is not ok."));
+		}
+
+		MojString serviceName = m_workingLoginState.getServiceName();
+		MojString username = m_workingLoginState.getUsername();
+
+		MojString connectionType, localIpAddress;
+		ConnectionState::getBestConnection(connectionType, localIpAddress);
+		// We're about to log in, so set the state to "logging in"
+		updateLoginStateNoResponse(serviceName, username, LOGIN_STATE_LOGGING_ON, localIpAddress.data());
+
+		loginParams.password = password.data();
+		loginParams.accountId = m_workingLoginState.getAccountId().data();
+		loginParams.username = username.data();
+		loginParams.serviceName = serviceName.data();
+		loginParams.availability = m_workingLoginState.getAvailability();
+		loginParams.customMessage = m_workingLoginState.getCustomMessage();
+		loginParams.connectionType = connectionType.data();
+		loginParams.localIpAddress = localIpAddress.data();
+
+		// Login may be asynchronous with the result callback in loginResult().
+		// Also deal with immediate results
+		LibpurpleAdapter::LoginResult result;
+		result = LibpurpleAdapter::login(&loginParams, m_loginStateController);
+		if (result == LibpurpleAdapter::FAILED)
+		{
+			handleBadCredentials(serviceName, username, ERROR_GENERIC_ERROR);
+		}
+		if (result == LibpurpleAdapter::INVALID_CREDENTIALS)
+		{
+			handleBadCredentials(serviceName, username, ERROR_AUTHENTICATION_FAILED);
+		}
+		else if (result == LibpurpleAdapter::ALREADY_LOGGED_IN)
+		{
+			MojDbQuery query;
+			query.where("serviceName", MojDbQuery::OpEq, serviceName);
+			query.where("username", MojDbQuery::OpEq, username);
+			query.from(IM_LOGINSTATE_KIND);
+			MojObject mergeProps;
+			mergeProps.putString("state", LOGIN_STATE_ONLINE);
+			mergeProps.putString("ipAddress", localIpAddress);
+			m_dbClient.merge(m_updateLoginStateSlot, query, mergeProps);
+
+			// update any imcommands that are in the "waiting-for-connection" status
+			moveWaitingCommandsToPending();
+		}
+	}
+	return MojErrNone;
+}
+
+
+MojErr IMLoginStateHandler::queryForContactsResult(MojObject& payload, MojErr resultErr)
+{
+	if (m_buddyListConsolidator == NULL)
+	{
+		MojLogError(IMServiceApp::s_log, _T("m_buddyListConsolidator is null on contact response"));
+		//TODO what to do here???
+	}
+	else
+	{
+		MojObject contactArray;
+		payload.getRequired("results", contactArray);
+		m_buddyListConsolidator->setContacts(contactArray);
+		if (m_buddyListConsolidator->isAllDataSet())
+		{
+			consolidateAllBuddyLists();
+		}
+	}
+	return MojErrNone;
+}
+
+
+MojErr IMLoginStateHandler::queryForBuddyStatusResult(MojObject& payload, MojErr resultErr)
+{
+	if (m_buddyListConsolidator == NULL)
+	{
+		MojLogError(IMServiceApp::s_log, _T("m_buddyListConsolidator is null on buddystatus response"));
+		//TODO what to do here???
+	}
+	else
+	{
+		MojObject buddyArray;
+		payload.getRequired("results", buddyArray);
+		m_buddyListConsolidator->setBuddyStatus(buddyArray);
+		if (m_buddyListConsolidator->isAllDataSet())
+		{
+			consolidateAllBuddyLists();
+		}
+	}
+	return MojErrNone;
+}
+
+
+MojErr IMLoginStateHandler::markBuddiesAsOffline(const MojString& serviceName, const MojString& username)
+{
+	MojErr err = MojErrNotFound;
+	LoginStateData state;
+	bool found = m_loginStateController->getLoginStateData(serviceName, username, state);
+	if (found)
+	{
+		err = markBuddiesAsOffline(state.getAccountId());
+	}
+	return err;
+}
+
+
+MojErr IMLoginStateHandler::markBuddiesAsOffline(const MojString& accountId)
+{
+	//MojLogInfo(IMServiceApp::s_log, _T("IMLoginStateHandler::markBuddiesAsOffline account=%s"), accountId.data());
+	// All buddies for this account get marked as offline
+	MojDbQuery query;
+	if (accountId.length() > 0)
+	{
+		query.where("accountId", MojDbQuery::OpEq, accountId);
+	}
+	else
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("markBuddiesAsOffline: no accountId - marking all buddies offline"));
+	}
+
+	query.from(IM_BUDDYSTATUS_KIND);
+	MojObject mergeProps;
+	mergeProps.putInt("availability", PalmAvailability::OFFLINE);
+	mergeProps.putString("status", "");
+	return m_tempdbClient.merge(m_markBuddiesAsOfflineSlot, query, mergeProps);
+}
+
+
+MojErr IMLoginStateHandler::markBuddiesAsOfflineResult(MojObject& payload, MojErr resultErr)
+{
+	// TODO: anything to do here???
+	return MojErrNone;
+}
+
+
+MojErr IMLoginStateHandler::moveWaitingMessagesToPending(const MojString& serviceName, const MojString& username)
+{
+	//MojLogInfo(IMServiceApp::s_log, _T("IMLoginStateHandler::moveWaitingMessagesToPending"));
+	MojDbQuery query;
+	MojString folderName, statusName;
+	folderName.assign(IMMessage::folderStrings[Outbox]);
+	query.where(MOJDB_FOLDER, MojDbQuery::OpEq, folderName);
+	statusName.assign(IMMessage::statusStrings[WaitingForConnection]);
+	query.where(MOJDB_STATUS, MojDbQuery::OpEq, statusName);
+
+	query.from(IM_IMMESSAGE_KIND);
+	MojObject mergeProps;
+	mergeProps.putString(MOJDB_STATUS, IMMessage::statusStrings[Pending]);
+	return m_dbClient.merge(m_moveMessagesToPendingSlot, query, mergeProps);
+}
+
+
+MojErr IMLoginStateHandler::moveMessagesToPendingResult(MojObject& payload, MojErr resultErr)
+{
+	return MojErrNone;
+}
+
+/*
+ * Find any imcommands that were left in the "waiting-for-connection" status and make them pending now that we are back online
+ */
+MojErr IMLoginStateHandler::moveWaitingCommandsToPending()
+{
+	MojLogInfo(IMServiceApp::s_log, _T("IMLoginStateHandler::moveWaitingCommandsToPending"));
+	MojDbQuery query;
+	MojString statusName;
+	statusName.assign(IMMessage::statusStrings[WaitingForConnection]);
+	query.where(MOJDB_STATUS, MojDbQuery::OpEq, statusName);
+
+	query.from(IM_IMCOMMAND_KIND);
+	MojObject mergeProps;
+	mergeProps.putString(MOJDB_STATUS, IMMessage::statusStrings[Pending]);
+	return m_dbClient.merge(m_moveCommandsToPendingSlot, query, mergeProps);
+}
+
+
+MojErr IMLoginStateHandler::moveCommandsToPendingResult(MojObject& payload, MojErr resultErr)
+{
+	return MojErrNone;
+}
+
+
+MojErr IMLoginStateHandler::queryLoginState()
+{
+	MojRefCountedPtr<MojServiceRequest> req;
+	MojErr err = m_service->createRequest(req);
+	if (err)
+	{
+		MojLogError(IMServiceApp::s_log, _T("IMLoginStateHandler: create activity manager adopt request failed"));
+	}
+	else
+	{
+		MojDbQuery query;
+		getLoginStateQuery(query);
+		err = m_dbClient.find(m_loginStateQuerySlot, query, false, false);
+		if (err)
+		{
+			MojLogError(IMServiceApp::s_log, _T("handleLoginStateChange query failed"));
+		}
+	}
+
+	return err;
+}
+
+
+void IMLoginStateHandler::logLoginStates(const LoginStateData& cachedState, const LoginStateData& newState)
+{
+	MojString stateString;
+	cachedState.toString(stateString);
+	//MojLogInfo(IMServiceApp::s_log, _T("cachedState: %s"), stateString.data());
+	newState.toString(stateString);
+	//MojLogInfo(IMServiceApp::s_log, _T("newState:    %s"), stateString.data());
+}
+
+
+// resultArray should be an array of db objects of the form
+// {_id, _rev, username, serviceName, state, availability, customMessage}
+MojErr IMLoginStateHandler::processLoginStates(MojObject& loginStateArray)
+{
+	MojErr err = MojErrNone;
+
+	MojObject loginStateEntry;
+	MojObject::ConstArrayIterator loginStateItr = loginStateArray.arrayBegin();
+	// This shouldn't happen, but check if there's nothing to do.
+	if (loginStateItr == loginStateArray.arrayEnd())
+	{
+		MojLogError(IMServiceApp::s_log, _T("processLoginStates had empty result set"));
+		completeAndResetWatch();
+	}
+	else
+	{
+		// Just grab the first change and deal with it. If other records have changed, we'll
+		// pick that up when the watch is reset. This works because the query is on _rev in
+		// ascending order.
+		loginStateEntry = *loginStateItr;
+		LoginStateData newState;
+		newState.assignFromDbRecord(loginStateEntry);
+
+		// Update the revision number so this change is removed from the next query.
+		m_loginStateController->setLoginStateRevision(newState.getRevision());
+		//m_loginStateRevision = newState.getRevision();
+
+		LoginStateData cachedState;
+		bool found = m_loginStateController->getLoginStateData(newState.getKey(), cachedState);
+		if (!found)
+		{
+			// Key not found, so assign the new state to the cached state and
+			// let it proceed as normal for login (most likely) or logout
+			cachedState = newState;
+		}
+
+		logLoginStates(cachedState, newState);
+		m_workingLoginState = newState;
+		if (newState.needsToLogin(cachedState))
+		{
+			// Get account info & password then start the login process.
+			bool found = false;
+			MojString accountId;
+			err = loginStateEntry.get("accountId", accountId, found);
+			if (err != MojErrNone || !found)
+			{
+				MojString error;
+				MojErrToString(err, error);
+				MojLogError(IMServiceApp::s_log, _T("ERROR accountId missing from imloginstate. error %d - %s"), err, error.data());
+				// TODO: fail the record and ...
+				completeAndResetWatch();
+			}
+			else
+			{
+				MojRefCountedPtr<MojServiceRequest> req;
+				err = m_service->createRequest(req);
+				MojObject params;
+				err = params.put("accountId", accountId);
+				err = params.putString("name", "common");
+				err = req->send(m_getCredentialsSlot, "com.palm.service.accounts","readCredentials", params, 1);
+			}
+		}
+		else if (newState.needsToLogoff(cachedState))
+		{
+			// Now log out. The result will come in loginResult() with type=SIGNED_OFF
+			if (LibpurpleAdapter::logout(newState.getServiceName(), newState.getUsername(), m_loginStateController))
+			{
+				// Update state to show we're in the process of logging off
+				updateLoginStateNoResponse(newState.getServiceName(), newState.getUsername(), LOGIN_STATE_LOGGING_OFF, NULL);
+			}
+			else
+			{
+				// Logout returns false if the account is already logged out.
+				// TODO: update newState to offline to reflect the changed state
+				updateLoginStateNoResponse(newState.getServiceName(), newState.getUsername(), LOGIN_STATE_OFFLINE, NULL);
+				// Make the buddies for this account look offline to us
+				markBuddiesAsOffline(newState.getAccountId());
+				completeAndResetWatch();
+			}
+		}
+		else if (newState.needsToGetBuddies(cachedState))
+		{
+			getBuddyLists(newState.getServiceName(), newState.getUsername(), newState.getAccountId());
+		}
+		else if (newState.hasAvailabilityChanged(cachedState) || newState.hasCustomMessageChanged(cachedState))
+		{
+			if (newState.hasAvailabilityChanged(cachedState))
+			{
+				LibpurpleAdapter::setMyAvailability(newState.getServiceName().data(), newState.getUsername().data(), newState.getAvailability());
+			}
+
+			if (newState.hasCustomMessageChanged(cachedState))
+			{
+				LibpurpleAdapter::setMyCustomMessage(newState.getServiceName().data(), newState.getUsername().data(), newState.getCustomMessage().data());
+			}
+
+			completeAndResetWatch();
+		}
+		else
+		{
+			// Nothing needed to be done so just reset the watch.
+			completeAndResetWatch();
+		}
+
+		// Finally, add or update the cached entry to reflect whatever changed
+		m_loginStateController->putLoginStateData(newState.getKey(), newState);
+	}
+	return err;
+}
+
+
+// This fires off 3 asynchronous requests with the responses being stored in m_buddyListConsolidator
+// So whichever of the 3 returns last will continue the buddy list processing
+MojErr IMLoginStateHandler::getBuddyLists(const MojString& serviceName, const MojString& username, const MojString& accountId)
+{
+	m_buddyListConsolidator = new BuddyListConsolidator(m_service, accountId);
+
+	// Get a full list of buddies. The result is asynchronously returned via the buddyListResult() callback
+	bool ok = LibpurpleAdapter::getFullBuddyList(serviceName, username);
+	if (ok)
+	{
+		//TODO move these two slots into BuddyListConsolidator??
+		MojErr err;
+
+		// Get contacts that are buddies of this user
+		MojDbQuery contactsQuery;
+		contactsQuery.from(IM_CONTACT_KIND);
+		contactsQuery.where("accountId", MojDbQuery::OpEq, accountId);
+		err = m_dbClient.find(m_queryForContactsSlot, contactsQuery, false, false);
+		if (err)
+		    MojLogError(IMServiceApp::s_log, _T("getBuddyLists: query for contacts returned err: %d"),err);
+
+		// Get buddies of this user
+		MojDbQuery buddiesQuery;
+		buddiesQuery.from(IM_BUDDYSTATUS_KIND);
+		buddiesQuery.where("accountId", MojDbQuery::OpEq, accountId);
+		err = m_tempdbClient.find(m_queryForBuddyStatusSlot, buddiesQuery, false, false);
+		if (err)
+			MojLogError(IMServiceApp::s_log, _T("getBuddyLists: query for buddies returned err: %d"),err);
+	}
+	else
+	{
+		//TODO: set the state to offline?? Perhaps loginstate needs a retry count.
+		MojLogError(IMServiceApp::s_log, _T("getBuddyLists: getFullBuddyList return false. This is not good"));
+
+		delete m_buddyListConsolidator;
+		m_buddyListConsolidator = NULL;
+
+
+		// Since it failed, we need to reset the watch ourself.
+		completeAndResetWatch();
+	}
+
+	return MojErrNone;
+}
+
+MojErr IMLoginStateHandler::consolidateAllBuddyLists()
+{
+	if (m_buddyListConsolidator == NULL)
+	{
+		MojLogError(IMServiceApp::s_log, _T("m_buddyListConsolidator is null in consolidateBuddyLists(). This shouldn't be possible"));
+		//TODO what to do here???
+	}
+	else
+	{
+		m_buddyListConsolidator->consolidateContacts();
+		m_buddyListConsolidator->consolidateBuddyStatus();
+		// The consolidator cleans itself up. Good kitty.
+		m_buddyListConsolidator = NULL;
+	}
+
+	// The user is online at this point despite any errors in buddy consolidation
+
+	// update any imcommands that are in the "waiting-for-connection" status
+	moveWaitingCommandsToPending();
+
+	MojString serviceName = m_workingLoginState.getServiceName();
+	MojString username = m_workingLoginState.getUsername();
+	MojDbQuery query;
+	query.where("serviceName", MojDbQuery::OpEq, serviceName);
+	query.where("username", MojDbQuery::OpEq, username);
+	query.from(IM_LOGINSTATE_KIND);
+	MojObject mergeProps;
+	mergeProps.putString("state", LOGIN_STATE_ONLINE);
+	return m_dbClient.merge(m_updateLoginStateSlot, query, mergeProps);
+}
+
+MojErr IMLoginStateHandler::adoptActivity()
+{
+	MojLogInfo(IMServiceApp::s_log, _T("Adopting activityId: %llu."), m_activityId);
+	MojErr err = MojErrNone;
+	if (m_activityId > 0)
+	{
+		MojRefCountedPtr<MojServiceRequest> req;
+		MojErr err = m_service->createRequest(req);
+		if (err)
+		{
+			MojLogError(IMServiceApp::s_log, _T("IMLoginStateHandler: create activity manager adopt request failed"));
+		}
+		else
+		{
+			MojObject adoptParams;
+			adoptParams.put(_T("activityId"), m_activityId);
+			adoptParams.putBool(_T("subscribe"), true);
+
+
+
+			MojLogInfo(IMServiceApp::s_log, _T("handleLoginStateChange adopting activity id: %llu."), m_activityId);
+			err = req->send(m_activityAdoptSlot, "com.palm.activitymanager", "adopt", adoptParams, MojServiceRequest::Unlimited);
+			if (err)
+			{
+				MojLogError(IMServiceApp::s_log, _T("IMLoginStateHandler::adoptActivity send activity manager adopt request failed"));
+			}
+		}
+	}
+
+	return err;
+}
+
+
+MojErr IMLoginStateHandler::completeAndResetWatch()
+{
+	//MojLogInfo(IMServiceApp::s_log, _T("Completing activityId: %llu."), m_activityId);
+	MojErr err = MojErrNone;
+
+	// If there is an active activity, mark it as completed with the "restart" flag
+	if (m_activityId > 0)
+	{
+		MojRefCountedPtr<MojServiceRequest> completeReq;
+		MojErr err = m_service->createRequest(completeReq);
+		MojErrCheck(err);
+		MojObject completeParams;
+		completeParams.put(_T("activityId"), m_activityId);
+		completeParams.put(_T("restart"), true); // Important, we need the activity to restart
+
+		// Build out the actvity's trigger
+		const char* triggerJson =
+				"{\"key\":\"fired\","
+				"\"method\":\"palm://com.palm.db/watch\","
+				"}";
+		MojObject trigger;
+		trigger.fromJson(triggerJson);
+		MojDbQuery dbQuery;
+		getLoginStateQuery(dbQuery);
+		MojObject queryDetails;
+		dbQuery.toObject(queryDetails);
+		MojObject query;
+		query.put("query", queryDetails);
+		trigger.put("params", query);
+
+		completeParams.put("trigger", trigger);
+
+		err = completeReq->send(m_activityCompleteSlot, "com.palm.activitymanager", "complete", completeParams, 1);
+		MojErrCheck(err);
+
+		m_activityId = -1; // clear this out so we don't keep using it.
+	}
+	else
+	{
+		MojLogError(IMServiceApp::s_log, _T("completeAndResetWatch - no activity id to complete"));
+//		setWatch();
+	}
+
+	return err;
+}
+
+/*
+ * NOT USED
+ */
+//MojErr IMLoginStateHandler::setWatch()
+//{
+//	MojLogError(IMServiceApp::s_log, _T("setWatch 1"));
+//	MojLogInfo(IMServiceApp::s_log, _T("Starting new loginstate watch"));
+//	MojErr err = MojErrNone;
+//
+//	// Reset the activity watch
+//	MojRefCountedPtr<MojServiceRequest> watchReq;
+//	err = m_service->createRequest(watchReq);
+//	MojErrCheck(err);
+//	MojLogDebug(IMServiceApp::s_log, _T("com.palm.activitymanager/create"));
+//
+//	MojLogError(IMServiceApp::s_log, _T("setWatch 2"));
+//	// A lot of the activity object is static data, so fill that in using hardcoded strings, then add the "trigger"
+//	// Properties within the "activity" object
+//
+//	// Build out the actvity's trigger
+//	const char* triggerJson =
+//			"{\"key\":\"fired\","
+//			"\"method\":\"palm://com.palm.db/watch\","
+//			"}";
+//	MojObject trigger;
+//	trigger.fromJson(triggerJson);
+//	MojDbQuery dbQuery;
+//	getLoginStateQuery(dbQuery);
+//	MojObject queryDetails;
+//	dbQuery.toObject(queryDetails);
+//	MojObject query;
+//	query.put("query", queryDetails);
+//	trigger.put("params", query);
+//
+//	// Build out the activity
+//	const char* activityJson =
+//			"{\"name\":\"Libpurple loginstate\","
+//			"\"description\":\"Watch for changes to the imloginstate\","
+//			"\"type\": {\"foreground\": true},"
+//			"\"callback\":{\"method\":\"palm://com.palm.imlibpurple/loginStateChanged\"}"
+//			"}";
+//	MojObject activity;
+//	activity.fromJson(activityJson);
+//	activity.put("trigger", trigger);
+//
+//	// requirements for internet:true
+//	MojObject requirements;
+//	err = requirements.put("internet", true);
+//	MojErrCheck(err);
+//	err = activity.put("requirements", requirements);
+//	MojErrCheck(err);
+//
+//	MojObject activityCreateParams;
+//	activityCreateParams.putBool("start", true);
+//	activityCreateParams.put("activity", activity);
+//	//TODO should this be Unlimited or just one-off???
+//	err = watchReq->send(m_setWatchSlot, "com.palm.activitymanager", "create", activityCreateParams, MojServiceRequest::Unlimited);
+//	MojErrCheck(err);
+//
+//	return err;
+//}
+
+
+// This is a callback from the LibpurpleAdapter for notification of login events (success, failed, disconnected)
+void IMLoginStateHandler::loginResult(const char* serviceName, const char* username, LoginCallbackInterface::LoginResult type, bool loggedOut, const char* errCode, bool noRetry)
+{
+	MojErr err = MojErrNone;
+	MojLogInfo(IMServiceApp::s_log, _T("loginResult: user %s, service %s, result=%d, code=%s, loggedOut=%d, noRetry=%d."), username, serviceName, type, errCode, loggedOut, noRetry);
+
+	MojString serviceNameMoj, usernameMoj, errorCodeMoj;
+	if (errCode == NULL)
+	{
+		// If no error code was specified, assume no error
+		errorCodeMoj.assign(ERROR_NO_ERROR);
+	}
+	else
+	{
+		errorCodeMoj.assign(errCode);
+	}
+
+	// Want to merge the new state and errorCode values for the given username and serviceName
+	MojDbQuery query;
+	serviceNameMoj.assign(serviceName);
+	usernameMoj.assign(username);
+	query.where("serviceName", MojDbQuery::OpEq, serviceNameMoj);
+	query.where("username", MojDbQuery::OpEq, usernameMoj);
+	query.from(IM_LOGINSTATE_KIND);
+
+	MojObject mergeProps;
+	if (noRetry)
+	{
+		if (type == LoginCallbackInterface::LOGIN_SUCCESS)
+		{
+			MojLogWarning(IMServiceApp::s_log, _T("loginResult WARNING: ignoring noRetry==true because type==login_success"));
+		}
+		else
+		{
+			mergeProps.putInt("availability", PalmAvailability::OFFLINE);
+		}
+	}
+
+	// Special case to handle getting logged off because of lost network connection.
+	// There's a race condition where the login fails before the network manager
+	// admits the connection is lost so the following prevents it from immediately
+	// logging off which then triggers the db watch, causing a login to start and
+	// quickly get stopped.
+	if (type == LoginCallbackInterface::LOGIN_FAILED && noRetry == false)
+	{
+		IMLoginFailRetryHandler* handler = new IMLoginFailRetryHandler(m_service);
+		mergeProps.putString("state", LOGIN_STATE_OFFLINE);
+		mergeProps.put("errorCode", errorCodeMoj);
+		handler->startTimerActivity(serviceNameMoj, query, mergeProps);
+	}
+	else
+	{
+		switch (type)
+		{
+		case LoginCallbackInterface::LOGIN_SUCCESS:
+			mergeProps.putString("state", LOGIN_STATE_GETTING_BUDDIES);
+			mergeProps.put("errorCode", errorCodeMoj);
+			// Since the login succeeded, move any waiting messages back to pending
+			moveWaitingMessagesToPending(serviceNameMoj, usernameMoj);
+			break;
+		case LoginCallbackInterface::LOGIN_SIGNED_OFF:
+		case LoginCallbackInterface::LOGIN_FAILED:
+		case LoginCallbackInterface::LOGIN_TIMEOUT:
+			mergeProps.putString("state", LOGIN_STATE_OFFLINE);
+			mergeProps.put("errorCode", errorCodeMoj);
+			// Make the buddies for this account look offline to us
+			markBuddiesAsOffline(serviceNameMoj, usernameMoj);
+			break;
+		}
+		err = m_dbClient.merge(m_updateLoginStateSlot, query, mergeProps);
+	}
+
+	// update the syncState record for this account so account dashboard can display errors
+	// first we need to find our account id
+	LoginStateData state;
+	MojString accountId, service, user;
+	service.assign(serviceName);
+	user.assign(username);
+	bool found = m_loginStateController->getLoginStateData(service, user, state);
+	if (found) {
+		accountId = state.getAccountId();
+		MojRefCountedPtr<IMLoginSyncStateHandler> syncStateHandler(new IMLoginSyncStateHandler(m_service));
+		syncStateHandler->updateSyncStateRecord(serviceName, accountId, type, errorCodeMoj);
+	}
+	else {
+		MojLogError(IMServiceApp::s_log, _T("loginResult: could not find account Id in cached login states map. No syncState record created."));
+		// can we do anything here??
+	}
+
+}
+
+
+// This is a callback from the LibpurpleAdapter for notification of buddyList changes
+void IMLoginStateHandler::fullBuddyListResult(const char* serviceName, const char* username, MojObject& buddyList)
+{
+
+	//TODO: Update com.palm.imbuddystatus (maybe just delete all and add all new)
+	if (m_buddyListConsolidator == NULL)
+	{
+		MojLogError(IMServiceApp::s_log, _T("m_buddyListConsolidator is null on fullBuddyListResult"));
+		//TODO what to do here???
+	}
+	else
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("fullBuddyListResult: setting new buddy list"));
+		m_buddyListConsolidator->setNewBuddyList(buddyList);
+		if (m_buddyListConsolidator->isAllDataSet())
+		{
+			consolidateAllBuddyLists();
+		}
+	}
+}
+
+
+MojErr IMLoginStateHandler::getLoginStateQuery(MojDbQuery& query)
+{
+	query.from(IM_LOGINSTATE_KIND);
+	query.where("_rev", MojDbQuery::OpGreaterThan, m_workingLoginStateRev);
+	MojObject queryObj;
+	query.toObject(queryObj);
+	IMServiceHandler::logMojObjectJsonString(_T("getLoginStateQuery: %s"), queryObj);
+	return MojErrNone;
+}
+
+
+MojErr IMLoginStateHandler::updateLoginStateNoResponse(const MojString& serviceName, const MojString& username, const char* state, const char* ipAddress)
+{
+	MojDbQuery query;
+	query.where("serviceName", MojDbQuery::OpEq, serviceName);
+	query.where("username", MojDbQuery::OpEq, username);
+	query.from(IM_LOGINSTATE_KIND);
+	MojObject mergeProps;
+	mergeProps.putString("state", state);
+	if (ipAddress != NULL)
+	{
+		mergeProps.putString("ipAddress", ipAddress);
+	}
+	return m_dbClient.merge(m_ignoreUpdateLoginStateSlot, query, mergeProps);
+}
+
+
+/*
+ * IMLoginState::LoginStateData
+ */
+MojErr LoginStateData::assignFromDbRecord(MojObject& record)
+{
+	MojErr err = MojErrNone;
+	bool found = false;
+
+	err = record.get("_id", m_recordId, found);
+	if (err != MojErrNone || found == false)
+	{
+		MojLogError(IMServiceApp::s_log, _T("LoginStateData::getFromDbRecord missing _id."));
+		return err;
+	}
+
+	err = record.get("_rev", m_revision, found);
+	if (err != MojErrNone || found == false)
+	{
+		MojLogError(IMServiceApp::s_log, _T("LoginStateData::getFromDbRecord missing _rev. err=%u"), err);
+		return err;
+	}
+
+	record.get("username", m_username, found);
+	record.get("accountId", m_accountId, found);
+	record.get("serviceName", m_serviceName, found);
+	err = record.get("state", m_state, found);	
+	if (err != MojErrNone || found == false)
+	{
+		MojLogError(IMServiceApp::s_log, _T("LoginStateData::getFromDbRecord missing state, assuming offline."));
+		m_state.assign(LOGIN_STATE_OFFLINE);
+	}
+
+	// This may legitimately be missing
+	record.get("customMessage", m_customMessage, found);
+
+	err = record.get("availability", m_availability, found);
+	if (err != MojErrNone || found == false)
+	{
+		MojLogError(IMServiceApp::s_log, _T("LoginStateData::getFromDbRecord missing availability, assuming offline."));
+		m_availability = PalmAvailability::OFFLINE;
+	}
+	return err;
+}
+
+bool LoginStateData::needsToLogin(LoginStateData& oldState)
+{
+	return (m_state == LOGIN_STATE_OFFLINE && m_availability != PalmAvailability::OFFLINE && m_availability != PalmAvailability::NO_PRESENCE);
+}
+
+bool LoginStateData::needsToGetBuddies(LoginStateData& oldState)
+{
+	return (m_state == LOGIN_STATE_GETTING_BUDDIES && m_availability != PalmAvailability::OFFLINE && m_availability != PalmAvailability::NO_PRESENCE && (oldState.m_state == LOGIN_STATE_OFFLINE || oldState.m_state == LOGIN_STATE_LOGGING_ON));
+}
+
+bool LoginStateData::needsToLogoff(LoginStateData& oldState)
+{
+	return (m_state != LOGIN_STATE_OFFLINE && m_availability == PalmAvailability::OFFLINE);
+}
+
+bool LoginStateData::hasAvailabilityChanged(LoginStateData& oldState)
+{
+	return (m_availability != oldState.m_availability);
+}
+
+bool LoginStateData::hasCustomMessageChanged(LoginStateData& newState)
+{
+	return (m_customMessage != newState.m_customMessage);
+}
+
+
+/*
+ * IMLoginFailRetryHandler -- signal handler
+ */
+IMLoginFailRetryHandler::IMLoginFailRetryHandler(MojService* service)
+: m_activitySubscriptionSlot(this, &IMLoginFailRetryHandler::activitySubscriptionResult),
+  m_dbmergeSlot(this, &IMLoginFailRetryHandler::dbmergeResult),
+  m_activityCompleteSlot(this, &IMLoginFailRetryHandler::activityCompleteResult),
+  m_service(service),
+  m_dbClient(service, MojDbServiceDefs::ServiceName),
+  m_tempdbClient(service, MojDbServiceDefs::TempServiceName),
+  m_activityId(-1)
+{
+}
+
+MojErr IMLoginFailRetryHandler::startTimerActivity(const MojString& serviceName, const MojDbQuery& query, const MojObject& mergeProps)
+{
+	//MojLogError(IMServiceApp::s_log, _T("**********IMLoginFailRetryHandler::startTimerActivity"));
+	MojRefCountedPtr<MojServiceRequest> req;
+	MojErr err = m_service->createRequest(req);
+	if (err != MojErrNone)
+	{
+		MojLogError(IMServiceApp::s_log, _T("IMLoginFailRetryHandler createRequest failed. error %d"), err);
+	}
+	else
+	{
+		m_query = query;
+		m_mergeProps = mergeProps;
+		// This is what the activity looks like
+		// {
+		//  "name":"Set IMLoginState Offline " + serviceName,
+		//  "description":"Scheduled request to mark the service as offline",
+		//  "type":{"foreground":true},
+		//  "schedule":{
+		//      "start":<current date/time> + 2s,
+		//  }
+		// }
+		// activity
+		MojObject activity;
+		MojString activityName;
+		activityName.assign(_T("Set IMLoginState Offline "));
+		activityName.append(serviceName);
+		activity.putString("name", activityName);
+		activity.putString("description", _T("Scheduled request to mark the service as offline"));
+
+		// activity.type
+		MojObject activityType;
+		activityType.putBool("foreground", true);
+		activity.put("type", activityType);
+
+		// activity.schedule
+		time_t targetDate;
+		time(&targetDate);
+		targetDate += 2; // schedule for 2 seconds in the future
+		tm* ptm = gmtime(&targetDate);
+		char scheduleTime[50];
+		sprintf(scheduleTime, "%d-%02d-%02d %02d:%02d:%02dZ", ptm->tm_year+1900, ptm->tm_mon+1, ptm->tm_mday, ptm->tm_hour, ptm->tm_min, ptm->tm_sec);
+		MojLogDebug(IMServiceApp::s_log, _T("IMLoginFailRetryHandler: com.palm.activitymanager/create date=%s"), scheduleTime);
+		MojObject scheduleObj;
+		scheduleObj.putString("start", scheduleTime);
+		activity.put("schedule", scheduleObj);
+
+		MojObject params;
+		params.putBool("start", true);
+		params.putBool("subscribe", true);
+		params.put("activity", activity);
+
+		err = req->send(m_activitySubscriptionSlot, "com.palm.activitymanager", "create", params, MojServiceRequest::Unlimited);
+	}
+
+	return err;
+}
+
+// Expected responses
+// {"activityId":78,"returnValue":true}
+// {"activityId":78,"event":"start","returnValue":true}  <-- this occurs when the timeout fires
+// Error in case there is already an activity for the given serviceName
+// {"errorCode":17,"errorText":"Activity with that name already exists","returnValue":false}
+MojErr IMLoginFailRetryHandler::activitySubscriptionResult(MojObject& result, MojErr err)
+{
+	MojLogDebug(IMServiceApp::s_log, _T("IMLoginFailRetryHandler::activitySubscriptionResult begin err=%d"), err);
+
+	MojString event;
+	if (err == MojErrNone && result.getRequired(_T("event"), event) == MojErrNone)
+	{
+		if (event == "start")
+		{
+			bool found = result.get("activityId", m_activityId);
+			if (!found)
+				MojLogError(IMServiceApp::s_log, _T("activitySubscriptionResult: parameter has no activityId"));
+			err = m_dbClient.merge(m_dbmergeSlot, m_query, m_mergeProps);
+			//TODO also markBuddiesAsOffline? Shouldn't need to since lost connection should do that later
+		}
+	}
+	return err;
+}
+
+MojErr IMLoginFailRetryHandler::dbmergeResult(MojObject& result, MojErr err)
+{
+	if (m_activityId > 0)
+	{
+		MojRefCountedPtr<MojServiceRequest> req;
+		err = m_service->createRequest(req);
+		MojObject completeParams;
+		completeParams.put(_T("activityId"), m_activityId);
+		err = req->send(m_activityCompleteSlot, "com.palm.activitymanager", "complete", completeParams, 1);
+	}
+	return err;
+}
+
+MojErr IMLoginFailRetryHandler::activityCompleteResult(MojObject& result, MojErr err)
+{
+	m_activitySubscriptionSlot.cancel();
+	return err;
+}
+
+
+/*
+ * IMLoginSyncStateHandler -- signal handler to update syncState
+ */
+IMLoginSyncStateHandler::IMLoginSyncStateHandler(MojService* service)
+: m_removeSyncStateSlot(this, &IMLoginSyncStateHandler::removeSyncStateResult),
+  m_saveSyncStateSlot(this, &IMLoginSyncStateHandler::saveSyncStateResult),
+  m_service(service),
+  m_tempdbClient(service, MojDbServiceDefs::TempServiceName)
+{
+}
+
+/*
+ * Update the syncState record in temp DB
+ *     delete any existing syncState record. Covers the case when login succeeds
+ *     if the login failed due to bad password, need to add a syncState record with the correct account error code
+ */
+void IMLoginSyncStateHandler::updateSyncStateRecord(const char* serviceName, MojString accountId, LoginCallbackInterface::LoginResult type, const char* errCode)
+{
+	// syncState record:
+		/*
+		{
+		"_kind": "com.palm.account.syncstate:1",
+		"accountId": "++HBI8gkY38GlaVk",   LoginStateData.getAccountId()
+		"busAddress": "com.palm.imlibpurple"
+		"capabilityProvider": "com.palm.google.talk" or "com.palm.aol.aim"
+		"errorCode": "401_UNAUTHORIZED",
+		"errorText": "Incorrect Password",
+		"syncState": "ERROR"
+		 }
+		 */
+
+
+	// get the capabilityProvidor id from the service
+	// TODO - should read this out of template ID...
+	if (strcmp(serviceName, SERVICENAME_AIM) == 0) {
+		m_capabilityId.assign(CAPABILITY_AIM);
+	}
+	else if (strcmp(serviceName, SERVICENAME_FACEBOOK) == 0){
+		m_capabilityId.assign(CAPABILITY_FACEBOOK);
+	}
+	else if (strcmp(serviceName, SERVICENAME_GTALK) == 0){
+		m_capabilityId.assign(CAPABILITY_GTALK);
+	}
+	else if (strcmp(serviceName, SERVICENAME_GADU) == 0){
+		m_capabilityId.assign(CAPABILITY_GADU);
+	}
+	else if (strcmp(serviceName, SERVICENAME_GROUPWISE) == 0){
+		m_capabilityId.assign(CAPABILITY_GROUPWISE);
+	}
+	else if (strcmp(serviceName, SERVICENAME_ICQ) == 0){
+		m_capabilityId.assign(CAPABILITY_ICQ);
+	}
+	else if (strcmp(serviceName, SERVICENAME_JABBER) == 0){
+		m_capabilityId.assign(CAPABILITY_JABBER);
+	}
+	else if (strcmp(serviceName, SERVICENAME_LIVE) == 0){
+		m_capabilityId.assign(CAPABILITY_LIVE);
+	}
+	else if (strcmp(serviceName, SERVICENAME_MYSPACE) == 0){
+		m_capabilityId.assign(CAPABILITY_MYSPACE);
+	}
+	else if (strcmp(serviceName, SERVICENAME_QQ) == 0){
+		m_capabilityId.assign(CAPABILITY_QQ);
+	}
+	else if (strcmp(serviceName, SERVICENAME_SAMETIME) == 0){
+		m_capabilityId.assign(CAPABILITY_SAMETIME);
+	}
+	else if (strcmp(serviceName, SERVICENAME_SIPE) == 0){
+		m_capabilityId.assign(CAPABILITY_SIPE);
+	}
+	else if (strcmp(serviceName, SERVICENAME_XFIRE) == 0){
+		m_capabilityId.assign(CAPABILITY_XFIRE);
+	}
+	else if (strcmp(serviceName, SERVICENAME_YAHOO) == 0){
+		m_capabilityId.assign(CAPABILITY_YAHOO);
+	}
+	else {
+		MojLogError(IMServiceApp::s_log, _T("updateSyncStateRecord: unknown serviceName %s. No syncState record created."), serviceName);
+		// can we do anything here??
+		return;
+	}
+
+	// save the input parameters
+	m_accountId = accountId;
+
+	// get the error code for the new record if we need it
+	if (LoginCallbackInterface::LOGIN_SUCCESS != type) {
+
+		// for now, we only show dashboard for authentication errors
+		if ((strcmp(errCode, ERROR_AUTHENTICATION_FAILED) == 0) ||
+			(strcmp(errCode, ERROR_BAD_USERNAME) == 0) ||
+		    (strcmp(errCode, ERROR_BAD_PASSWORD) == 0))	{
+			m_errorCode.assign(ACCOUNT_401_UNAUTHORIZED);
+		}
+	}
+
+	// delete any existing record for this account
+	// construct our where clause - find by username, accountId and servicename
+	MojDbQuery query;
+	query.where("capabilityProvider", MojDbQuery::OpEq, m_capabilityId);
+	query.where("accountId", MojDbQuery::OpEq, m_accountId);
+	query.from(IM_SYNCSTATE_KIND);
+
+	// delete the old record. If none exists, that is OK - DB just returns a count of 0 in result
+	MojErr err = m_tempdbClient.del(m_removeSyncStateSlot, query);
+	if (err) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("updateSyncStateRecord: dbClient.del() failed: error %d - %s"), err, error.data());
+	}
+}
+
+/*
+ * Remove the old the syncState record result
+ */
+MojErr IMLoginSyncStateHandler::removeSyncStateResult(MojObject& result, MojErr resultErr)
+{
+	if (resultErr) {
+		MojString error;
+		MojErrToString(resultErr, error);
+		MojLogError(IMServiceApp::s_log, _T("removeSyncStateResult: DB del failed. error %d - %s"), resultErr, error.data());
+	}
+	else {
+		IMServiceHandler::logMojObjectJsonString(_T("removeSyncStateResult: syncState successfully removed: %s"), result);
+	}
+
+	// no error means we are done
+	if (m_errorCode.empty())
+		return MojErrNone;
+
+
+	// otherwise add the new record
+	MojObject props;
+	props.putString(_T("errorCode"), m_errorCode);
+	props.putString(_T("_kind"), IM_SYNCSTATE_KIND);
+	props.putString(_T("accountId"), m_accountId);
+	props.putString(_T("capabilityProvider"), m_capabilityId);
+
+	// bus address
+	MojString busAddr;
+	busAddr.assign(_T("org.webosinternals.imlibpurple"));
+	props.putString(_T("busAddress"), busAddr);
+
+	// sync state - error
+	MojString syncState;
+	syncState.assign(_T("ERROR"));
+	props.putString(_T("syncState"), syncState);
+
+	// log it
+	MojString json;
+	props.toJson(json);
+	MojLogInfo(IMServiceApp::s_log, _T("removeSyncStateResult: saving syncState to db: %s"), json.data());
+
+	MojErr err = m_tempdbClient.put(m_saveSyncStateSlot, props);
+	if (err) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("removeSyncStateResult: dbClient.put() failed: error %d - %s"), err, error.data());
+	}
+
+	return MojErrNone;
+}
+
+/*
+ * Save the new syncState record result
+ * Just log errors.
+ */
+MojErr IMLoginSyncStateHandler::saveSyncStateResult(MojObject& result, MojErr resultErr)
+{
+	if (resultErr) {
+		MojString error;
+		MojErrToString(resultErr, error);
+		MojLogError(IMServiceApp::s_log, _T("saveSyncStateResult: DB put failed. error %d - %s"), resultErr, error.data());
+	}
+	else {
+		IMServiceHandler::logMojObjectJsonString(_T("saveSyncStateResult: syncState successfully saved: %s"), result);
+	}
+
+	return MojErrNone;
+}
+
diff -rupN imlibpurpleservice-1.0/src/IMServiceApp.cpp imlibpurpleservice-1.0-new//src/IMServiceApp.cpp
--- imlibpurpleservice-1.0/src/IMServiceApp.cpp	2011-03-25 10:45:40.744552999 -0600
+++ imlibpurpleservice-1.0-new//src/IMServiceApp.cpp	2011-03-27 09:10:06.164553000 -0600
@@ -32,6 +32,7 @@ MojLogger IMServiceApp::s_log(_T("org.we
 
 int main(int argc, char** argv)
 {
+purple_debug_set_enabled(TRUE);
 	IMServiceApp app;
 	LibpurpleAdapter::init();
 	int mainResult = app.main(argc, argv);
diff -rupN imlibpurpleservice-1.0/src/LibpurpleAdapter.cpp imlibpurpleservice-1.0-new//src/LibpurpleAdapter.cpp
--- imlibpurpleservice-1.0/src/LibpurpleAdapter.cpp	2011-03-25 10:45:40.760552999 -0600
+++ imlibpurpleservice-1.0-new//src/LibpurpleAdapter.cpp	2011-03-27 09:10:06.212553000 -0600
@@ -378,6 +378,9 @@ static char* getMojoFriendlyTemplateID (
 	else if (strcmp(serviceName, SERVICENAME_LIVE) == 0){
 		return (char*)CAPABILITY_LIVE;
 	}
+	else if (strcmp(serviceName, SERVICENAME_WLM) == 0){
+		return (char*)CAPABILITY_WLM;
+	}
 	else if (strcmp(serviceName, SERVICENAME_MYSPACE) == 0){
 		return (char*)CAPABILITY_MYSPACE;
 	}
@@ -554,7 +557,7 @@ static char* getPrplProtocolIdFromServic
 	}
 	GString* prplProtocolId = g_string_new("prpl-");
 
-	if ((strcmp(serviceName, SERVICENAME_GTALK) == 0) || (strcmp(serviceName, SERVICENAME_LIVE) == 0) || (strcmp(serviceName, SERVICENAME_FACEBOOK) == 0) || (strcmp(serviceName, SERVICENAME_SAMETIME) == 0) || (strcmp(serviceName, SERVICENAME_GROUPWISE) == 0) || (strcmp(serviceName, SERVICENAME_GADU) == 0))
+	if ((strcmp(serviceName, SERVICENAME_GTALK) == 0) || (strcmp(serviceName, SERVICENAME_LIVE) == 0) || (strcmp(serviceName, SERVICENAME_FACEBOOK) == 0) || (strcmp(serviceName, SERVICENAME_SAMETIME) == 0) || (strcmp(serviceName, SERVICENAME_GROUPWISE) == 0) || (strcmp(serviceName, SERVICENAME_GADU) == 0) || (strcmp(serviceName, SERVICENAME_WLM) == 0))
 	{
 		if (strcmp(serviceName, SERVICENAME_GTALK) == 0)
 		{
@@ -566,6 +569,11 @@ static char* getPrplProtocolIdFromServic
 			// Special case for live where the mojo serviceName is "type_live" and the prpl protocol_id is "prpl-msn"
 			g_string_append(prplProtocolId, "msn");
 		}
+		if (strcmp(serviceName, SERVICENAME_WLM) == 0)
+		{
+			// Special case for live (pecan) where the mojo serviceName is "type_wlm" and the prpl protocol_id is "prpl-msn-pecan"
+			g_string_append(prplProtocolId, "msn-pecan");
+		}
 		if (strcmp(serviceName, SERVICENAME_FACEBOOK) == 0)
 		{
 			// Special case for facebook where the mojo serviceName is "type_facebook" and the prpl protocol_id is "prpl-bigbrownchunx-facebookim"
@@ -647,6 +655,12 @@ static char* getServiceNameFromPrplProto
 		g_string_free(serviceName, TRUE);
 		serviceName = g_string_new("live");
 	}
+        if (strcmp(serviceName->str, "msn-pecan") == 0)
+        {
+                // Special case for live where the mojo serviceName is "type_wlm" and the prpl protocol_id is "prpl-msn-pecan"
+                g_string_free(serviceName, TRUE);
+                serviceName = g_string_new("wlm");
+        }
 	if (strcmp(serviceName->str, "bigbrownchunx-facebookim") == 0)
 	{
 		// Special case for facebook where the mojo serviceName is "type_facebook" and the prpl protocol_id is "prpl-bigbrownchunx-facebookim"
diff -rupN imlibpurpleservice-1.0/src/LibpurpleAdapter.cpp~ imlibpurpleservice-1.0-new//src/LibpurpleAdapter.cpp~
--- imlibpurpleservice-1.0/src/LibpurpleAdapter.cpp~	1969-12-31 18:00:00.000000000 -0600
+++ imlibpurpleservice-1.0-new//src/LibpurpleAdapter.cpp~	2011-03-27 09:10:06.132553000 -0600
@@ -0,0 +1,2817 @@
+/*
+ * LibpurpleAdapter.cpp
+ *
+ * Copyright 2010 Palm, Inc. All rights reserved.
+ *
+ * This program is free software and licensed under the terms of the GNU
+ * General Public License Version 2 as published by the Free
+ * Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License,
+ * Version 2 along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-
+ * 1301, USA
+ *
+ * IMLibpurpleservice uses libpurple.so to implement a fully functional IM
+ * Transport service for use on a mobile device.
+ *
+ * The LibpurpleAdapter is a simple adapter between libpurple.so and the
+ * IMLibpurpleService transport
+ */
+
+/*
+ * This file includes code from pidgin  (nullclient.c)
+ *
+ * pidgin
+ *
+ * Pidgin is the legal property of its developers, whose names are too numerous
+ * to list here.  Please refer to the COPYRIGHT file distributed with this
+ * source distribution.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02111-1301  USA
+ *
+ */
+
+#include "purple.h"
+
+#include <glib.h>
+
+#include <signal.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+
+#include "LibpurpleAdapter.h"
+#include "LibpurpleAdapterPrefs.h"
+#include "PalmImCommon.h"
+#include "luna/MojLunaService.h"
+#include "IMServiceApp.h"
+#include "db/MojDbQuery.h"
+
+static const guint PURPLE_GLIB_READ_COND  = (G_IO_IN | G_IO_HUP | G_IO_ERR);
+static const guint PURPLE_GLIB_WRITE_COND = (G_IO_OUT | G_IO_HUP | G_IO_ERR | G_IO_NVAL);
+//static const guint CONNECT_TIMEOUT_SECONDS = 45; Moved to preferences
+//static const guint BUDDY_LIST_REFRESH = 10; Moved to preferences
+
+static LoginCallbackInterface* s_loginState = NULL;
+static IMServiceCallbackInterface* s_imServiceHandler = NULL;
+static LibpurplePrefsHandler* s_PrefsHandler = NULL;
+
+/**
+ * List of accounts that are online
+ */
+static GHashTable* s_onlineAccountData = NULL;
+/**
+ * List of accounts that are in the process of logging in
+ */
+static GHashTable* s_pendingAccountData = NULL;
+static GHashTable* s_offlineAccountData = NULL;
+static GHashTable* s_accountLoginTimers = NULL;
+static GHashTable* s_connectionTypeData = NULL;
+static GHashTable* s_AccountIdsData = NULL;
+static GHashTable* s_accountBuddyListTimers = NULL;
+
+/*
+ * list of pending authorization requests
+ */
+static GHashTable* s_AuthorizeRequests = NULL;
+
+static bool s_libpurpleInitialized = FALSE;
+static bool s_registeredForAccountSignals = FALSE;
+static bool s_registeredForPresenceUpdateSignals = FALSE;
+/** 
+ * Keeps track of the local IP address that we bound to when logging in to individual accounts 
+ * key: accountKey, value: IP address 
+ */
+static GHashTable* s_ipAddressesBoundTo = NULL;
+
+typedef struct _IOClosure
+{
+	guint result;
+	gpointer data;
+	PurpleInputFunction function;
+} IOClosure;
+
+// used for processing buddy invite requests
+typedef struct _auth_and_add
+{
+	PurpleAccountRequestAuthorizationCb auth_cb;
+	PurpleAccountRequestAuthorizationCb deny_cb;
+	void *data;
+	char *remote_user;
+	char *alias;
+	PurpleAccount *account;
+} AuthRequest;
+
+static void incoming_message_cb(PurpleConversation *conv, const char *who, const char *alias, const char *message,	PurpleMessageFlags flags, time_t mtime);
+static void adapterUIInit(void);
+static GHashTable* getClientInfo(void);
+static gboolean adapterInvokeIO(GIOChannel *source, GIOCondition condition, gpointer data);
+static guint adapterIOAdd(gint fd, PurpleInputCondition condition, PurpleInputFunction function, gpointer data);
+
+//Prompt for authorization when someone adds this account to their buddy list.
+//To authorize them to see this account's presence, call authorize_cb (user_data); otherwise call deny_cb (user_data);
+//Returns:
+//    a UI-specific handle, as passed to close_account_request.
+//    void(* _PurpleAccountUiOps::close_account_request)(void *ui_handle)
+//    Close a pending request for authorization.
+//    ui_handle is a handle as returned by request_authorize.
+//Parameters:
+//    	account 	The account that was added
+//    	remote_user 	The name of the user that added this account.
+//    	id 	The optional ID of the local account. Rarely used.
+//    	alias 	The optional alias of the remote user.
+//    	message 	The optional message sent by the user wanting to add you.
+//    	on_list 	Is the remote user already on the buddy list?
+//    	auth_cb 	The callback called when the local user accepts
+//    	deny_cb 	The callback called when the local user rejects
+//    	user_data 	Data to be passed back to the above callbacks
+static void *request_authorize_cb (PurpleAccount *account,
+	const char *remote_user,
+	const char *id,
+	const char *alias,
+	const char *message,
+	gboolean on_list,
+	PurpleAccountRequestAuthorizationCb authorize_cb,
+	PurpleAccountRequestAuthorizationCb deny_cb,
+	void *user_data);
+
+void request_add_cb (PurpleAccount *account, const char *remote_user, const char *id, const char *alias, const char *message);
+
+// AccountUIOps:
+//    /** A buddy who is already on this account's buddy list added this account
+//-	   *  to their buddy list.
+//     */
+//-	void (*notify_added)(PurpleAccount *account,
+//-	                     const char *remote_user,
+//-	                     const char *id,
+//-	                     const char *alias,
+//-	                     const char *message);
+//-
+//-	/** This account's status changed. */
+//-	void (*status_changed)(PurpleAccount *account,
+//-	                       PurpleStatus *status);
+//-
+//-	/** Someone we don't have on our list added us; prompt to add them. */
+//-	void (*request_add)(PurpleAccount *account,
+//-	                    const char *remote_user,
+//-	                    const char *id,
+//-	                    const char *alias,
+//-	                    const char *message);
+//-
+//-	/** Prompt for authorization when someone adds this account to their buddy
+//-	 * list.  To authorize them to see this account's presence, call \a
+//-	 * authorize_cb (\a user_data); otherwise call \a deny_cb (\a user_data);
+//-	 * @return a UI-specific handle, as passed to #close_account_request.
+//-	 */
+//-	void *(*request_authorize)(PurpleAccount *account,
+//-	                           const char *remote_user,
+//-	                           const char *id,
+//-	                           const char *alias,
+//-	                           const char *message,
+//-	                           gboolean on_list,
+//-	                           PurpleAccountRequestAuthorizationCb authorize_cb,
+//-	                           PurpleAccountRequestAuthorizationCb deny_cb,
+//-	                           void *user_data);
+//-
+//-	/** Close a pending request for authorization.  \a ui_handle is a handle
+//-	 *  as returned by #request_authorize.
+//-	 */
+//-	void (*close_account_request)(void *ui_handle);
+static PurpleAccountUiOps adapterAccountUIOps =
+{
+	NULL,                  //  notify_added
+	NULL,                  //  status_changed
+	request_add_cb,        //  request_add
+	request_authorize_cb,  //  request_authorize
+	NULL,                  //  close_account_request,
+
+	// padding
+	NULL,
+	NULL,
+	NULL,
+	NULL,
+};
+
+static PurpleCoreUiOps adapterCoreUIOps =
+{
+	NULL, NULL, adapterUIInit, NULL, getClientInfo, NULL, NULL, NULL
+};
+
+static PurpleEventLoopUiOps adapterEventLoopUIOps =
+{
+	g_timeout_add, g_source_remove, adapterIOAdd, g_source_remove, NULL, g_timeout_add_seconds, NULL, NULL, NULL
+};
+
+static PurpleConversationUiOps adapterConversationUIOps  =
+{
+	NULL, NULL, NULL, NULL, incoming_message_cb, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL,
+	NULL, NULL
+};
+
+// useful for debugging
+static void authRequest_log_func(gpointer key, gpointer value, gpointer ud)
+{
+	AuthRequest *aa = (AuthRequest *)value;
+	MojLogInfo(IMServiceApp::s_log, _T("  AuthRequest: key = %s, requester = %s"), (char*)key, aa->remote_user);
+}
+static void logAuthRequestTableValues()
+{
+	MojLogInfo(IMServiceApp::s_log, _T("Authorize Request Table:"));
+	g_hash_table_foreach(s_AuthorizeRequests, authRequest_log_func, NULL);
+}
+
+
+void adapterUIInit(void)
+{
+	purple_conversations_set_ui_ops(&adapterConversationUIOps);
+	purple_accounts_set_ui_ops(&adapterAccountUIOps);
+}
+
+void destroyNotify(gpointer dataToFree)
+{
+	g_free(dataToFree);
+}
+
+gboolean adapterInvokeIO(GIOChannel* ioChannel, GIOCondition ioCondition, gpointer data)
+{
+	IOClosure* ioClosure = (IOClosure*)data;
+	int purpleCondition = 0;
+	
+	if (PURPLE_GLIB_READ_COND & ioCondition)
+	{
+		purpleCondition = purpleCondition | PURPLE_INPUT_READ;
+	}
+	
+	if (PURPLE_GLIB_WRITE_COND & ioCondition)
+	{
+		purpleCondition = purpleCondition | PURPLE_INPUT_WRITE;
+	}
+
+	ioClosure->function(ioClosure->data, g_io_channel_unix_get_fd(ioChannel), (PurpleInputCondition)purpleCondition);
+
+	return TRUE;
+}
+
+guint adapterIOAdd(gint fd, PurpleInputCondition purpleCondition, PurpleInputFunction inputFunction, gpointer data)
+{
+	GIOChannel* ioChannel;
+	unsigned int ioCondition = 0;
+	IOClosure* ioClosure = g_new0(IOClosure, 1);
+
+	ioClosure->data = data;
+	ioClosure->function = inputFunction;
+
+	if (PURPLE_INPUT_READ & purpleCondition)
+	{
+		ioCondition = ioCondition | PURPLE_GLIB_READ_COND;
+	}
+	
+	if (PURPLE_INPUT_WRITE & purpleCondition)
+	{
+		ioCondition = ioCondition | PURPLE_GLIB_WRITE_COND;
+	}
+
+	ioChannel = g_io_channel_unix_new(fd);
+	ioClosure->result = g_io_add_watch_full(ioChannel, G_PRIORITY_DEFAULT, (GIOCondition)ioCondition, adapterInvokeIO, ioClosure,
+			destroyNotify);
+
+	g_io_channel_unref(ioChannel);
+	return ioClosure->result;
+}
+
+/*
+ * Helper methods 
+ */
+
+ /*
+ * The messaging service expects the username to be in the username@domain.com format, whereas the AIM prpl uses the username only
+ * Free the returned string when you're done with it 
+ */
+static char* getMojoFriendlyUsername(const char* username, const char* serviceName)
+{
+	if (!username || !serviceName)
+	{
+		return strdup("");
+	}
+	GString* mojoFriendlyUsername = g_string_new(username);
+	if (strcmp(serviceName, SERVICENAME_AIM) == 0 && strchr(username, '@') == NULL)
+	{
+		g_string_append(mojoFriendlyUsername, "@aol.com");
+	}
+	else if (strcmp(serviceName, SERVICENAME_GTALK) == 0)
+	{
+		char* resource = (char*)memchr(username, '/', strlen(username));
+		if (resource != NULL)
+		{
+			int charsToKeep = resource - username;
+			g_string_erase(mojoFriendlyUsername, charsToKeep, -1);
+		}
+	}
+	else if (strcmp(serviceName, SERVICENAME_JABBER) == 0)
+	{
+		if (strstr(username, "/") != NULL)
+		{
+			//If jabber resource is blank remove /
+			char *resource = (char*)memchr(username, '/', strlen(username));
+			if (resource != NULL)
+			{
+				int charsToKeep = resource - username;
+				g_string_erase(mojoFriendlyUsername, charsToKeep, -1);
+			}
+		}
+	}
+	else if (strcmp(serviceName, SERVICENAME_SIPE) == 0)
+	{
+		char *resource = (char*)memchr(username, ',', strlen(username));
+		if (resource != NULL)
+		{
+			int charsToKeep = resource - username;
+			g_string_erase(mojoFriendlyUsername, charsToKeep, -1);
+		}
+	}
+	char* mojoFriendlyUsernameToReturn = strdup(mojoFriendlyUsername->str);
+	g_string_free(mojoFriendlyUsername, TRUE);
+	return mojoFriendlyUsernameToReturn;
+}
+
+static char* getMojoFriendlyTemplateID (char* serviceName)
+{
+	if (strcmp(serviceName, SERVICENAME_AIM) == 0) {
+		return (char*)CAPABILITY_AIM;
+	}
+	else if (strcmp(serviceName, SERVICENAME_FACEBOOK) == 0){
+		return (char*)CAPABILITY_FACEBOOK;
+	}
+	else if (strcmp(serviceName, SERVICENAME_GTALK) == 0){
+		return (char*)CAPABILITY_GTALK;
+	}
+	else if (strcmp(serviceName, SERVICENAME_GADU) == 0){
+		return (char*)CAPABILITY_GADU;
+	}
+	else if (strcmp(serviceName, SERVICENAME_GROUPWISE) == 0){
+		return (char*)CAPABILITY_GROUPWISE;
+	}
+	else if (strcmp(serviceName, SERVICENAME_ICQ) == 0){
+		return (char*)CAPABILITY_ICQ;
+	}
+	else if (strcmp(serviceName, SERVICENAME_JABBER) == 0){
+		return (char*)CAPABILITY_JABBER;
+	}
+	else if (strcmp(serviceName, SERVICENAME_LIVE) == 0){
+		return (char*)CAPABILITY_LIVE;
+	}
+	else if (strcmp(serviceName, SERVICENAME_MYSPACE) == 0){
+		return (char*)CAPABILITY_MYSPACE;
+	}
+	else if (strcmp(serviceName, SERVICENAME_QQ) == 0){
+		return (char*)CAPABILITY_QQ;
+	}
+	else if (strcmp(serviceName, SERVICENAME_SAMETIME) == 0){
+		return (char*)CAPABILITY_SAMETIME;
+	}
+	else if (strcmp(serviceName, SERVICENAME_SIPE) == 0){
+		return (char*)CAPABILITY_SIPE;
+	}
+	else if (strcmp(serviceName, SERVICENAME_XFIRE) == 0){
+		return (char*)CAPABILITY_XFIRE;
+	}
+	else if (strcmp(serviceName, SERVICENAME_YAHOO) == 0){
+		return (char*)CAPABILITY_YAHOO;
+	}
+	
+	return (char*)"";
+}
+
+/*
+ * This method handles special cases where the username passed by the mojo side does not satisfy a particular prpl's requirement
+ * (e.g. for logging into AIM, the mojo service uses "palmpre@aol.com", yet the aim prpl expects "palmpre"; same scenario with yahoo)
+ * Free the returned string when you're done with it 
+ */
+static char* getPrplFriendlyUsername(const char* serviceName, const char* username)
+{
+	if (!username || !serviceName)
+	{
+		return strdup("");
+	}
+
+	char* transportFriendlyUsername = strdup(username);
+	if (strcmp(serviceName, SERVICENAME_AIM) == 0)
+	{
+		// Need to strip off @aol.com, but not @aol.com.mx
+		const char* extension = strstr(username, "@aol.com");
+		if (extension != NULL && strstr(extension, "aol.com.") == NULL)
+		{
+			strtok(transportFriendlyUsername, "@");
+		}
+	}
+	
+	const char* SIPEServerLogin;
+	const char* JabberResource;
+	char* templateId = getMojoFriendlyTemplateID((char*)serviceName);
+
+	//Special Case for Office Communicator when DOMAIN\USER is set. Account name is USERNAME,DOMAIN\USER
+	if (strcmp(serviceName, SERVICENAME_SIPE) == 0)
+	{
+		if (strstr(username, ",") != NULL)
+		{
+			//A "," exists in the sign in name already
+			//transportFriendlyUsername = malloc(strlen(username) + 1);
+			transportFriendlyUsername = strcpy(transportFriendlyUsername, username);
+			return transportFriendlyUsername;
+		}
+		else
+		{
+			SIPEServerLogin = s_PrefsHandler->GetStringPreference("SIPEServerLogin", templateId, username);
+			if (strcmp(SIPEServerLogin, "") != 0)
+			{
+				//transportFriendlyUsername = malloc(strlen(username) + 1);
+				transportFriendlyUsername = strcpy(transportFriendlyUsername, username);
+
+				//SIPE Account
+				char *SIPEFullLoginName = NULL;
+				SIPEFullLoginName = (char *)calloc(strlen(transportFriendlyUsername) + strlen(SIPEServerLogin) + 2, sizeof(char));
+				strcat(SIPEFullLoginName, transportFriendlyUsername);
+				strcat(SIPEFullLoginName, ",");
+				strcat(SIPEFullLoginName, SIPEServerLogin);
+
+				return SIPEFullLoginName;
+			}
+		}
+	}
+
+	//Special Case for jabber when resource is set. Account name is USERNAME/RESOURCE
+	if (strcmp(serviceName, SERVICENAME_JABBER) == 0)
+	{
+		if (strstr(username, "/") != NULL)
+		{
+			//A "/" exists in the sign in name already
+			transportFriendlyUsername = strcpy(transportFriendlyUsername, username);
+
+			return transportFriendlyUsername;
+		}
+		else
+		{
+			JabberResource = s_PrefsHandler->GetStringPreference("JabberResource", templateId, username);
+			
+			if (strcmp(JabberResource, "") != 0)
+			{
+				transportFriendlyUsername = strcpy(transportFriendlyUsername, username);
+				
+				//Jabber Account
+				char *JabberFullLoginName = NULL;
+				JabberFullLoginName = (char *)calloc(strlen(transportFriendlyUsername) + strlen(JabberResource) + 2, sizeof(char));
+				strcat(JabberFullLoginName, transportFriendlyUsername);
+				strcat(JabberFullLoginName, "/");
+				strcat(JabberFullLoginName, JabberResource);
+
+				return JabberFullLoginName;
+			}
+		}
+	}
+	
+	MojLogInfo(IMServiceApp::s_log, _T("getPrplFriendlyUsername: username: %s, transportFriendlyUsername: %s"), username, transportFriendlyUsername);
+	return transportFriendlyUsername;
+}
+
+static char* stripResourceFromGtalkUsername(const char* username, const char* serviceName)
+{
+	if (!username)
+	{
+		return strdup("");
+	}
+	if ((strcmp(serviceName, SERVICENAME_GTALK) != 0) && (strcmp(serviceName, SERVICENAME_JABBER) != 0))
+	{
+		return strdup(username);
+	}
+
+	GString* mojoFriendlyUsername = g_string_new(username);
+	char* resource = (char*)memchr(username, '/', strlen(username));
+	if (resource != NULL)
+	{
+		int charsToKeep = resource - username;
+		g_string_erase(mojoFriendlyUsername, charsToKeep, -1);
+	}
+	char* mojoFriendlyUsernameToReturn = strdup(mojoFriendlyUsername->str);
+	g_string_free(mojoFriendlyUsername, TRUE);
+	return mojoFriendlyUsernameToReturn;
+}
+
+static const char* getMojoFriendlyErrorCode(PurpleConnectionError type)
+{
+	const char* mojoFriendlyErrorCode;
+	if (type == PURPLE_CONNECTION_ERROR_INVALID_USERNAME)
+	{
+		mojoFriendlyErrorCode = ERROR_BAD_USERNAME;
+	}
+	else if (type == PURPLE_CONNECTION_ERROR_AUTHENTICATION_FAILED)
+	{
+		mojoFriendlyErrorCode = ERROR_AUTHENTICATION_FAILED;
+	}
+	else if (type == PURPLE_CONNECTION_ERROR_NETWORK_ERROR)
+	{
+		mojoFriendlyErrorCode = ERROR_NETWORK_ERROR;
+	}
+	else if (type == PURPLE_CONNECTION_ERROR_NAME_IN_USE)
+	{
+		mojoFriendlyErrorCode = ERROR_NAME_IN_USE;
+	}
+	else
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("PurpleConnectionError was %i"), type);
+		mojoFriendlyErrorCode = ERROR_GENERIC_ERROR;
+	}
+	return mojoFriendlyErrorCode;
+}
+
+/*
+ * Given mojo-friendly serviceName, it will return prpl-specific protocol_id (e.g. given "type_aim", it will return "prpl-aim")
+ * Free the returned string when you're done with it 
+ */
+static char* getPrplProtocolIdFromServiceName(const char* serviceName)
+{
+	if (!serviceName || serviceName[0] == 0)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getPrplProtocolIdFromServiceName called with empty serviceName"));
+		return strdup("");
+	}
+	GString* prplProtocolId = g_string_new("prpl-");
+
+	if ((strcmp(serviceName, SERVICENAME_GTALK) == 0) || (strcmp(serviceName, SERVICENAME_LIVE) == 0) || (strcmp(serviceName, SERVICENAME_FACEBOOK) == 0) || (strcmp(serviceName, SERVICENAME_SAMETIME) == 0) || (strcmp(serviceName, SERVICENAME_GROUPWISE) == 0) || (strcmp(serviceName, SERVICENAME_GADU) == 0))
+	{
+		if (strcmp(serviceName, SERVICENAME_GTALK) == 0)
+		{
+			// Special case for gtalk where the mojo serviceName is "type_gtalk" and the prpl protocol_id is "prpl-jabber"
+			g_string_append(prplProtocolId, "jabber");
+		}
+		if (strcmp(serviceName, SERVICENAME_LIVE) == 0)
+		{
+			// Special case for live where the mojo serviceName is "type_live" and the prpl protocol_id is "prpl-msn"
+			g_string_append(prplProtocolId, "msn");
+		}
+		if (strcmp(serviceName, SERVICENAME_FACEBOOK) == 0)
+		{
+			// Special case for facebook where the mojo serviceName is "type_facebook" and the prpl protocol_id is "prpl-bigbrownchunx-facebookim"
+			g_string_append(prplProtocolId, "bigbrownchunx-facebookim");
+		}
+		if (strcmp(serviceName, SERVICENAME_SAMETIME) == 0)
+		{
+			// Special case for sametime where the mojo serviceName is "type_sametime" and the prpl protocol_id is "prpl-meanwhile"
+			g_string_append(prplProtocolId, "meanwhile");
+		}
+		if (strcmp(serviceName, SERVICENAME_GROUPWISE) == 0)
+		{
+			// Special case for groupwise where the mojo serviceName is "type_groupwise" and the prpl protocol_id is "prpl-novell"
+			g_string_append(prplProtocolId, "novell");
+		}
+		if (strcmp(serviceName, SERVICENAME_GADU) == 0)
+		{
+			// Special case for gadu gadu where the mojo serviceName is "type_gadu" and the prpl protocol_id is "prpl-gg"
+			g_string_append(prplProtocolId, "gg");
+		}
+	}
+	else
+	{
+		const char* stringChopper = serviceName;
+		stringChopper += strlen("type_");
+		g_string_append(prplProtocolId, stringChopper);
+	}
+	char* prplProtocolIdToReturn = strdup(prplProtocolId->str);
+	g_string_free(prplProtocolId, TRUE);
+	return prplProtocolIdToReturn;
+}
+
+/*
+ * Given the prpl-specific protocol_id, it will return mojo-friendly serviceName (e.g. given "prpl-aim", it will return "type_aim")
+ * Free the returned string when you're done with it 
+ */
+static char* getServiceNameFromPrplProtocolId(PurpleAccount *account)
+{
+	char *prplProtocolId = account->protocol_id;
+	if (!prplProtocolId)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getServiceNameFromPrplProtocolId called with empty protocolId"));
+		return strdup("type_default");
+	}
+	char* stringChopper = prplProtocolId;
+	stringChopper += strlen("prpl-");
+	GString* serviceName = g_string_new(stringChopper);
+
+	if (strcmp(serviceName->str, "jabber") == 0)
+	{
+		// Special case for gtalk where the mojo serviceName is "type_gtalk" and the prpl protocol_id is "prpl-jabber"
+		g_string_free(serviceName, TRUE);
+		
+		const char *Alias = purple_account_get_alias (account);
+
+		if (Alias != NULL)
+		{
+			//Check account alias. gtalk for Gtalk, jabber for Jabber
+			if (strcmp(Alias, "gtalk") == 0)
+			{
+				// Special case for gtalk where the java serviceName is "gmail" and the prpl protocol_id is "prpl-jabber"
+				serviceName = g_string_new("gtalk");
+			}
+			else
+			{
+				// Special case for jabber where the java serviceName is "jabber" and the prpl protocol_id is "prpl-jabber"
+				serviceName = g_string_new("jabber");
+			}
+		}
+		else
+		{
+			//Account alias is blank for some reason. Guess gtalk
+			serviceName = g_string_new("gtalk");
+		}
+	}
+	if (strcmp(serviceName->str, "msn") == 0)
+	{
+		// Special case for live where the mojo serviceName is "type_live" and the prpl protocol_id is "prpl-msn"
+		g_string_free(serviceName, TRUE);
+		serviceName = g_string_new("live");
+	}
+	if (strcmp(serviceName->str, "bigbrownchunx-facebookim") == 0)
+	{
+		// Special case for facebook where the mojo serviceName is "type_facebook" and the prpl protocol_id is "prpl-bigbrownchunx-facebookim"
+		g_string_free(serviceName, TRUE);
+		serviceName = g_string_new("facebook");
+	}
+	if (strcmp(serviceName->str, "meanwhile") == 0)
+	{
+		// Special case for sametime where the mojo serviceName is "type_sametime" and the prpl protocol_id is "prpl-meanwhile"
+		g_string_free(serviceName, TRUE);
+		serviceName = g_string_new("sametime");
+	}
+	if (strcmp(serviceName->str, "novell") == 0)
+	{
+		// Special case for groupwise where the mojo serviceName is "type_groupwise" and the prpl protocol_id is "prpl-novell"
+		g_string_free(serviceName, TRUE);
+		serviceName = g_string_new("groupwise");
+	}
+	if (strcmp(serviceName->str, "gg") == 0)
+	{
+		// Special case for gadu where the mojo serviceName is "type_gadu" and the prpl protocol_id is "prpl-gg"
+		g_string_free(serviceName, TRUE);
+		serviceName = g_string_new("gadu");
+	}
+	char* serviceNameToReturn = NULL;
+	// asprintf allocates appropriate-sized buffer
+	asprintf(&serviceNameToReturn, "type_%s", serviceName->str);
+	g_string_free(serviceName, TRUE);
+	return serviceNameToReturn;
+}
+
+static char* getAccountKey(const char* username, const char* serviceName)
+{
+	if (!username || !serviceName)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getAccountKey called with username=\"%s\" and serviceName=\"%s\""), username, serviceName);
+		return strdup("");
+	}
+	char *accountKey = NULL;
+	// asprintf allocates appropriate-sized buffer
+	asprintf(&accountKey, "%s_%s", username, serviceName);
+	return accountKey;
+}
+
+static char* getAuthRequestKey(const char* username, const char* serviceName, const char* remoteUsername)
+{
+	if (!username || !serviceName || !remoteUsername)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getAuthRequestKey - empty input parameter. username: %s, serviceName: %s, remoteUsername: %s"), username, serviceName, remoteUsername);
+		return strdup("");
+	}
+	char *authRequestKey = NULL;
+	// asprintf allocates appropriate-sized buffer
+	asprintf(&authRequestKey, "%s_%s_%s", username, serviceName, remoteUsername);
+	MojLogInfo(IMServiceApp::s_log, _T("getAuthRequestKey - username: %s, serviceName: %s, remoteUser: %s key: %s"), username, serviceName, remoteUsername, authRequestKey);
+	return authRequestKey;
+}
+
+static char* getAccountKeyFromPurpleAccount(PurpleAccount* account)
+{
+	if (!account)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getAccountKeyFromPurpleAccount called with empty account"));
+		return strdup("");
+	}
+	char* serviceName = getServiceNameFromPrplProtocolId(account);
+	char* username = getMojoFriendlyUsername(account->username, serviceName);
+	char* accountKey = getAccountKey(username, serviceName);
+
+	free(serviceName);
+	free(username);
+
+	return accountKey;
+}
+
+/**
+ * Returns a GString containing the special stanza to enable server-side presence update queue
+ * Clean up after yourself using g_string_free when you're done with the return value
+ */
+static GString* getEnableQueueStanza(PurpleAccount* account)
+{
+	GString* stanza = NULL;
+	if (account != NULL)
+	{
+		if (strcmp(account->protocol_id, "prpl-jabber") == 0)
+		{
+			stanza = g_string_new("");
+			PurpleConnection* pc = purple_account_get_connection(account);
+			if (pc == NULL)
+			{
+				return NULL;
+			}
+			const char* displayName = purple_connection_get_display_name(pc);
+			if (displayName == NULL)
+			{
+				return NULL;
+			}
+			g_string_append(stanza, "<iq from='");
+			g_string_append(stanza, displayName);
+			g_string_append(stanza, "' type='set'><query xmlns='google:queue'><enable/></query></iq>");
+		}
+		else if (strcmp(account->protocol_id, "prpl-aim") == 0)
+		{
+			MojLogInfo(IMServiceApp::s_log, _T("getEnableQueueStanza for AIM"));
+			stanza = g_string_new("true");
+		}
+	}
+	return stanza;
+}
+
+/**
+ * Returns a GString containing the special stanza to disable and flush the server-side presence update queue
+ * Clean up after yourself using g_string_free when you're done with the return value
+ */
+static GString* getDisableQueueStanza(PurpleAccount* account)
+{
+	GString* stanza = NULL;
+	if (account != NULL)
+	{
+		if (strcmp(account->protocol_id, "prpl-jabber") == 0)
+		{
+			stanza = g_string_new("");
+			PurpleConnection* pc = purple_account_get_connection(account);
+			if (pc == NULL)
+			{
+				return NULL;
+			}
+			const char* displayName = purple_connection_get_display_name(pc);
+			if (displayName == NULL)
+			{
+				return NULL;
+			}
+			g_string_append(stanza, "<iq from='");
+			g_string_append(stanza, displayName);
+			g_string_append(stanza, "' type='set'><query xmlns='google:queue'><disable/><flush/></query></iq>");
+		}
+		else if (strcmp(account->protocol_id, "prpl-aim") == 0)
+		{
+			MojLogInfo(IMServiceApp::s_log, _T("getDisableQueueStanza for AIM"));
+			stanza = g_string_new("false");
+		}
+	}
+	return stanza;
+}
+
+static void enableServerQueueForAccount(PurpleAccount* account)
+{
+	if (!account)
+	{
+		MojLogError(IMServiceApp::s_log, _T("enableServerQueueForAccount called with empty account"));
+		return;
+	}
+
+	PurplePluginProtocolInfo* prpl_info = NULL;
+	PurpleConnection* gc = purple_account_get_connection(account);
+	PurplePlugin* prpl = NULL;
+	
+	if (gc != NULL)
+	{
+		prpl = purple_connection_get_prpl(gc);
+	}
+
+	if (prpl != NULL)
+	{
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+	}
+
+	if (prpl_info && prpl_info->send_raw)
+	{
+		GString* enableQueueStanza = getEnableQueueStanza(account);
+		if (enableQueueStanza != NULL) 
+		{
+			MojLogInfo(IMServiceApp::s_log, _T("Enabling server queue for %s"), account->protocol_id);
+			prpl_info->send_raw(gc, enableQueueStanza->str, enableQueueStanza->len);
+			g_string_free(enableQueueStanza, TRUE);
+		}
+	}
+}
+
+static void disableServerQueueForAccount(PurpleAccount* account)
+{
+	if (!account)
+	{
+		MojLogError(IMServiceApp::s_log, _T("disableServerQueueForAccount called with empty account"));
+		return;
+	}
+	PurplePluginProtocolInfo* prpl_info = NULL;
+	PurpleConnection* gc = purple_account_get_connection(account);
+	PurplePlugin* prpl = NULL;
+	
+	if (gc != NULL)
+	{
+		prpl = purple_connection_get_prpl(gc);
+	}
+
+	if (prpl != NULL)
+	{
+		prpl_info = PURPLE_PLUGIN_PROTOCOL_INFO(prpl);
+	}
+
+	if (prpl_info && prpl_info->send_raw)
+	{
+		GString* disableQueueStanza = getDisableQueueStanza(account);
+		if (disableQueueStanza != NULL) 
+		{
+			MojLogInfo(IMServiceApp::s_log, _T("Disabling server queue"));
+			prpl_info->send_raw(gc, disableQueueStanza->str, disableQueueStanza->len);
+			g_string_free(disableQueueStanza, TRUE);
+		}
+	}
+}
+
+/**
+ * Asking the gtalk server to enable/disable queueing of presence updates 
+ * This is called when the screen is turned off (enable:true) or turned on (enable:false)
+ */
+bool LibpurpleAdapter::queuePresenceUpdates(bool enable)
+{
+	PurpleAccount* account;
+	GList* onlineAccountKeys = NULL;
+	GList* iterator = NULL;
+	char* accountKey = NULL;
+	
+	onlineAccountKeys = g_hash_table_get_keys(s_onlineAccountData);
+	for (iterator = onlineAccountKeys; iterator != NULL; iterator = g_list_next(iterator))
+	{
+		accountKey = (char*)iterator->data;
+		account = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+		if (account)
+		{
+			/*
+			 * enabling/disabling server queue is supported by gtalk (jabber) or aim
+			 */
+ 			if ((strcmp(account->protocol_id, "prpl-jabber") == 0) ||
+			    (strcmp(account->protocol_id, "prpl-aim") == 0))
+ 			{
+				if (enable)
+				{
+					enableServerQueueForAccount(account);
+				}
+				else
+				{
+					disableServerQueueForAccount(account);
+				}
+ 			}
+		}
+	}
+	return TRUE;
+}
+
+
+static int getPalmAvailabilityFromPurpleAvailability(int prplAvailability)
+{
+	switch (prplAvailability)
+	{
+	case PURPLE_STATUS_UNSET:
+		return PalmAvailability::NO_PRESENCE;
+	case PURPLE_STATUS_OFFLINE:
+		return PalmAvailability::OFFLINE;
+	case PURPLE_STATUS_AVAILABLE:
+		return PalmAvailability::ONLINE;
+	case PURPLE_STATUS_UNAVAILABLE:
+		return PalmAvailability::IDLE;
+	case PURPLE_STATUS_INVISIBLE:
+		return PalmAvailability::INVISIBLE;
+	case PURPLE_STATUS_AWAY:
+		return PalmAvailability::IDLE;
+	case PURPLE_STATUS_EXTENDED_AWAY:
+		return PalmAvailability::IDLE;
+	case PURPLE_STATUS_MOBILE:
+		return PalmAvailability::MOBILE;
+	case PURPLE_STATUS_TUNE:
+		return PalmAvailability::ONLINE;
+	default:
+		return PalmAvailability::OFFLINE;
+	}
+}
+
+
+static PurpleStatusPrimitive getPurpleAvailabilityFromPalmAvailability(int palmAvailability)
+{
+	switch (palmAvailability)
+	{
+	case PalmAvailability::ONLINE:
+		return PURPLE_STATUS_AVAILABLE;
+	case PalmAvailability::MOBILE:
+		return PURPLE_STATUS_MOBILE;
+	case PalmAvailability::IDLE:
+		return PURPLE_STATUS_AWAY;
+	case PalmAvailability::INVISIBLE:
+		return PURPLE_STATUS_INVISIBLE;
+	case PalmAvailability::OFFLINE:
+		return PURPLE_STATUS_OFFLINE;
+	default:
+		return PURPLE_STATUS_OFFLINE;
+	}
+}
+
+/*
+ * End of helper methods 
+ */
+
+/*
+ * Callbacks
+ */
+
+static void buddy_signed_on_off_cb(PurpleBuddy* buddy, gpointer data)
+{
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	PurpleAccount* account = purple_buddy_get_account(buddy);
+	char* accountKey = getAccountKeyFromPurpleAccount(account);
+	const char* accountId = (const char*)g_hash_table_lookup(s_AccountIdsData, accountKey);
+	if (NULL == accountId) {
+		MojLogError(IMServiceApp::s_log, _T("buddy_signed_on_off_cb: accountId not found in table. accountKey: %s"), accountKey);
+		free(accountKey);
+		return;
+	}
+
+	char* serviceName = getServiceNameFromPrplProtocolId(account);
+	PurpleStatus* activeStatus = purple_presence_get_active_status(purple_buddy_get_presence(buddy));
+	/*
+	 * Getting the new availability
+	 */
+	int newStatusPrimitive = purple_status_type_get_primitive(purple_status_get_type(activeStatus));
+	int newAvailabilityValue = getPalmAvailabilityFromPurpleAvailability(newStatusPrimitive);
+	PurpleBuddyIcon* icon = purple_buddy_get_icon(buddy);
+	const char* customMessage = "";
+	char* buddyAvatarLocation = NULL;
+
+	char* UserName = getMojoFriendlyUsername(account->username, serviceName);
+	char* templateId = getMojoFriendlyTemplateID(serviceName);
+
+	if (s_PrefsHandler->GetBoolPreference("Avatar", templateId, UserName) == true)
+	{
+		if (icon != NULL)
+		{
+			buddyAvatarLocation = purple_buddy_icon_get_full_path(icon);
+		}
+	}
+	else
+	{
+		buddyAvatarLocation = (char*)"";
+	}
+	
+	if (s_PrefsHandler->GetBoolPreference("Alias", templateId, UserName) == true)
+	{
+		if (buddy->server_alias == NULL)
+		{
+			buddy->server_alias = (char*)"";
+		}
+	}
+	else
+	{
+		if (buddy->alias == NULL)
+		{
+			buddy->alias = (char*)"";
+		}
+	}
+
+	customMessage = purple_status_get_attr_string(activeStatus, "message");
+	if (customMessage == NULL)
+	{
+		customMessage = "";
+	}
+
+	PurpleGroup* group = purple_buddy_get_group(buddy);
+	const char* groupName = purple_group_get_name(group);
+	if (groupName == NULL)
+	{
+		groupName = "";
+	}
+	
+	//Special for Office Communicator. (Remove 'sip:' prefix)
+	if (strcmp(serviceName, SERVICENAME_SIPE) == 0)
+	{
+		if (strstr(buddy->name, "sip:") != NULL)
+		{
+			GString *SIPBuddyAlias = g_string_new(buddy->name);
+			g_string_erase(SIPBuddyAlias, 0, 4);
+			buddy->name = SIPBuddyAlias->str;
+		}
+	}
+
+	// call into the imlibpurpletransport
+	// buddy->name is stored in the imbuddyStatus DB kind in the libpurple format - ie. for AIM without the "@aol.com" so that is how we need to search for it
+	s_imServiceHandler->updateBuddyStatus(accountId, serviceName, buddy->name, newAvailabilityValue,customMessage, groupName, buddyAvatarLocation);
+
+	if (s_PrefsHandler->GetBoolPreference("Alias", templateId, UserName) == true)
+	{
+		g_message(
+				"%s says: %s's presence: availability: '%i', custom message: '%s', avatar location: '%s', display name: '%s', group name: '%s'",
+				__FUNCTION__, buddy->name, newAvailabilityValue, customMessage, buddyAvatarLocation, buddy->server_alias, groupName);
+	}
+	else
+	{
+			g_message(
+				"%s says: %s's presence: availability: '%i', custom message: '%s', avatar location: '%s', display name: '%s', group name: '%s'",
+				__FUNCTION__, buddy->name, newAvailabilityValue, customMessage, buddyAvatarLocation, buddy->alias, groupName);
+	}
+	
+	free(serviceName);
+	free(accountKey);
+
+	/* if (buddyAvatarLocation)
+	{
+		g_free(buddyAvatarLocation);
+	} */
+}
+
+static void buddy_status_changed_cb(PurpleBuddy* buddy, PurpleStatus* old_status, PurpleStatus* new_status,
+		gpointer unused)
+{
+	/*
+	 * Getting the new availability
+	 */
+	int newStatusPrimitive = purple_status_type_get_primitive(purple_status_get_type(new_status));
+	int newAvailabilityValue = getPalmAvailabilityFromPurpleAvailability(newStatusPrimitive);
+
+	/*
+	 * Getting the new custom message
+	 */
+	const char* customMessage = purple_status_get_attr_string(new_status, "message");
+	if (customMessage == NULL)
+	{
+		customMessage = "";
+	}
+
+	LSError lserror;
+	LSErrorInit(&lserror);
+
+	PurpleAccount* account = purple_buddy_get_account(buddy);
+	char* accountKey = getAccountKeyFromPurpleAccount(account);
+	const char* accountId = (const char*)g_hash_table_lookup(s_AccountIdsData, accountKey);
+	if (NULL == accountId) {
+		MojLogError(IMServiceApp::s_log, _T("buddy_status_changed_cb: accountId not found in table. accountKey: %s"), accountKey);
+		free(accountKey);
+		return;
+	}
+	char* serviceName = getServiceNameFromPrplProtocolId(account);
+
+	PurpleBuddyIcon* icon = purple_buddy_get_icon(buddy);
+	char* buddyAvatarLocation = NULL;
+	
+	char* UserName = getMojoFriendlyUsername(account->username, serviceName);
+	char* templateId = getMojoFriendlyTemplateID(serviceName);
+	
+	if (s_PrefsHandler->GetBoolPreference("Avatar", templateId, UserName) == true)
+	{
+		if (icon != NULL)
+		{
+			buddyAvatarLocation = purple_buddy_icon_get_full_path(icon);
+		}
+	}
+	else
+	{
+		buddyAvatarLocation = (char*)"";
+	}
+
+	PurpleGroup* group = purple_buddy_get_group(buddy);
+	const char* groupName = purple_group_get_name(group);
+	if (groupName == NULL)
+	{
+		groupName = "";
+	}
+
+	//Special for Office Communicator. (Remove 'sip:' prefix)
+	if (strcmp(serviceName, SERVICENAME_SIPE) == 0)
+	{
+		if (strstr(buddy->name, "sip:") != NULL)
+		{
+			GString *SIPBuddyAlias = g_string_new(buddy->name);
+			g_string_erase(SIPBuddyAlias, 0, 4);
+			buddy->name = SIPBuddyAlias->str;
+		}
+	}
+	
+	// call into the imlibpurpletransport
+	// buddy->name is stored in the imbuddyStatus DB kind in the libpurple format - ie. for AIM without the "@aol.com" so that is how we need to search for it
+	s_imServiceHandler->updateBuddyStatus(accountId, serviceName, buddy->name, newAvailabilityValue, customMessage, groupName, buddyAvatarLocation);
+
+	if (s_PrefsHandler->GetBoolPreference("Alias", templateId, UserName) == true)
+	{
+		g_message(
+				"%s says: %s's presence: availability: '%i', custom message: '%s', avatar location: '%s', display name: '%s', group name: '%s'",
+				__FUNCTION__, buddy->name, newAvailabilityValue, customMessage, buddyAvatarLocation, buddy->server_alias, groupName);
+	}
+	else
+	{
+		g_message(
+			"%s says: %s's presence: availability: '%i', custom message: '%s', avatar location: '%s', display name: '%s', group name: '%s'",
+			__FUNCTION__, buddy->name, newAvailabilityValue, customMessage, buddyAvatarLocation, buddy->alias, groupName);
+	}
+	
+	if (serviceName)
+	{
+		free(serviceName);
+	}
+	free(accountKey);
+
+	/* if (buddyAvatarLocation)
+	{
+		g_free(buddyAvatarLocation);
+	} */
+}
+
+static void buddy_avatar_changed_cb(PurpleBuddy* buddy)
+{
+	PurpleStatus* activeStatus = purple_presence_get_active_status(purple_buddy_get_presence(buddy));
+	MojLogInfo(IMServiceApp::s_log, _T("buddy avatar changed for %s"), buddy->name);
+	buddy_status_changed_cb(buddy, activeStatus, activeStatus, NULL);
+}
+
+/*
+ * Called after we remove a buddy from out list
+ */
+static void buddy_removed_cb(PurpleBuddy* buddy)
+{
+	// nothing to do...
+	MojLogInfo(IMServiceApp::s_log, _T("buddy removed %s"), buddy->name);
+}
+
+/*
+ * Called both after we add a buddy to our list and when we accept a remote users' invitation to add us to their list
+ * buddy is the new buddy
+ */
+static void buddy_added_cb(PurpleBuddy* buddy)
+{
+	// nothing to do...
+	MojLogInfo(IMServiceApp::s_log, _T("buddy added %s"), buddy->name);
+}
+
+// testing. Never gets called...
+//static void sent_message_cb (PurpleAccount *account, const char *receiver, const char *message)
+//{
+//	MojLogInfo(IMServiceApp::s_log, _T("im message sent: %s, receiver %s"), message, receiver);
+//}
+
+bool LibpurpleAdapter::getFullBuddyList(const char* serviceName, const char* username)
+{
+	MojLogInfo(IMServiceApp::s_log, "%s called.", __FUNCTION__);
+
+	if (!serviceName || !username)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getBuddyList: Invalid parameter. Please double check the passed parameters."));
+		return FALSE;
+	}
+
+	if (s_loginState == NULL)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getBuddyList: s_loginState still null."));
+		return FALSE;
+	}
+
+	MojLogInfo(IMServiceApp::s_log, _T("getFullBuddyList: Parameters: serviceName %s, username %s"), serviceName, username);
+
+	/*
+	 * Send over the full buddy list if the account is already logged in
+	 */
+	bool success;
+	char* accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* account = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	if (account == NULL)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getFullBuddyList: ERROR: No account for %s on %s"), username, serviceName);
+		MojLogError(IMServiceApp::s_log, _T("getFullBuddyList !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! accountKey: %s"), accountKey);
+		success = FALSE;
+	}
+	else
+	{
+		success = TRUE;
+		GSList* buddyList = purple_find_buddies(account, NULL);
+		MojObject buddyListObj;
+		if (!buddyList)
+		{
+			MojLogError(IMServiceApp::s_log, _T("getFullBuddyList: WARNING: the buddy list was NULL, returning empty buddy list. accountKey %s"), accountKey);
+			s_loginState->buddyListResult(serviceName, username, buddyListObj, true);
+		}
+
+		GSList* buddyIterator = NULL;
+		PurpleBuddy* buddyToBeAdded = NULL;
+		PurpleGroup* group = NULL;
+		char* buddyAvatarLocation = NULL;
+
+		//printf("\n\n\n\n\n\n ---------------- BUDDY LIST SIZE: %d----------------- \n\n\n\n\n\n", g_slist_length(buddyList));
+		for (buddyIterator = buddyList; buddyIterator != NULL; buddyIterator = buddyIterator->next)
+		{
+			MojObject buddyObj;
+			buddyObj.clear(MojObject::TypeArray);
+			buddyToBeAdded = (PurpleBuddy*)buddyIterator->data;
+
+			buddyObj.putString("username", buddyToBeAdded->name);
+			buddyObj.putString("serviceName", serviceName);
+
+			group = purple_buddy_get_group(buddyToBeAdded);
+			const char* groupName = purple_group_get_name(group);
+			buddyObj.putString("group", groupName);
+
+			/*
+			 * Getting the availability
+			 */
+			PurpleStatus* status = purple_presence_get_active_status(purple_buddy_get_presence(buddyToBeAdded));
+			int newStatusPrimitive = purple_status_type_get_primitive(purple_status_get_type(status));
+			int availability = getPalmAvailabilityFromPurpleAvailability(newStatusPrimitive);
+			buddyObj.putInt("availability", availability);
+
+			char* templateId = getMojoFriendlyTemplateID((char*)serviceName);
+			
+			//Special for Office Communicator. (Remove 'sip:' prefix)
+			if (strcmp(serviceName, SERVICENAME_SIPE) == 0)
+			{
+				if (strstr(buddyToBeAdded->name, "sip:") != NULL)
+				{
+					GString *SIPBuddyAlias = g_string_new(buddyToBeAdded->name);
+					g_string_erase(SIPBuddyAlias, 0, 4);
+					buddyObj.putString("displayName", SIPBuddyAlias->str);
+				}
+				else
+				{
+					buddyObj.putString("displayName", buddyToBeAdded->name);
+				}
+			}
+			else
+			{
+				if (s_PrefsHandler->GetBoolPreference("Alias", templateId, username) == true)
+				{
+					if (buddyToBeAdded->server_alias != NULL)
+					{
+						buddyObj.putString("displayName", buddyToBeAdded->server_alias);
+					}
+				}
+				else
+				{
+					if (buddyToBeAdded->alias != NULL)
+					{
+						buddyObj.putString("displayName", buddyToBeAdded->alias);
+					}
+				}
+			}
+
+			PurpleBuddyIcon* icon = purple_buddy_get_icon(buddyToBeAdded);
+
+			if (s_PrefsHandler->GetBoolPreference("Avatar", templateId, username) == true)
+			{
+				if (icon != NULL)
+				{
+					buddyAvatarLocation = purple_buddy_icon_get_full_path(icon);
+					buddyObj.putString("avatar", buddyAvatarLocation);
+				}
+				else
+				{
+					buddyObj.putString("avatar", "");
+				}
+			}
+			else
+			{
+				buddyObj.putString("avatar", "");
+			}
+
+			const char* customMessage = purple_status_get_attr_string(status, "message");
+			if (customMessage != NULL)
+			{
+				buddyObj.putString("status", customMessage);
+			}
+
+			if (s_PrefsHandler->GetBoolPreference("Alias", templateId, username) == true)
+			{
+				g_message("%s says: %s's presence: availability: '%d', custom message: '%s', avatar location: '%s', display name: '%s', group name:'%s'",
+						__FUNCTION__, buddyToBeAdded->name, availability, customMessage, buddyAvatarLocation, buddyToBeAdded->server_alias, groupName);
+			}
+			else
+			{
+				g_message("%s says: %s's presence: availability: '%d', custom message: '%s', avatar location: '%s', display name: '%s', group name:'%s'",
+						__FUNCTION__, buddyToBeAdded->name, availability, customMessage, buddyAvatarLocation, buddyToBeAdded->alias, groupName);
+			}
+			
+			if (buddyAvatarLocation)
+			{
+				g_free(buddyAvatarLocation);
+				buddyAvatarLocation = NULL;
+			}
+
+			buddyListObj.push(buddyObj);
+		}
+
+		s_loginState->buddyListResult(serviceName, username, buddyListObj, true);
+
+		//TODO free the buddyList object???
+	}
+
+	if (accountKey)
+	{
+		free(accountKey);
+	}
+	return success;
+}
+
+typedef struct _LoginDetails
+{
+	PurpleAccount* account;
+	char* accountKey;
+	char* serviceName;
+	char* username;
+	gpointer loginState;
+} LoginDetails;
+
+gboolean BuddyListRefreshCallback(gpointer data)
+{
+	LoginDetails *logindetails = (LoginDetails*)data;
+
+	void* blist_handle = purple_blist_get_handle();
+	static int handle;
+	gpointer loginState = logindetails->loginState;
+	
+	char* accountKey = logindetails->accountKey;
+	PurpleAccount* loggedInAccount = (PurpleAccount*)logindetails->account;
+	char* serviceName = logindetails->serviceName;
+	char* username = logindetails->username;
+
+	if (g_hash_table_lookup(s_onlineAccountData, accountKey) != NULL)
+	{
+		/*
+		 * If the account is not pending anymore (which means login either already failed or succeeded) 
+		 * then we shouldn't have gotten to this point since we should have cancelled the timer
+		 */
+		MojLogError(IMServiceApp::s_log,
+				_T("WARNING: we shouldn't have gotten to BuddyListRefreshCallback since the account is not logged in. accountKey %s"), accountKey);
+		free(accountKey);
+		return TRUE;
+	}
+
+	/*
+	 * Remove the timer
+	 */
+	guint BuddyListtimerHandle = (guint)g_hash_table_lookup(s_accountBuddyListTimers, accountKey);
+	purple_timeout_remove(BuddyListtimerHandle);
+	g_hash_table_remove(s_accountBuddyListTimers, accountKey);
+	
+	// Don't free accountKey because s_onlineAccountData has a reference to it.
+	MojLogInfo(IMServiceApp::s_log, _T("account_logged_in_cb: inserting account into onlineAccountData hash table. accountKey %s"), accountKey);
+	g_hash_table_insert(s_onlineAccountData, accountKey, loggedInAccount);
+	g_hash_table_remove(s_pendingAccountData, accountKey);
+
+	MojLogInfo(IMServiceApp::s_log, _T("Account connected..."));
+
+	//reply with login success
+	if (loginState)
+	{
+		((LoginCallbackInterface*)loginState)->loginResult(serviceName, username, LoginCallbackInterface::LOGIN_SUCCESS, false, ERROR_NO_ERROR, false);
+	}
+	else
+	{
+		MojLogError(IMServiceApp::s_log, _T("ERROR: account_logged_in_cb called with loginState=NULL"));
+	}
+
+	if (s_registeredForPresenceUpdateSignals == FALSE)
+	{
+		purple_signal_connect(blist_handle, "buddy-status-changed", &handle, PURPLE_CALLBACK(buddy_status_changed_cb),
+				loginState);
+		purple_signal_connect(blist_handle, "buddy-signed-on", &handle, PURPLE_CALLBACK(buddy_signed_on_off_cb),
+				GINT_TO_POINTER(TRUE));
+		purple_signal_connect(blist_handle, "buddy-signed-off", &handle, PURPLE_CALLBACK(buddy_signed_on_off_cb),
+				GINT_TO_POINTER(FALSE));
+		purple_signal_connect(blist_handle, "buddy-icon-changed", &handle, PURPLE_CALLBACK(buddy_avatar_changed_cb),
+				GINT_TO_POINTER(FALSE));
+		purple_signal_connect(blist_handle, "buddy-removed", &handle, PURPLE_CALLBACK(buddy_removed_cb),
+				GINT_TO_POINTER(FALSE));
+		purple_signal_connect(blist_handle, "buddy-added", &handle, PURPLE_CALLBACK(buddy_added_cb),
+						GINT_TO_POINTER(FALSE));
+
+		// testing. Doesn't work: error - "Signal data for sent-im-msg not found". Need to figure out the right handle
+//		purple_signal_connect(purple_connections_get_handle(), "sent-im-msg", &handle, PURPLE_CALLBACK(sent_message_cb),
+//						GINT_TO_POINTER(FALSE));
+		s_registeredForPresenceUpdateSignals = TRUE;
+	}
+	
+	//Refresh the full buddy list
+	MojLogError(IMServiceApp::s_log, _T("BuddyListRefreshCallback accountKey: %s"), accountKey);
+	
+	return TRUE;
+}
+
+static void account_logged_in_cb(PurpleConnection* gc, gpointer loginState)
+{
+	PurpleAccount* loggedInAccount = purple_connection_get_account(gc);
+	g_return_if_fail(loggedInAccount != NULL);
+
+	char* serviceName = getServiceNameFromPrplProtocolId(loggedInAccount);
+	char* username = getMojoFriendlyUsername(loggedInAccount->username, serviceName);
+	char* accountKey = getAccountKey(username, serviceName);
+
+	if (g_hash_table_lookup(s_onlineAccountData, accountKey) != NULL)
+	{
+		// we were online. why are we getting notified that we're connected again? we were never disconnected.
+		// mark the account online just to be sure?
+		MojLogError(IMServiceApp::s_log, _T("account_logged_in_cb: account already online. why are we getting notified? accountKey %s"), accountKey);
+		free(serviceName);
+		free(username);
+		free(accountKey);
+		return;
+	}
+
+	/*
+	 * cancel the connect timeout for this account
+	 */
+	guint timerHandle = (guint)g_hash_table_lookup(s_accountLoginTimers, accountKey);
+	purple_timeout_remove(timerHandle);
+	g_hash_table_remove(s_accountLoginTimers, accountKey);
+	
+	//Create timer to refresh the buddy list after login
+	LoginDetails* logindetails = g_new0(LoginDetails, 1);
+	
+	logindetails->accountKey = accountKey;
+	logindetails->serviceName = serviceName;
+	logindetails->username = username;
+	logindetails->loginState = loginState;
+	logindetails->account = loggedInAccount;
+	
+	char* templateId = getMojoFriendlyTemplateID((char*)serviceName);
+	char* BuddyListTimeOut = s_PrefsHandler->GetStringPreference("BuddyListTimeOut", templateId, username);
+	static const guint BUDDY_LIST_REFRESH = (guint)atoi(BuddyListTimeOut);
+	guint BuddyListtimerHandle = purple_timeout_add_seconds(BUDDY_LIST_REFRESH, BuddyListRefreshCallback, logindetails);
+	g_hash_table_insert(s_accountBuddyListTimers, accountKey, (gpointer)BuddyListtimerHandle);
+	
+	MojLogError(IMServiceApp::s_log, _T("Login successful. Waiting %s seconds to ensure successful buddy list retrieval."),BuddyListTimeOut);
+}
+
+static void account_signed_off_cb(PurpleConnection* gc, gpointer loginState)
+{
+	PurpleAccount* account = purple_connection_get_account(gc);
+	g_return_if_fail(account != NULL);
+
+	char* accountKey = getAccountKeyFromPurpleAccount(account);
+	if (g_hash_table_lookup(s_onlineAccountData, accountKey) != NULL)
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("account_signed_off_cb: removing account from onlineAccountData hash table. accountKey %s"), accountKey);
+		g_hash_table_remove(s_onlineAccountData, accountKey);
+	}
+	else if (g_hash_table_lookup(s_pendingAccountData, accountKey) != NULL)
+	{
+		g_hash_table_remove(s_pendingAccountData, accountKey);
+	}
+	else
+	{
+		// Already signed off this account (or never signed in) so just return
+		free(accountKey);
+		return;
+	}
+
+	g_hash_table_remove(s_ipAddressesBoundTo, accountKey);
+	//g_hash_table_remove(connectionTypeData, accountKey);
+
+	MojLogInfo(IMServiceApp::s_log, _T("Account disconnected..."));
+
+	if (g_hash_table_lookup(s_offlineAccountData, accountKey) == NULL)
+	{
+		/*
+		 * Keep the PurpleAccount struct to reuse in future logins
+		 */
+		g_hash_table_insert(s_offlineAccountData, accountKey, account);
+	}
+	
+	// reply with signed off
+	if (loginState)
+	{
+		char* serviceName = getServiceNameFromPrplProtocolId(account);
+		char* myMojoFriendlyUsername = getMojoFriendlyUsername(account->username, serviceName);
+		((LoginCallbackInterface*)loginState)->loginResult(serviceName, myMojoFriendlyUsername, LoginCallbackInterface::LOGIN_SIGNED_OFF, false, ERROR_NO_ERROR, true);
+		free(serviceName);
+		free(myMojoFriendlyUsername);
+	}
+	else
+	{
+		MojLogError(IMServiceApp::s_log, _T("ERROR: account_logged_in_cb called with loginState=NULL"));
+	}
+
+	free(accountKey);
+}
+
+/*
+ * This callback is called if a) the login attempt failed, or b) login was successful but the session was closed 
+ * (e.g. connection problems, etc).
+ */
+static void account_login_failed_cb(PurpleConnection* gc, PurpleConnectionError type, const gchar* description,
+		gpointer loginState)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("account_login_failed is called with description %s"), description);
+
+	PurpleAccount* account = purple_connection_get_account(gc);
+	g_return_if_fail(account != NULL);
+
+	gboolean loggedOut = FALSE;
+	bool noRetry = true;
+	char* serviceName = getServiceNameFromPrplProtocolId(account);
+	char* username = getMojoFriendlyUsername(account->username, serviceName);
+	char* accountKey = getAccountKey(username, serviceName);
+
+	if (g_hash_table_lookup(s_onlineAccountData, accountKey) != NULL)
+	{
+		/* 
+		 * We were online on this account and are now disconnected because either a) the data connection is dropped, 
+		 * b) the server is down, or c) the user has logged in from a different location and forced this session to
+		 * get closed.
+		 */
+		// Special handling for broken network connection errors (due to bad coverage or flight mode)
+		if (type == 0)//PURPLE_CONNECTION_ERROR_NETWORK_ERROR)
+		{
+			MojLogInfo(IMServiceApp::s_log, _T("We had a network error. Reason: %s, prpl error code: %i"), description, type);
+			noRetry = false;
+		}
+		else
+		{
+			loggedOut = TRUE;
+			MojLogInfo(IMServiceApp::s_log, _T("We were logged out. Reason: %s, prpl error code: %i"), description, type);
+		}
+	}
+	else
+	{
+		/*
+		 * cancel the connect timeout for this account
+		 */
+		guint timerHandle = (guint)g_hash_table_lookup(s_accountLoginTimers, accountKey);
+		purple_timeout_remove(timerHandle);
+		g_hash_table_remove(s_accountLoginTimers, accountKey);
+		
+		//Cancel the buddy list timer
+		guint BuddyListtimerHandle = (guint)g_hash_table_lookup(s_accountBuddyListTimers, accountKey);
+		purple_timeout_remove(BuddyListtimerHandle);
+		g_hash_table_remove(s_accountBuddyListTimers, accountKey);
+
+		if (g_hash_table_lookup(s_pendingAccountData, accountKey) == NULL)
+		{
+			/*
+			 * This account was in neither of the account data lists (online or pending). We must have logged it out 
+			 * and not cared about letting mojo know about it (probably because mojo went down and came back up and
+			 * thought that the account was logged out anyways)
+			 */
+			MojLogError(IMServiceApp::s_log, _T("account_login_failed_cb: account in neither online or pending list. Why are we getting logged out? accountKey: %s description %s:"),
+					accountKey, description);
+			// don't leak!
+			free(serviceName);
+			free(username);
+			free(accountKey);
+			return;
+		}
+		else
+		{
+			g_hash_table_remove(s_pendingAccountData, accountKey);
+		}
+	}
+
+	const char* mojoFriendlyErrorCode = getMojoFriendlyErrorCode(type);
+	const char* accountBoundToIpAddress = (char*)g_hash_table_lookup(s_ipAddressesBoundTo, accountKey);
+	const char* connectionType = (char*)g_hash_table_lookup(s_connectionTypeData, accountKey);
+
+	if (accountBoundToIpAddress == NULL)
+	{
+		accountBoundToIpAddress = "";
+	}
+
+	if (connectionType == NULL)
+	{
+		connectionType = "";
+	}
+	MojLogInfo(IMServiceApp::s_log, _T("account_login_failed_cb: removing account from onlineAccountData hash table. accountKey %s"), accountKey);
+	g_hash_table_remove(s_onlineAccountData, accountKey);
+	g_hash_table_remove(s_ipAddressesBoundTo, accountKey);
+	g_hash_table_remove(s_connectionTypeData, accountKey);
+ 
+	if (g_hash_table_lookup(s_offlineAccountData, accountKey) == NULL)
+	{
+		/*
+		 * Keep the PurpleAccount struct to reuse in future logins
+		 */
+		g_hash_table_insert(s_offlineAccountData, accountKey, account);
+		// don't free the accountKey in this case since now s_offlineAccountData points to it
+		accountKey = NULL;
+	}
+	
+	// reply with login failed
+	if (loginState != NULL)
+	{
+		//TODO: determine if there are cases where noRetry should be false
+		//TODO: include "description" parameter because it had useful details?
+		((LoginCallbackInterface*)loginState)->loginResult(serviceName, username, LoginCallbackInterface::LOGIN_FAILED, loggedOut, mojoFriendlyErrorCode, noRetry);
+	}
+	else
+	{
+		MojLogError(IMServiceApp::s_log, _T("ERROR: account_login_failed_cb called with loginState=NULL"));
+	}
+	free(serviceName);
+	free(username);
+	if (NULL != accountKey)
+		free(accountKey);
+}
+
+static void account_status_changed(PurpleAccount* account, PurpleStatus* oldStatus, PurpleStatus* newStatus, gpointer loginState)
+{
+	printf("\n\n ACCOUNT STATUS CHANGED \n\n");
+}
+
+/*
+ *  This gets called then we decline a remote user's buddy invite
+ *  TODO - what signal gets emitted when a remote user declines our invitation???
+ */
+static void account_auth_deny_cb(PurpleAccount* account, const char* remote_user)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("account_auth_deny_cb called. account: %s, remote_user: %s"), account->username, remote_user);
+
+	// TODO this needs to happen when remote user declines our invite, not here...
+//	char* serviceName = getServiceNameFromPrplProtocolId(account);
+//	char* username = getMojoFriendlyUsername(account->username, serviceName);
+//	char* usernameFromStripped = stripResourceFromGtalkUsername(remote_user, serviceName);
+//
+//	// tell transport to delete the buddy and contacts
+//	s_imServiceHandler->buddyInviteDeclined(serviceName, username, usernameFromStripped);
+//
+//	// clean up
+//	free(serviceName);
+//	free(username);
+//	free(usernameFromStripped);
+
+
+}
+
+/*
+ * This gets called then we accept a remote user's buddy invite
+ *      log: account_auth_accept_cb called. account: palm@gmail.com/Home, buddy: palm3@gmail.com
+ */
+static void account_auth_accept_cb(PurpleAccount* account, const char* remote_user)
+{
+	// nothing to do
+	MojLogInfo(IMServiceApp::s_log, _T("account_auth_accept_cb called. account: %s, remote_user: %s"), account->username, remote_user);
+}
+
+
+void incoming_message_cb(PurpleConversation* conv, const char* who, const char* alias, const char* message,
+		PurpleMessageFlags flags, time_t mtime)
+{
+	/*
+	 * snippet taken from nullclient
+	 */
+	const char* usernameFrom;
+	if (who &&* who)
+		usernameFrom = who;
+	else if (alias &&* alias)
+		usernameFrom = alias;
+	else
+		usernameFrom = "";
+
+	if ((flags & PURPLE_MESSAGE_RECV) != PURPLE_MESSAGE_RECV)
+	{
+		/* this is a sent message. ignore it. */
+		return;
+	}
+
+	PurpleAccount* account = purple_conversation_get_account(conv);
+
+	// these never return null...
+	char* serviceName = getServiceNameFromPrplProtocolId(account);
+	char* username = getMojoFriendlyUsername(account->username, serviceName);
+
+	if (strcmp(username, usernameFrom) == 0) // TODO: should this compare use account->username?
+	{
+		/* We get notified even though we sent the message. Just ignore it */
+		free(serviceName);
+		free(username);
+		return;
+	}
+
+	if (strcmp(serviceName, SERVICENAME_AIM) == 0 && (strcmp(usernameFrom, "aolsystemmsg") == 0 || strcmp(usernameFrom,
+			"AOL System Msg") == 0))
+	{
+		/*
+		 * ignore messages from aolsystemmsg telling us that we're logged in somewhere else
+		 */
+		free(serviceName);
+		free(username);
+		return;
+	}
+
+	char* usernameFromStripped = stripResourceFromGtalkUsername(usernameFrom, serviceName);
+	
+	//Special for Office Communicator. (Remove 'sip:' prefix)
+	if (strcmp(serviceName, SERVICENAME_SIPE) == 0)
+	{
+		if (strstr(usernameFromStripped, "sip:") != NULL)
+		{
+			GString *SIPBuddyAlias = g_string_new(usernameFromStripped);
+			g_string_erase(SIPBuddyAlias, 0, 4);
+			usernameFromStripped = (char*)SIPBuddyAlias->str;
+		}
+	}
+
+	// call the transport service incoming message handler
+	s_imServiceHandler->incomingIM(serviceName, username, usernameFromStripped, message);
+
+	free(serviceName);
+	free(username);
+	free(usernameFromStripped);
+}
+
+/*
+ * Called when a remote user requests authorization to be our buddy
+ *
+ * Note: this method will get called every time user logs in if there is a pending invitation.
+ */
+static void *request_authorize_cb (PurpleAccount *account, const char *remote_user, const char *id,	const char *alias, const char *message,
+	gboolean on_list, PurpleAccountRequestAuthorizationCb authorize_cb,	PurpleAccountRequestAuthorizationCb deny_cb,
+	void *user_data)
+{
+
+	MojLogInfo(IMServiceApp::s_log, _T("request_authorize_cb called. remote user: %s, id: %s, message: %s"), remote_user, id, message);
+
+	// these never return null...
+	char* serviceName = getServiceNameFromPrplProtocolId(account);
+	char* username = getMojoFriendlyUsername(account->username, serviceName);
+	char* usernameFromStripped = stripResourceFromGtalkUsername(remote_user, serviceName);
+
+	// Save off the authorize/deny callbacks to use later
+	AuthRequest *aa = g_new0(AuthRequest, 1);
+	aa->auth_cb = authorize_cb;
+	aa->deny_cb = deny_cb;
+	aa->data = user_data;
+	aa->remote_user = g_strdup(remote_user);
+	aa->alias = g_strdup(alias);
+	aa->account = account;
+
+	char *authRequestKey = getAuthRequestKey(username, serviceName, usernameFromStripped);
+	// if there is already an entry for this, we need to replace it since callback function pointers will change on login
+	// old object gets deleted by our destroy functions specified in the hash table construction
+	g_hash_table_replace(s_AuthorizeRequests, authRequestKey, aa);
+	// log the table
+	logAuthRequestTableValues();
+
+	// call back into IMServiceHandler to create a receivedBuddyInvite imCommand.
+	s_imServiceHandler->receivedBuddyInvite(serviceName, username, usernameFromStripped, message);
+
+	free(serviceName);
+	free(username);
+	free(usernameFromStripped);
+	// don't free the authRequestKey - it is not copied, but held onto for the life of the hash table once inserted
+
+	return NULL;
+
+}
+
+/*
+ * Not used
+ */
+void request_add_cb(PurpleAccount *account, const char *remote_user, const char *id, const char *alias, const char *message) {
+
+	MojLogInfo(IMServiceApp::s_log, _T("request_add_cb called. remote user: %s"), remote_user);
+}
+
+gboolean connectTimeoutCallback(gpointer data)
+{
+	char* accountKey = (char*)data;
+	PurpleAccount* account = (PurpleAccount*)g_hash_table_lookup(s_pendingAccountData, accountKey);
+	if (account == NULL)
+	{
+		/*
+		 * If the account is not pending anymore (which means login either already failed or succeeded) 
+		 * then we shouldn't have gotten to this point since we should have cancelled the timer
+		 */
+		MojLogError(IMServiceApp::s_log,
+				_T("WARNING: we shouldn't have gotten to connectTimeoutCallback since login had already failed/succeeded. accountKey %s"), accountKey);
+		free(accountKey);
+		return FALSE;
+	}
+
+	/*
+	 * abort logging in since our connect timeout has hit before login either failed or succeeded
+	 */
+	g_hash_table_remove(s_accountLoginTimers, accountKey);
+	g_hash_table_remove(s_pendingAccountData, accountKey);
+	g_hash_table_remove(s_ipAddressesBoundTo, accountKey);
+	g_hash_table_remove(s_accountBuddyListTimers, accountKey);
+
+	purple_account_disconnect(account);
+
+	if (s_loginState)
+	{
+		char* serviceName = getServiceNameFromPrplProtocolId(account);
+		char* username = getMojoFriendlyUsername(account->username, serviceName);
+
+		s_loginState->loginResult(serviceName, username, LoginCallbackInterface::LOGIN_TIMEOUT, false, ERROR_NETWORK_ERROR, true);
+
+		free(serviceName);
+		free(username);
+	}
+	else
+	{
+		MojLogError(IMServiceApp::s_log, _T("ERROR: connectTimeoutCallback called with s_loginState=NULL. accountKey %s"), accountKey);
+	}
+
+	free(accountKey);
+	return FALSE;
+}
+
+/*
+ * End of callbacks
+ */
+
+/*
+ * libpurple initialization methods
+ */
+
+static GHashTable* getClientInfo(void)
+{
+	GHashTable* clientInfo = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	g_hash_table_insert(clientInfo, (void*)"name", (void*)"Palm Messaging");
+	g_hash_table_insert(clientInfo, (void*)"version", (void*)"");
+
+	return clientInfo;
+}
+
+static void initializeLibpurple()
+{
+	signal(SIGCHLD, SIG_IGN);
+
+	/* Set a custom user directory (optional) */
+	purple_util_set_user_dir(CUSTOM_USER_DIRECTORY);
+
+	/* We do not want any debugging for now to keep the noise to a minimum. */
+	purple_debug_set_enabled(TRUE);
+
+	/* Set the core-uiops, which is used to
+	 * 	- initialize the ui specific preferences.
+	 * 	- initialize the debug ui.
+	 * 	- initialize the ui components for all the modules.
+	 * 	- uninitialize the ui components for all the modules when the core terminates.
+	 */
+	purple_core_set_ui_ops(&adapterCoreUIOps);
+	
+	/* Set path to search for plugins. The core (libpurple) takes care of loading the
+	* core-plugins, which includes the protocol-plugins. So it is not essential to add
+	* any path here, but it might be desired, especially for ui-specific plugins. */
+	purple_plugins_add_search_path(CUSTOM_PLUGIN_PATH);
+
+	purple_eventloop_set_ui_ops(&adapterEventLoopUIOps);
+
+	// TODO - there is a memory leak in here...at least on desktop
+	if (!purple_core_init(UI_ID))
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("libpurple initialization failed."));
+		abort();
+	}
+
+	/* Create and load the buddylist. */
+	purple_set_blist(purple_blist_new());
+	purple_blist_load();
+
+	purple_buddy_icons_set_cache_dir("/var/luna/data/im-avatars");
+
+	s_libpurpleInitialized = TRUE;
+	MojLogInfo(IMServiceApp::s_log, _T("libpurple initialized.\n"));
+}
+/*
+ * End of libpurple initialization methods
+ */
+ 
+/*
+ * Service methods
+ */ 
+LibpurpleAdapter::LoginResult LibpurpleAdapter::login(LoginParams* params, LoginCallbackInterface* loginState)
+{	
+	LoginResult result = LibpurpleAdapter::OK;
+
+	PurpleAccount* account;
+	char* prplProtocolId = NULL;
+	char* transportFriendlyUserName = NULL;
+	char* accountKey = NULL;
+	bool accountIsAlreadyOnline = FALSE;
+	bool accountIsAlreadyPending = FALSE;
+
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	PurpleAccount* alreadyActiveAccount = NULL;
+
+	if (!params || !params->serviceName || params->serviceName[0] == 0 || !params->username || params->username[0] == 0)
+	{
+		MojLogError(IMServiceApp::s_log, _T("LibpurpleAdapter::login with empty username or serviceName"));
+		result = LibpurpleAdapter::INVALID_CREDENTIALS;
+		goto error;
+	}
+
+	if (!params->localIpAddress)
+	{
+		params->localIpAddress = "";
+	}
+	
+	if (!params->connectionType)
+	{
+		params->connectionType = "";
+	}
+
+	MojLogInfo(IMServiceApp::s_log, _T("Parameters: accountId %s, servicename %s, connectionType %s"), params->accountId, params->serviceName, params->connectionType);
+
+	if (s_libpurpleInitialized == FALSE)
+	{
+		initializeLibpurple();
+	}
+
+	/* libpurple variables */
+	accountKey = getAccountKey(params->username, params->serviceName);
+
+	// If this account id isn't yet stored, then keep track of it now.
+	if (g_hash_table_lookup(s_AccountIdsData, accountKey) == NULL)
+	{
+		g_hash_table_insert(s_AccountIdsData, accountKey, strdup(params->accountId));
+	}
+
+	/*
+	 * Let's check to see if we're already logged in to this account or that we're already in the process of logging in 
+	 * to this account. This can happen when mojo goes down and comes back up.
+	 */
+	alreadyActiveAccount = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	if (alreadyActiveAccount != NULL)
+	{
+		accountIsAlreadyOnline = TRUE;
+	}
+	else
+	{
+		alreadyActiveAccount = (PurpleAccount*)g_hash_table_lookup(s_pendingAccountData, accountKey);
+		if (alreadyActiveAccount != NULL)
+		{
+			accountIsAlreadyPending = TRUE;
+		}
+	}
+
+	if (alreadyActiveAccount != NULL)
+	{
+		/*
+		 * We're either already logged in to this account or we're already in the process of logging in to this account 
+		 * (i.e. it's pending; waiting for server response)
+		 */
+		char* accountBoundToIpAddress = (char*)g_hash_table_lookup(s_ipAddressesBoundTo, accountKey);
+		if (accountBoundToIpAddress != NULL && strcmp(params->localIpAddress, accountBoundToIpAddress) == 0)
+		{
+			/*
+			 * We're using the right interface for this account
+			 */
+			if (accountIsAlreadyPending)
+			{
+				MojLogError(IMServiceApp::s_log, _T("LibpurpleAdapter::login: We were already in the process of logging in. accountKey %s"), accountKey);
+				return LibpurpleAdapter::OK;
+			}
+			else if (accountIsAlreadyOnline)
+			{
+				MojLogError(IMServiceApp::s_log, _T("LibpurpleAdapter::login: We were already logged in to the requested account. accountKey %s"), accountKey);
+				return LibpurpleAdapter::ALREADY_LOGGED_IN;
+			}
+		}
+		else
+		{
+			/*
+			 * We're not using the right interface. Close the current connection for this account and create a new one
+			 */
+			MojLogError(IMServiceApp::s_log,
+					_T("LibpurpleAdapter::login: We have to logout and login again since the local IP address has changed. Logging out from account. accountKey %s"), accountKey);
+			/*
+			 * Once the current connection is closed we don't want to let mojo know that the account was disconnected.
+			 * Since mojo went down and came back up it didn't know that the account was connected anyways.
+			 * So let's take the account out of the account data hash and then disconnect it.
+			 */
+			if (g_hash_table_lookup(s_onlineAccountData, accountKey) != NULL)
+			{
+				MojLogInfo(IMServiceApp::s_log, _T("LibpurpleAdapter::login: removing account from onlineAccountData hash table. accountKey %s"), accountKey);
+				g_hash_table_remove(s_onlineAccountData, accountKey);
+			}
+			if (g_hash_table_lookup(s_pendingAccountData, accountKey) != NULL)
+			{
+				g_hash_table_remove(s_pendingAccountData, accountKey);
+			}
+			purple_account_disconnect(alreadyActiveAccount);
+		}
+	}
+
+	/*
+	 * Let's go through our usual login process
+	 */
+
+	// TODO this currently ignores authentication token, but should check it as well when support for auth token is added
+	if (params->password == NULL || params->password[0] == 0)
+	{
+		MojLogError(IMServiceApp::s_log, _T("Error: null or empty password trying to log in to servicename %s"), params->serviceName);
+		result = LibpurpleAdapter::INVALID_CREDENTIALS;
+		goto error;
+	}
+	else
+	{
+		/* save the local IP address that we need to use */
+		// TODO - move this to #ifdef. If you are running imlibpurpletransport on desktop, but tethered to device, params->localIpAddress needs to be set to
+		// NULL otherwise login will fail...
+		if (params->localIpAddress != NULL && params->localIpAddress[0] != 0)
+		{
+			purple_prefs_remove("/purple/network/preferred_local_ip_address");
+			purple_prefs_add_string("/purple/network/preferred_local_ip_address", params->localIpAddress);
+		}
+		else
+		{
+#ifdef DEVICE
+			/*
+			 * If we're on device you should not accept an empty ipAddress; it's mandatory to be provided
+			 */
+			MojLogError(IMServiceApp::s_log, _T("LibpurpleAdapter::login with missing localIpAddress"));
+			result = FAILED;
+			goto error;
+#endif
+		}
+
+		/* save the local IP address that we need to use */
+		if (params->connectionType != NULL && params->connectionType[0] != 0)
+		{
+			g_hash_table_insert(s_connectionTypeData, accountKey, strdup(params->connectionType));
+		}
+
+		prplProtocolId = getPrplProtocolIdFromServiceName(params->serviceName);
+		/*
+		 * If we've already logged in to this account before then re-use the old PurpleAccount struct
+		 */
+		transportFriendlyUserName = getPrplFriendlyUsername(params->serviceName, params->username);
+		account = (PurpleAccount*)g_hash_table_lookup(s_offlineAccountData, accountKey);
+		if (!account)
+		{
+			/* Create the account */
+			account = purple_account_new(transportFriendlyUserName, prplProtocolId);
+			if (!account)
+			{
+				MojLogError(IMServiceApp::s_log, _T("LibpurpleAdapter::login failed to create new Purple account"));
+				result = LibpurpleAdapter::FAILED;
+				goto error;
+			}
+		}
+
+		//Load account preferences
+		char* templateId = getMojoFriendlyTemplateID((char*)params->serviceName);
+		
+		if (strcmp((char*)params->serviceName, SERVICENAME_JABBER) == 0)
+		{
+			//Set Account Alias to jabber
+			purple_account_set_alias (account,"jabber");
+		}
+		if (strcmp((char*)params->serviceName,SERVICENAME_GTALK) == 0)
+		{
+			//Set Account Alias to gtalk
+			purple_account_set_alias (account,"gtalk");
+		}
+		
+		MojString m_templateId;
+		m_templateId.assign(templateId);
+		s_PrefsHandler->setaccountprefs(m_templateId,account);
+		//Load account preferences
+		MojLogInfo(IMServiceApp::s_log, _T("Logging in..."));
+
+		purple_account_set_password(account, params->password);
+	}
+
+	if (result == LibpurpleAdapter::OK)
+	{
+		/* mark the account as pending */
+		g_hash_table_insert(s_pendingAccountData, accountKey, account);
+
+		if (params->localIpAddress != NULL && params->localIpAddress[0] != 0)
+		{
+			/* keep track of the local IP address that we bound to when logging in to this account */
+			g_hash_table_insert(s_ipAddressesBoundTo, accountKey, strdup(params->localIpAddress));
+		}
+
+		/* It's necessary to enable the account first. */
+		purple_account_set_enabled(account, UI_ID, TRUE);
+
+		/* Now, to connect the account, create a status and activate it. */
+
+		/*
+		 * Create a timer for this account's login so it can fail the login after a timeout.
+		 */
+		char* UserName = getMojoFriendlyUsername(params->username, params->serviceName);
+		char* templateId = getMojoFriendlyTemplateID((char*)params->serviceName);
+		static const guint CONNECT_TIMEOUT_SECONDS = (guint)atoi(s_PrefsHandler->GetStringPreference("LoginTimeOut", templateId, UserName));
+		guint timerHandle = purple_timeout_add_seconds(CONNECT_TIMEOUT_SECONDS, connectTimeoutCallback, accountKey);
+		g_hash_table_insert(s_accountLoginTimers, accountKey, (gpointer)timerHandle);
+
+		PurpleStatusPrimitive prim = getPurpleAvailabilityFromPalmAvailability(params->availability);
+		PurpleSavedStatus* savedStatus = purple_savedstatus_new(NULL, prim);
+		if (params->customMessage && params->customMessage[0])
+		{
+			purple_savedstatus_set_message(savedStatus, params->customMessage);
+		}
+		purple_savedstatus_activate_for_account(savedStatus, account);
+	}
+
+	error:
+
+	if (prplProtocolId)
+	{
+		free(prplProtocolId);
+	}
+	if (transportFriendlyUserName)
+	{
+		free(transportFriendlyUserName);
+	}
+
+	return result;
+}
+
+bool LibpurpleAdapter::logout(const char* serviceName, const char* username, LoginCallbackInterface* loginState)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	if (!username || !serviceName)
+	{
+		MojLogError(IMServiceApp::s_log, _T("Invalid logout parameter. Please double check the passed parameters."));
+		return FALSE;
+	}
+
+	bool success = TRUE;
+
+	MojLogInfo(IMServiceApp::s_log, _T("Parameters: servicename %s"), serviceName);
+
+	char* accountKey = getAccountKey(username, serviceName);
+
+	// Remove the accountId since a logout could be from the user removing the account
+	g_hash_table_remove(s_AccountIdsData, accountKey);
+
+	PurpleAccount* accountTologoutFrom = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	if (accountTologoutFrom == NULL)
+	{
+		accountTologoutFrom = (PurpleAccount*)g_hash_table_lookup(s_pendingAccountData, accountKey);
+		if (accountTologoutFrom == NULL)
+		{
+			MojLogError(IMServiceApp::s_log, _T("Trying to logout from an account that is not logged in. username %s, service name %s, accountKey %s"), username, serviceName, accountKey);
+			success = FALSE;
+		}
+	}
+
+	if (accountTologoutFrom != NULL)
+	{
+		purple_account_disconnect(accountTologoutFrom);
+	}
+
+	if (accountKey)
+	{
+		free(accountKey);
+	}
+	return success;
+}
+
+bool LibpurpleAdapter::setMyAvailability(const char* serviceName, const char* username, int availability)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	if (!serviceName || !username)
+	{
+		MojLogError(IMServiceApp::s_log, _T("setMyAvailability: Invalid parameter. Please double check the passed parameters."));
+		return FALSE;
+	}
+
+	MojLogInfo(IMServiceApp::s_log, _T("Parameters: serviceName %s, availability %i"), serviceName, availability);
+
+	bool retVal = FALSE;
+	char* accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* account = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	if (account == NULL)
+	{
+		//this should never happen based on MessagingService's logic
+		MojLogError(IMServiceApp::s_log,
+				_T("setMyAvailability was called on an account that wasn't logged in. serviceName: %s, availability: %i"),
+				serviceName, availability);
+		retVal = FALSE;
+	}
+	else
+	{
+		retVal = TRUE;
+		/*
+		 * Let's get the current custom message and set it as well so that we don't overwrite it with ""
+		 */
+		PurplePresence* presence = purple_account_get_presence(account);
+		const PurpleStatus* status = purple_presence_get_active_status(presence);
+		const PurpleValue* value = purple_status_get_attr_value(status, "message");
+		const char* customMessage = NULL;
+		if (value != NULL)
+		{
+			customMessage = purple_value_get_string(value);
+		}
+		if (customMessage == NULL)
+		{
+			customMessage = "";
+		}
+
+		PurpleStatusPrimitive prim = getPurpleAvailabilityFromPalmAvailability(availability);
+		PurpleStatusType* type = purple_account_get_status_type_with_primitive(account, prim);
+		GList* attrs = NULL;
+		attrs = g_list_append(attrs, (void*)"message");
+		attrs = g_list_append(attrs, (char*)customMessage);
+		purple_account_set_status_list(account, purple_status_type_get_id(type), TRUE, attrs);
+	}
+
+	// delete the key since it was just for lookup
+	free(accountKey);
+	return retVal;
+}
+
+bool LibpurpleAdapter::setMyCustomMessage(const char* serviceName, const char* username, const char* customMessage)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	if (!serviceName || !username || !customMessage)
+	{
+		MojLogError(IMServiceApp::s_log, _T("setMyCustomMessage: Invalid parameter. Please double check the passed parameters."));
+		return FALSE;
+	}
+
+	MojLogInfo(IMServiceApp::s_log, _T("Parameters: serviceName %s"), serviceName);
+
+	bool retVal = FALSE;
+	char* accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* account = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	if (account == NULL)
+	{
+		//this should never happen based on MessagingService's logic
+		MojLogError(IMServiceApp::s_log,
+				_T("setMyCustomMessage was called on an account that wasn't logged in. serviceName: %s"),
+				serviceName);
+		retVal = FALSE;
+	}
+	else
+	{
+		retVal = TRUE;
+		// get the account's current status type
+		PurpleStatusType* type = purple_status_get_type(purple_account_get_active_status(account));
+		GList* attrs = NULL;
+		attrs = g_list_append(attrs, (void*)"message");
+		attrs = g_list_append(attrs, (char*)customMessage);
+		purple_account_set_status_list(account, purple_status_type_get_id(type), TRUE, attrs);
+	}
+
+	// delete the key since it was just for lookup
+	free(accountKey);
+	return retVal;
+}
+
+/*
+ * Block this user from sending us messages
+ */
+LibpurpleAdapter::SendResult LibpurpleAdapter::blockBuddy(const char* serviceName, const char* username, const char* buddyUsername, bool block)
+{
+	bool success = FALSE;
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	if (!serviceName || !username || !buddyUsername)
+	{
+		MojLogError(IMServiceApp::s_log, _T("blockBuddy: null parameter. username %s, service name %s, buddyUsername %s"), username, serviceName, buddyUsername);
+		return INVALID_PARAMS;
+	}
+
+	char* accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* account = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	success = (account != NULL);
+	if (success)
+	{
+		// strip off the "@aol.com" if needed
+		char *transportFriendlyUserName = getPrplFriendlyUsername(serviceName, buddyUsername);
+		if (block)
+		{
+			MojLogInfo(IMServiceApp::s_log, _T("blockBuddy: deny %s"), transportFriendlyUserName);
+			purple_privacy_deny(account, transportFriendlyUserName, false, true);
+		}
+		else
+		{
+			MojLogInfo(IMServiceApp::s_log, _T("blockBuddy: allow %s"), transportFriendlyUserName);
+			purple_privacy_allow(account, transportFriendlyUserName, false, true);
+		}
+		free(transportFriendlyUserName);
+	}
+	else
+	{
+		MojLogError(IMServiceApp::s_log, "blockBuddy: Trying to send from an account that is not logged in. username %s, service name %s, accountKey %s", username, serviceName, accountKey);
+	}
+
+	if (accountKey)
+	{
+		free(accountKey);
+	}
+
+	if (success)
+		return SENT;
+	else return USER_NOT_LOGGED_IN;
+}
+
+/*
+ * Remove a buddy from our account
+ */
+LibpurpleAdapter::SendResult LibpurpleAdapter::removeBuddy(const char* serviceName, const char* username, const char* buddyUsername)
+{
+	bool success = FALSE;
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	if (!serviceName || !username || !buddyUsername)
+	{
+		MojLogError(IMServiceApp::s_log, _T("removeBuddy: null parameter. username %s, service name %s, buddyUsername %s"), username, serviceName, buddyUsername);
+		return INVALID_PARAMS;
+	}
+
+	char* accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* account = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	success = (account != NULL);
+	if (success)
+	{
+		// strip off the "@aol.com" if needed
+		char *transportFriendlyUserName = getPrplFriendlyUsername(serviceName, buddyUsername);
+		MojLogInfo(IMServiceApp::s_log, _T("removeBuddy: %s"), transportFriendlyUserName);
+
+		PurpleBuddy* buddy = purple_find_buddy(account, transportFriendlyUserName);
+		if (NULL == buddy) {
+			MojLogError(IMServiceApp::s_log, _T("could not find buddy %s in list - cannot remove"), transportFriendlyUserName);
+			success = FALSE;
+		}
+		else {
+			PurpleGroup* group = purple_buddy_get_group(buddy);
+			// remove from server list
+			purple_account_remove_buddy(account, buddy, group);
+
+			// remove from buddy list - generates a "buddy-removed" signal
+			purple_blist_remove_buddy(buddy);
+		}
+
+		free(transportFriendlyUserName);
+	}
+	else
+	{
+		MojLogError(IMServiceApp::s_log, "removeBuddy: Trying to send from an account that is not logged in. username %s, service name %s, accountKey %s", username, serviceName, accountKey);
+	}
+
+	if (accountKey)
+	{
+		free(accountKey);
+	}
+
+	if (success)
+		return SENT;
+	else return USER_NOT_LOGGED_IN;
+}
+
+/*
+ * Add a buddy to our buddy list. Some services (GTalk) will require the buddy to authorize us to add them
+ */
+LibpurpleAdapter::SendResult LibpurpleAdapter::addBuddy(const char* serviceName, const char* username, const char* buddyUsername, const char* groupName)
+{
+	bool success = FALSE;
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	if (!serviceName || !username || !buddyUsername)
+	{
+		MojLogError(IMServiceApp::s_log, _T("addBuddy: null parameter. username %s, service name %s, buddyUsername %s"), username, serviceName, buddyUsername);
+		return INVALID_PARAMS;
+	}
+
+	char* accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* account = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	success = (account != NULL);
+	if (success)
+	{
+		// strip off the "@aol.com" if needed
+		char *transportFriendlyUserName = getPrplFriendlyUsername(serviceName, buddyUsername);
+		MojLogInfo(IMServiceApp::s_log, _T("addBuddy: %s"), transportFriendlyUserName);
+
+		PurpleBuddy* buddy = purple_buddy_new(account, transportFriendlyUserName, /*alias*/ NULL);
+
+		// add buddy to list
+		/*
+		void purple_blist_add_buddy  	(  	PurpleBuddy *   	 buddy,
+				PurpleContact *  	contact,
+				PurpleGroup *  	group,
+				PurpleBlistNode *  	node
+			)
+
+		Adds a new buddy to the buddy list.
+		The buddy will be inserted right after node or prepended to the group if node is NULL. If both are NULL, the buddy will be added to the "Buddies" group.
+		*/
+		PurpleGroup *group = NULL;
+		if (NULL != groupName && *groupName != '\0') {
+			group = purple_find_group(groupName);
+			if (NULL == group){
+				// group not there - add it
+				MojLogInfo(IMServiceApp::s_log, _T("addBuddy: adding new group %s"), groupName);
+				group = purple_group_new(groupName);
+			}
+		}
+		purple_blist_add_buddy(buddy, NULL, group, NULL);
+
+		// add to server - note: this has to be called AFTER the purple_blist_add_buddy() call otherwise it seg faults...
+		purple_account_add_buddy(account, buddy);
+
+		// note - there seems to be an inconsistency in libpurple where AIM buddies added via purple appear offline until the account is logged off and on...
+		// see http://pidgin.im/pipermail/devel/2007-June/001517.html:
+		/*	Such is not the case on AIM, however.  The behavior I see here is that the
+			buddies appear in the Pidgin blist but always have an offline status, even
+			though I know at least four of these people are online.  Looking at blist.xml
+			after the next shown flush in the debug window shows that nothing has been added
+			to the local list.  The alias and buddy notes are not added, either.  The status
+			remains incorrect until I restart Pidgin, disable and enable the account, or
+			switch to the offline status and then back to an online status.  At this point,
+			the buddies are finally shown in blist.xml and statuses are correct; however,
+			the alias and notes string that were set at import are missing.  Behavior is
+			identical on ICQ when importing a list of AIM buddies (which to my limited
+			knowledge does not require authorization).
+		*/
+
+		free(transportFriendlyUserName);
+	}
+	else
+	{
+		MojLogError(IMServiceApp::s_log, "addBuddy: Trying to send from an account that is not logged in. username %s, service name %s, accountKey %s", username, serviceName, accountKey);
+	}
+
+	if (accountKey)
+	{
+		free(accountKey);
+	}
+
+	if (success)
+		return SENT;
+	else return USER_NOT_LOGGED_IN;
+}
+
+/*
+ * Authorize the remote user to be our buddy
+ */
+LibpurpleAdapter::SendResult LibpurpleAdapter::authorizeBuddy(const char* serviceName, const char* username, const char* fromUsername)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("authorizeBuddy: username: %s, serviceName: %s, buddyUsername: %s"), username, serviceName, fromUsername);
+
+	if (!serviceName || !username || !fromUsername)
+	{
+		MojLogError(IMServiceApp::s_log, _T("authorizeBuddy: null parameter. cannot process command"));
+		return INVALID_PARAMS;
+	}
+
+	// if we got here, we need to be online...
+	char *accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* onlineAccount = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+
+	if (onlineAccount == NULL)
+	{
+		MojLogError(IMServiceApp::s_log, _T("authorizeBuddy: account not online. accountKey: %s"), accountKey);
+		free (accountKey);
+		return USER_NOT_LOGGED_IN;
+	}
+	// free key since it was only used for lookup
+	free (accountKey);
+
+	// create the key and find the auth_and_add object in the s_AuthorizeRequests table
+	char *authRequestKey = getAuthRequestKey(username, serviceName, fromUsername);
+	AuthRequest *aa = (AuthRequest *)g_hash_table_lookup(s_AuthorizeRequests, authRequestKey);
+	if (NULL == aa)
+	{
+		MojLogError(IMServiceApp::s_log, "authorizeBuddy: cannot find auth request object - authRequestKey %s", authRequestKey);
+		// log the table
+		logAuthRequestTableValues();
+		free (authRequestKey);
+		return SEND_FAILED;
+	}
+
+	// authorize account
+	aa->auth_cb(aa->data);
+
+	// TODO - do we need to add this user to our buddy list? Libpurple seems to add it automatically - appears at next login.
+
+	// we are done with this request - remove it from list
+	// object and key held by table get deleted by our destroy functions specified in the hash table construction
+	g_hash_table_remove(s_AuthorizeRequests, authRequestKey);
+
+	// free key used for look-up
+	free (authRequestKey);
+
+	return SENT;
+}
+
+/*
+ * Decline the request from the remote user to be our buddy
+ */
+LibpurpleAdapter::SendResult LibpurpleAdapter::declineBuddy(const char* serviceName, const char* username, const char* fromUsername)
+{
+	MojLogError(IMServiceApp::s_log, _T("declineBuddy: username: %s, serviceName: %s, buddyUsername: %s"), username, serviceName, fromUsername);
+	if (!serviceName || !username || !fromUsername)
+	{
+		MojLogError(IMServiceApp::s_log, _T("declineBuddy: null parameter. cannot process command"));
+		return INVALID_PARAMS;
+	}
+
+	// if we got here, we need to be online...
+	char *accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* onlineAccount = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+	if (onlineAccount == NULL)
+	{
+		MojLogError(IMServiceApp::s_log, _T("declineBuddy: account not online. accountKey: %s"), accountKey);
+		free (accountKey);
+		return USER_NOT_LOGGED_IN;
+	}
+	// free key since it was only used for lookup
+	free (accountKey);
+
+	// create the key and find the auth_and_add object in the s_AuthorizeRequests table
+	char *authRequestKey = getAuthRequestKey(username, serviceName, fromUsername);
+	AuthRequest *aa = (AuthRequest *)g_hash_table_lookup(s_AuthorizeRequests, authRequestKey);
+	if (NULL == aa)
+	{
+		MojLogError(IMServiceApp::s_log, "declineBuddy: cannot find auth request object - authRequestKey %s", authRequestKey);
+		// log the table
+		logAuthRequestTableValues();
+		free (authRequestKey);
+		return SEND_FAILED;
+	}
+
+	aa->deny_cb(aa->data);
+
+	// we are done with this request - remove it from list
+	// object gets deleted by our destroy functions specified in the hash table construction
+	g_hash_table_remove(s_AuthorizeRequests, authRequestKey);
+
+	// free key used for look-up
+	free (authRequestKey);
+	return SENT;
+}
+
+LibpurpleAdapter::SendResult LibpurpleAdapter::sendMessage(const char* serviceName, const char* username, const char* usernameTo, const char* messageText)
+{
+	if (!serviceName || !username || !usernameTo || !messageText)
+	{
+		MojLogError(IMServiceApp::s_log, _T("sendMessage: Invalid parameter. Please double check the passed parameters."));
+		return LibpurpleAdapter::INVALID_PARAMS;
+	}
+
+	LibpurpleAdapter::SendResult retVal = LibpurpleAdapter::SENT;
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	char* accountKey = getAccountKey(username, serviceName);
+	PurpleAccount* accountToSendFrom = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+
+	if (accountToSendFrom == NULL)
+	{
+		retVal = LibpurpleAdapter::USER_NOT_LOGGED_IN;
+		MojLogError(IMServiceApp::s_log, _T("sendMessage: Trying to send from an account that is not logged in. username %s, service name %s, accountKey %s"), username, serviceName, accountKey);
+	}
+	else
+	{
+		// strip off the "@aol.com" if needed
+		char *transportFriendlyUserName = getPrplFriendlyUsername(serviceName, usernameTo);
+		PurpleConversation* purpleConversation = purple_conversation_new(PURPLE_CONV_TYPE_IM, accountToSendFrom, transportFriendlyUserName);
+		char* messageTextUnescaped = g_strcompress(messageText);
+
+		// replace this with the lower level call so we can try to get an error code back...
+		// calls common_send which calls serv_send_im (conversation.c)
+//		purple_conv_im_send(purple_conversation_get_im_data(purpleConversation), messageTextUnescaped);
+//				common_send(PurpleConversation *conv, const char *message, PurpleMessageFlags msgflags)
+//					gc = purple_conversation_get_gc(conv);
+//					err = serv_send_im(gc, purple_conversation_get_name(conv), sent, msgflags);
+		// we still don't seem to get an error value back there...returns 1, even for an invalid recipient
+		int err = serv_send_im(purple_conversation_get_gc(purpleConversation), purple_conversation_get_name(purpleConversation), messageTextUnescaped, (PurpleMessageFlags)0);
+		if (err < 0) {
+			retVal = LibpurpleAdapter::SEND_FAILED;
+			MojLogError(IMServiceApp::s_log, _T("sendMessage: serv_send_im returned err %d"), err);
+		}
+
+		free(messageTextUnescaped);
+		free(transportFriendlyUserName);
+	}
+	if (accountKey)
+		free(accountKey);
+	return retVal;
+}
+
+
+// Called by IMLoginState whenever a connection interface goes down.
+// If all==true, then all interfaces went down.
+bool LibpurpleAdapter::deviceConnectionClosed(bool all, const char* ipAddress)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	if (!ipAddress)
+	{
+		return FALSE;
+	}
+
+	PurpleAccount* account;
+	GSList* accountToLogoutList = NULL;
+	GList* iterator = NULL;
+
+	GList* onlineAndPendingAccountKeys = g_hash_table_get_keys(s_ipAddressesBoundTo);
+	for (iterator = onlineAndPendingAccountKeys; iterator != NULL; iterator = g_list_next(iterator))
+	{
+		char* accountKey = (char*)iterator->data;
+		char* accountBoundToIpAddress = (char*)g_hash_table_lookup(s_ipAddressesBoundTo, accountKey);
+		if (all == true || (accountBoundToIpAddress != NULL && strcmp(ipAddress, accountBoundToIpAddress) == 0))
+		{
+			bool accountWasLoggedIn = FALSE;
+
+			account = (PurpleAccount*)g_hash_table_lookup(s_onlineAccountData, accountKey);
+			if (account == NULL)
+			{
+				account = (PurpleAccount*)g_hash_table_lookup(s_pendingAccountData, accountKey);
+				if (account == NULL)
+				{
+					MojLogInfo(IMServiceApp::s_log, _T("account was not found in the hash"));
+					continue;
+				}
+				MojLogInfo(IMServiceApp::s_log, _T("Abandoning login"));
+			}
+			else
+			{
+				accountWasLoggedIn = TRUE;
+				MojLogInfo(IMServiceApp::s_log, _T("Logging out"));
+			}
+
+			if (g_hash_table_lookup(s_onlineAccountData, accountKey) != NULL)
+			{
+				MojLogInfo(IMServiceApp::s_log, _T("deviceConnectionClosed: removing account from onlineAccountData hash table. accountKey %s"), accountKey);
+				g_hash_table_remove(s_onlineAccountData, accountKey);
+			}
+			if (g_hash_table_lookup(s_pendingAccountData, accountKey) != NULL)
+			{
+				g_hash_table_remove(s_pendingAccountData, accountKey);
+			}
+			if (g_hash_table_lookup(s_offlineAccountData, accountKey) == NULL)
+			{
+				/*
+				 * Keep the PurpleAccount struct to reuse in future logins
+				 */
+				g_hash_table_insert(s_offlineAccountData, accountKey, account);
+			}
+			
+			purple_account_disconnect(account);
+
+			accountToLogoutList = g_slist_append(accountToLogoutList, account);
+
+			MojLogInfo(IMServiceApp::s_log, _T("deviceConnectionClosed: removing account from onlineAccountData hash table. accountKey %s"), accountKey);
+			g_hash_table_remove(s_onlineAccountData, accountKey);
+			// We can't remove this guy since we're iterating through its keys. We'll remove it after the break
+			//g_hash_table_remove(ipAddressesBoundTo, accountKey);
+		}
+	}
+
+	if (g_slist_length(accountToLogoutList) == 0)
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("No accounts were connected on the requested ip address"));
+	}
+	else
+	{
+		GSList* accountIterator = NULL;
+		for (accountIterator = accountToLogoutList; accountIterator != NULL; accountIterator = accountIterator->next)
+		{
+			account = (PurpleAccount*) accountIterator->data;
+			char* serviceName = getServiceNameFromPrplProtocolId(account);
+			char* username = getMojoFriendlyUsername(account->username, serviceName);
+			char* accountKey = getAccountKey(username, serviceName);
+
+			g_hash_table_remove(s_ipAddressesBoundTo, accountKey);
+
+			free(serviceName);
+			free(username);
+			free(accountKey);
+		}
+	}
+
+	return TRUE;
+}
+
+void LibpurpleAdapter::assignIMLoginState(LoginCallbackInterface* loginState)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	static int handle = 0x1AD;
+	s_loginState = loginState;
+
+	if (s_registeredForAccountSignals == TRUE)
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("Disconnecting old signals."));
+		s_registeredForAccountSignals = FALSE;
+
+		purple_signal_disconnect(purple_connections_get_handle(), "signed-on", &handle,
+				PURPLE_CALLBACK(account_logged_in_cb));
+		purple_signal_disconnect(purple_connections_get_handle(), "signed-off", &handle,
+				PURPLE_CALLBACK(account_signed_off_cb));
+		purple_signal_disconnect(purple_connections_get_handle(), "connection-error", &handle,
+				PURPLE_CALLBACK(account_login_failed_cb));
+
+		purple_signal_disconnect(purple_accounts_get_handle(), "account-status-changed", &handle,
+				PURPLE_CALLBACK(account_status_changed));
+		purple_signal_disconnect(purple_accounts_get_handle(), "account-authorization-denied", &handle,
+				PURPLE_CALLBACK(account_auth_deny_cb));
+		purple_signal_disconnect(purple_accounts_get_handle(), "account-authorization-granted", &handle,
+				PURPLE_CALLBACK(account_auth_accept_cb));
+	}
+
+	if (loginState != NULL)
+	{
+		MojLogInfo(IMServiceApp::s_log, _T("Connecting new signals."));
+		s_registeredForAccountSignals = TRUE;
+		/*
+		 * Listen for a number of different signals:
+		 */
+		purple_signal_connect(purple_connections_get_handle(), "signed-on", &handle,
+				PURPLE_CALLBACK(account_logged_in_cb), loginState);
+		purple_signal_connect(purple_connections_get_handle(), "signed-off", &handle,
+				PURPLE_CALLBACK(account_signed_off_cb), loginState);
+		purple_signal_connect(purple_connections_get_handle(), "connection-error", &handle,
+				PURPLE_CALLBACK(account_login_failed_cb), loginState);
+
+		// accounts signals
+		purple_signal_connect(purple_accounts_get_handle(), "account-status-changed", &handle,
+				PURPLE_CALLBACK(account_status_changed), loginState);
+		purple_signal_connect(purple_accounts_get_handle(), "account-authorization-denied", &handle,
+				PURPLE_CALLBACK(account_auth_deny_cb), loginState);
+		purple_signal_connect(purple_accounts_get_handle(), "account-authorization-granted", &handle,
+			   PURPLE_CALLBACK(account_auth_accept_cb), loginState);
+	}
+}
+
+void LibpurpleAdapter::assignIMServiceHandler(IMServiceCallbackInterface* imServiceHandler)
+{
+	MojLogInfo(IMServiceApp::s_log, _T("%s called."), __FUNCTION__);
+
+	s_imServiceHandler = imServiceHandler;
+}
+
+void LibpurpleAdapter::assignPrefsHandler(LibpurplePrefsHandler* PrefsHandler)
+{
+	s_PrefsHandler = PrefsHandler;
+}
+
+/*
+ * Value destroy function for s_AuthorizeRequests
+ */
+static void deleteAuthRequest(void* obj)
+{
+	AuthRequest *aa = (AuthRequest *)obj;
+	MojLogInfo(IMServiceApp::s_log, _T("deleteAuthRequest: deleting auth request object. account: %s, remote_user: %s"), aa->account->username, aa->remote_user);
+ 	g_free(aa->remote_user);
+	g_free(aa->alias);
+	g_free(aa);
+}
+
+void LibpurpleAdapter::init()
+{
+	//TODO: replace the NULLs with real functions to prevent memory leaks
+	/* g_hash_table_new_full() Creates a new GHashTable like g_hash_table_new() and allows one to specify functions to free the memory allocated for the key and value that get called when removing the entry from the GHashTable.
+	 * Parameters:
+			hash_func:	a function to create a hash value from a key.
+			key_equal_func:	a function to check two keys for equality.
+			key_destroy_func:	a function to free the memory allocated for the key used when removing the entry from the GHashTable or NULL if you don't want to supply such a function.
+			value_destroy_func:	a function to free the memory allocated for the value used when removing the entry from the GHashTable or NULL if you don't want to supply such a function.
+			Returns:	a new GHashTable.
+	*/
+	s_onlineAccountData = g_hash_table_new_full(g_str_hash, g_str_equal, free, NULL);
+	s_pendingAccountData = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_accountLoginTimers = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_ipAddressesBoundTo = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, free);
+	s_connectionTypeData = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, free);
+	s_AccountIdsData = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, free);
+	s_offlineAccountData = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_AuthorizeRequests = g_hash_table_new_full(g_str_hash, g_str_equal, free, deleteAuthRequest);
+	s_accountBuddyListTimers = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	
+	initializeLibpurple();
+}
diff -rupN imlibpurpleservice-1.0/src/LibpurpleAdapterPrefs.cpp imlibpurpleservice-1.0-new//src/LibpurpleAdapterPrefs.cpp
--- imlibpurpleservice-1.0/src/LibpurpleAdapterPrefs.cpp	2011-03-25 10:45:40.752552999 -0600
+++ imlibpurpleservice-1.0-new//src/LibpurpleAdapterPrefs.cpp	2011-03-27 09:10:06.196553000 -0600
@@ -139,6 +139,9 @@ static char* getMojoFriendlyServiceName
 	else if (strcmp(templateId, CAPABILITY_LIVE) == 0){
 		return (char*)SERVICENAME_LIVE;
 	}
+	else if (strcmp(templateId, CAPABILITY_WLM) == 0){
+		return (char*)SERVICENAME_WLM;
+	}
 	else if (strcmp(templateId, CAPABILITY_MYSPACE) == 0){
 		return (char*)SERVICENAME_MYSPACE;
 	}
@@ -627,6 +630,7 @@ static char* getServiceNameFromPrplProto
 		MojLogError(IMServiceApp::s_log, _T("getServiceNameFromPrplProtocolId called with empty protocolId"));
 		return strdup("type_default");
 	}
+	MojLogError(IMServiceApp::s_log, _T("getServiceNameFromPrplProtocolId, prplProtocolId = %s"), prplProtocolId);
 	char* stringChopper = prplProtocolId;
 	stringChopper += strlen("prpl-");
 	GString* serviceName = g_string_new(stringChopper);
@@ -643,6 +647,12 @@ static char* getServiceNameFromPrplProto
 		g_string_free(serviceName, true);
 		serviceName = g_string_new("live");
 	}
+	if (strcmp(serviceName->str, "msn-pecan") == 0)
+	{
+		// Special case for wlm where the mojo serviceName is "type_wlm" and the prpl protocol_id is "prpl-msn-pecan"
+		g_string_free(serviceName, true);
+		serviceName = g_string_new("wlm");
+	}
 	if (strcmp(serviceName->str, "bigbrownchunx-facebookim") == 0)
 	{
 		// Special case for facebook where the mojo serviceName is "type_facebook" and the prpl protocol_id is "prpl-bigbrownchunx-facebookim"
@@ -667,6 +677,7 @@ static char* getServiceNameFromPrplProto
 		g_string_free(serviceName, true);
 		serviceName = g_string_new("gadu");
 	}
+	MojLogError(IMServiceApp::s_log, _T("getServiceNameFromPrplProtocolId, serviceName = %s"),serviceName->str);
 	char* serviceNameToReturn = NULL;
 	// asprintf allocates appropriate-sized buffer
 	asprintf(&serviceNameToReturn, "type_%s", serviceName->str);
diff -rupN imlibpurpleservice-1.0/src/LibpurpleAdapterPrefs.cpp~ imlibpurpleservice-1.0-new//src/LibpurpleAdapterPrefs.cpp~
--- imlibpurpleservice-1.0/src/LibpurpleAdapterPrefs.cpp~	1969-12-31 18:00:00.000000000 -0600
+++ imlibpurpleservice-1.0-new//src/LibpurpleAdapterPrefs.cpp~	2011-03-27 09:10:06.180553000 -0600
@@ -0,0 +1,821 @@
+/*
+ * LibpurpleAdapterPrefs.cpp
+ *
+ */
+
+#include "LibpurpleAdapterPrefs.h"
+#include "LibpurpleAdapter.h"
+#include "PalmImCommon.h"
+#include "IMServiceApp.h"
+#include "db/MojDbServiceClient.h"
+
+/*
+ * list of account preferences
+ */
+static GHashTable* s_AccountAliases = NULL;
+static GHashTable* s_AccountAvatars = NULL;
+static GHashTable* s_AccountBadCert = NULL;
+static GHashTable* s_ServerName = NULL;
+static GHashTable* s_ServerPort = NULL;
+static GHashTable* s_ServerTLS = NULL;
+static GHashTable* s_LoginTimeOut = NULL;
+static GHashTable* s_BuddyListTimeOut = NULL;
+
+static GHashTable* s_SametimeHideID = NULL;
+static GHashTable* s_SIPEServerProxy = NULL;
+static GHashTable* s_SIPEUserAgent = NULL;
+static GHashTable* s_XFireVersion = NULL;
+static GHashTable* s_SIPEServerLogin = NULL;
+static GHashTable* s_JabberResource = NULL;
+
+LibpurpleAdapterPrefs::LibpurpleAdapterPrefs(MojService* service)
+: m_findCommandSlot(this, &LibpurpleAdapterPrefs::findCommandResult),
+  m_service(service),
+  m_dbClient(service)
+{
+	
+}
+
+LibpurpleAdapterPrefs::~LibpurpleAdapterPrefs() {
+	
+}
+
+inline const char * const BoolToString(bool b)
+{
+	return b ? "true" : "false";
+}
+
+inline bool StringToBool(char* c)
+{
+	if(c == NULL)
+	{
+		return false;
+	}
+	if (strcmp(c, "false") == 0)
+	{
+		return false;
+	}
+	if (strcmp(c, "true") == 0)
+	{
+		return true;
+	}
+	return false;
+}
+
+/*
+ * The messaging service expects the username to be in the username@domain.com format, whereas the AIM prpl uses the username only
+ * Free the returned string when you're done with it 
+ */
+static char* getMojoFriendlyUsername(const char* username, const char* serviceName)
+{
+	if (!username || !serviceName)
+	{
+		return strdup("");
+	}
+	GString* mojoFriendlyUsername = g_string_new(username);
+	if (strcmp(serviceName, SERVICENAME_AIM) == 0 && strchr(username, '@') == NULL)
+	{
+		g_string_append(mojoFriendlyUsername, "@aol.com");
+	}
+	else if (strcmp(serviceName, SERVICENAME_GTALK) == 0)
+	{
+		char* resource = (char*)memchr(username, '/', strlen(username));
+		if (resource != NULL)
+		{
+			int charsToKeep = resource - username;
+			g_string_erase(mojoFriendlyUsername, charsToKeep, -1);
+		}
+	}
+	else if (strcmp(serviceName, SERVICENAME_JABBER) == 0)
+	{
+		if (strstr(username, "/") != NULL)
+		{
+			//If jabber resource is blank remove /
+			char *resource = (char*)memchr(username, '/', strlen(username));
+			if (resource != NULL)
+			{
+				int charsToKeep = resource - username;
+				g_string_erase(mojoFriendlyUsername, charsToKeep, -1);
+			}
+		}
+	}
+	else if (strcmp(serviceName, SERVICENAME_SIPE) == 0)
+	{
+		char *resource = (char*)memchr(username, ',', strlen(username));
+		if (resource != NULL)
+		{
+			int charsToKeep = resource - username;
+			g_string_erase(mojoFriendlyUsername, charsToKeep, -1);
+		}
+	}
+	char* mojoFriendlyUsernameToReturn = strdup(mojoFriendlyUsername->str);
+	g_string_free(mojoFriendlyUsername, true);
+	return mojoFriendlyUsernameToReturn;
+}
+
+static char* getMojoFriendlyServiceName (const char* templateId)
+{
+	if (strcmp(templateId, CAPABILITY_AIM) == 0) {
+		return (char*)SERVICENAME_AIM;
+	}
+	else if (strcmp(templateId, CAPABILITY_FACEBOOK) == 0){
+		return (char*)SERVICENAME_FACEBOOK;
+	}
+	else if (strcmp(templateId, CAPABILITY_GTALK) == 0){
+		return (char*)SERVICENAME_GTALK;
+	}
+	else if (strcmp(templateId, CAPABILITY_GADU) == 0){
+		return (char*)SERVICENAME_GADU;
+	}
+	else if (strcmp(templateId, CAPABILITY_GROUPWISE) == 0){
+		return (char*)SERVICENAME_GROUPWISE;
+	}
+	else if (strcmp(templateId, CAPABILITY_ICQ) == 0){
+		return (char*)SERVICENAME_ICQ;
+	}
+	else if (strcmp(templateId, CAPABILITY_JABBER) == 0){
+		return (char*)SERVICENAME_JABBER;
+	}
+	else if (strcmp(templateId, CAPABILITY_LIVE) == 0){
+		return (char*)SERVICENAME_LIVE;
+	}
+	else if (strcmp(templateId, CAPABILITY_WLM) == 0){
+		return (char*)SERVICENAME_WLM;
+	}
+	else if (strcmp(templateId, CAPABILITY_MYSPACE) == 0){
+		return (char*)SERVICENAME_MYSPACE;
+	}
+	else if (strcmp(templateId, CAPABILITY_QQ) == 0){
+		return (char*)SERVICENAME_QQ;
+	}
+	else if (strcmp(templateId, CAPABILITY_SAMETIME) == 0){
+		return (char*)SERVICENAME_SAMETIME;
+	}
+	else if (strcmp(templateId, CAPABILITY_SIPE) == 0){
+		return (char*)SERVICENAME_SIPE;
+	}
+	else if (strcmp(templateId, CAPABILITY_XFIRE) == 0){
+		return (char*)SERVICENAME_XFIRE;
+	}
+	else if (strcmp(templateId, CAPABILITY_YAHOO) == 0){
+		return (char*)SERVICENAME_YAHOO;
+	}
+	
+	return (char*)"";
+}
+
+//Preferences methods
+MojErr LibpurpleAdapterPrefs::LoadAccountPreferences(const char* templateId, const char* UserName)
+{
+	MojString m_templateId;
+	MojString m_UserName;
+	m_templateId.assign(templateId);
+	m_UserName.assign(UserName);
+
+	// Create the query
+	MojDbQuery query;
+	MojErr err;
+	
+	//If the template is empty load everything
+	if (!strcmp(m_templateId, "") == 0)
+	{
+		err = query.where("templateId", MojDbQuery::OpEq, m_templateId);
+		MojErrCheck(err);
+
+		err = query.where("UserName", MojDbQuery::OpEq, m_UserName);
+		MojErrCheck(err);
+	}
+
+	// add our kind to the object
+	err = query.from("org.webosinternals.messaging.prefs:1");
+	MojErrCheck(err);
+	
+	// log the query
+	MojObject queryObject;
+	err = query.toObject(queryObject);
+	MojErrCheck(err);
+	
+	MojString json;
+	queryObject.toJson(json);
+	MojLogError(IMServiceApp::s_log, _T("LoadAccountPreference Query: %s"), json.data());
+	
+	if (err) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("LoadAccountPreference Query failed: error %d - %s"), err, error.data());
+		return err;
+	}
+
+	// query DB
+	err = m_dbClient.find(this->m_findCommandSlot, query, true);
+	
+	if (err) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("LoadAccountPreference Query find failed: error %d - %s"), err, error.data());
+		return err;
+	}
+	
+	return MojErrNone;
+}
+
+/*
+ * Callback for the prefs query
+ */
+MojErr LibpurpleAdapterPrefs::findCommandResult(MojObject& result, MojErr findErr)
+{
+	MojLogTrace(IMServiceApp::s_log);
+
+	if (findErr) {
+		MojString error;
+		MojErrToString(findErr, error);
+		MojLogError(IMServiceApp::s_log, _T("findCommandResult failed: error %d - %s"), findErr, error.data());
+
+	} else {
+		// get the results
+		MojString mojStringJson;
+		result.toJson(mojStringJson);
+		MojLogError(IMServiceApp::s_log, _T("findCommandResult result: %s"), mojStringJson.data());
+
+		MojObject results;
+
+		// get results array in "results"
+		result.get(_T("results"), results);
+		
+		//Are there results?
+		if (!results.empty())
+		{
+			bool BadCert = false;
+			bool EnableAlias = false;
+			bool EnableAvatar = false;
+			bool ServerTLS = false;
+			MojString Preferences;
+			MojString ServerName;
+			MojString ServerPort;
+			MojString LoginTimeOut;
+			MojString BuddyListTimeOut;
+			MojString UserName;
+			MojString templateId;
+			MojObject m_ServerName;
+			MojObject m_ServerPort;
+			MojObject m_UserName;
+			MojObject m_templateId;
+			MojObject accountPreferences;
+			
+			bool SametimeHideID = false;
+			bool SIPEServerProxy = false;
+			MojString SIPEUserAgent;
+			MojString XFireVersion;
+			MojString SIPEServerLogin;
+			MojString JabberResource;
+			MojObject m_SIPEUserAgent;
+			MojObject m_XFireVersion;
+			MojObject m_SIPEServerLogin;
+			MojObject m_JabberResource;
+
+			MojObject::ConstArrayIterator PrefslItr = results.arrayBegin();
+			while (PrefslItr != results.arrayEnd()) {
+				accountPreferences = *PrefslItr;
+				
+				accountPreferences.toJson(Preferences);
+				MojLogError(IMServiceApp::s_log, _T("findCommandResult 'Preferences' result: %s"), Preferences.data());
+
+				//Get the results
+				accountPreferences.get ("BadCert", BadCert);
+				accountPreferences.get ("EnableAlias", EnableAlias);
+				accountPreferences.get ("EnableAvatar", EnableAvatar);
+				accountPreferences.getRequired ("ServerName", ServerName);
+				accountPreferences.getRequired ("ServerPort", ServerPort);
+				accountPreferences.getRequired ("LoginTimeOut", LoginTimeOut);
+				accountPreferences.getRequired ("BuddyListTimeOut", BuddyListTimeOut);
+				accountPreferences.get ("ServerTLS", ServerTLS);
+				accountPreferences.getRequired ("UserName", UserName);
+				accountPreferences.getRequired ("templateId", templateId);
+				
+				//Get non standard prefs
+				if (0 == templateId.compare(CAPABILITY_SAMETIME))
+				{
+					accountPreferences.get ("SametimeHideID", SametimeHideID);
+				}
+				if (0 == templateId.compare(CAPABILITY_SIPE))
+				{
+					accountPreferences.get ("SIPEServerProxy", SIPEServerProxy);
+					accountPreferences.getRequired ("SIPEUserAgent", SIPEUserAgent);
+					accountPreferences.getRequired ("SIPEServerLogin", SIPEServerLogin);
+				}
+				if (0 == templateId.compare(CAPABILITY_JABBER))
+				{
+					accountPreferences.getRequired ("JabberResource", JabberResource);
+				}
+				if (0 == templateId.compare(CAPABILITY_XFIRE))
+				{
+					accountPreferences.getRequired ("XFireversion", XFireVersion);
+				}
+				
+				//Set AccountID
+				char *accountKey = NULL;
+				const char* ServiceType = getMojoFriendlyServiceName (templateId.data());
+				const char* mojUserName = getMojoFriendlyUsername ((const char*)UserName.data(),ServiceType);
+				asprintf(&accountKey, "%s_%s", mojUserName, ServiceType);
+				
+				//Remove any entry in the hash tables
+				if (g_hash_table_lookup(s_AccountAliases, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_AccountAliases, accountKey);
+				}
+				if (g_hash_table_lookup(s_AccountAvatars, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_AccountAvatars, accountKey);
+				}
+				if (g_hash_table_lookup(s_AccountBadCert, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_AccountBadCert, accountKey);
+				}
+				if (g_hash_table_lookup(s_ServerName, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_ServerName, accountKey);
+				}
+				if (g_hash_table_lookup(s_ServerPort, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_ServerPort, accountKey);
+				}
+				if (g_hash_table_lookup(s_LoginTimeOut, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_LoginTimeOut, accountKey);
+				}
+				if (g_hash_table_lookup(s_BuddyListTimeOut, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_BuddyListTimeOut, accountKey);
+				}
+				if (g_hash_table_lookup(s_ServerTLS, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_ServerTLS, accountKey);
+				}
+				if (g_hash_table_lookup(s_SametimeHideID, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_SametimeHideID, accountKey);
+				}
+				if (g_hash_table_lookup(s_SIPEServerProxy, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_SIPEServerProxy, accountKey);
+				}
+				if (g_hash_table_lookup(s_SIPEUserAgent, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_SIPEUserAgent, accountKey);
+				}
+				if (g_hash_table_lookup(s_SIPEServerLogin, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_SIPEServerLogin, accountKey);
+				}
+				if (g_hash_table_lookup(s_XFireVersion, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_XFireVersion, accountKey);
+				}
+				if (g_hash_table_lookup(s_JabberResource, accountKey) != NULL)
+				{
+					g_hash_table_remove(s_JabberResource, accountKey);
+				}
+				
+				//Show results
+				//findCommandResult result: {"results":[{"BadCert":false,"EnableAlias":true,"EnableAvatar":true,"ServerName":"messenger.hotmail.com","ServerPort":"1863","UserName":"SOMEONE@HOTMAIL.COM","_id":"++HRyXbD3r+pt8M2","_kind":"org.webosinternals.messaging.prefs:1","_rev":41856,"_sync":true,"templateId":"ORG.WEBOSINTERNALS.MESSAGING.LIVE"}],"returnValue":true}
+				if (BadCert)
+				{
+					MojLogError(IMServiceApp::s_log, _T("'Preference' BadCert: true"));
+				}
+				else
+				{
+					MojLogError(IMServiceApp::s_log, _T("'Preference' BadCert: false"));
+				}
+				if (EnableAlias)
+				{
+					MojLogError(IMServiceApp::s_log, _T("'Preference' EnableAlias: true"));
+				}
+				else
+				{
+					MojLogError(IMServiceApp::s_log, _T("'Preference' EnableAlias: false"));
+				}
+				if (EnableAvatar)
+				{
+					MojLogError(IMServiceApp::s_log, _T("'Preference' EnableAvatar: true"));
+				}
+				else
+				{
+					MojLogError(IMServiceApp::s_log, _T("'Preference' EnableAvatar: false"));
+				}
+				if (ServerTLS)
+				{
+					MojLogError(IMServiceApp::s_log, _T("'Preference' ServerTLS: true"));
+				}
+				else
+				{
+					MojLogError(IMServiceApp::s_log, _T("'Preference' ServerTLS: false"));
+				}
+				if (0 == templateId.compare(CAPABILITY_SAMETIME))
+				{
+					//Show results
+					if (SametimeHideID)
+					{
+						MojLogError(IMServiceApp::s_log, _T("'Preference' SametimeHideID: true"));
+					}
+					else
+					{
+						MojLogError(IMServiceApp::s_log, _T("'Preference' SametimeHideID: false"));
+					}
+					//Add the results to the hash tables
+					g_hash_table_insert(s_SametimeHideID, accountKey, strdup(BoolToString(SametimeHideID)));
+				}
+				if (0 == templateId.compare(CAPABILITY_SIPE))
+				{
+					//Show results
+					if (SIPEServerProxy)
+					{
+						MojLogError(IMServiceApp::s_log, _T("'Preference' SIPEServerProxy: true"));
+					}
+					else
+					{
+						MojLogError(IMServiceApp::s_log, _T("'Preference' SIPEServerProxy: false"));
+					}
+					MojLogError(IMServiceApp::s_log, _T("'Preference' SIPEUserAgent: %s"), SIPEUserAgent.data());
+					MojLogError(IMServiceApp::s_log, _T("'Preference' SIPEServerLogin: %s"), SIPEServerLogin.data());
+					
+					//Add the results to the hash tables
+					g_hash_table_insert(s_SIPEServerLogin, accountKey, strdup(SIPEServerLogin.data()));
+					g_hash_table_insert(s_SIPEUserAgent, accountKey, strdup(SIPEUserAgent.data()));
+					g_hash_table_insert(s_SIPEServerProxy, accountKey, strdup(BoolToString(SIPEServerProxy)));
+				}
+				MojLogError(IMServiceApp::s_log, _T("'Preference' ServerName: %s"), ServerName.data());
+				MojLogError(IMServiceApp::s_log, _T("'Preference' ServerPort: %s"), ServerPort.data());
+				MojLogError(IMServiceApp::s_log, _T("'Preference' LoginTimeOut: %s"), LoginTimeOut.data());
+				MojLogError(IMServiceApp::s_log, _T("'Preference' BuddyListTimeOut: %s"), BuddyListTimeOut.data());
+				MojLogError(IMServiceApp::s_log, _T("'Preference' UserName: %s"), UserName.data());
+				MojLogError(IMServiceApp::s_log, _T("'Preference' templateId: %s"), templateId.data());
+				
+				if (0 == templateId.compare(CAPABILITY_XFIRE))
+				{
+					//Show results
+					MojLogError(IMServiceApp::s_log, _T("'Preference' XFireVersion: %s"), XFireVersion.data());
+					//Add the results to the hash tables
+					g_hash_table_insert(s_XFireVersion, accountKey, strdup(XFireVersion.data()));
+				}
+				if (0 == templateId.compare(CAPABILITY_JABBER))
+				{
+					//Show results
+					MojLogError(IMServiceApp::s_log, _T("'Preference' JabberResource: %s"), JabberResource.data());
+					//Add the results to the hash tables
+					g_hash_table_insert(s_JabberResource, accountKey, strdup(JabberResource.data()));
+				}
+				
+				//Add the results to the hash tables
+				g_hash_table_insert(s_AccountAliases, accountKey, strdup(BoolToString(EnableAlias)));
+				g_hash_table_insert(s_AccountAvatars, accountKey, strdup(BoolToString(EnableAvatar)));
+				g_hash_table_insert(s_AccountBadCert, accountKey, strdup(BoolToString(BadCert)));
+				g_hash_table_insert(s_ServerName, accountKey, strdup(ServerName.data()));
+				g_hash_table_insert(s_ServerPort, accountKey, strdup(ServerPort.data()));
+				g_hash_table_insert(s_ServerTLS, accountKey, strdup(BoolToString(ServerTLS)));
+				g_hash_table_insert(s_LoginTimeOut, accountKey, strdup(LoginTimeOut.data()));
+				g_hash_table_insert(s_BuddyListTimeOut, accountKey, strdup(BuddyListTimeOut.data()));
+			
+				//Loop
+				PrefslItr++;
+			}
+		}	
+	}
+
+	return MojErrNone;
+}
+
+MojErr LibpurpleAdapterPrefs::GetServerPreferences(const char* templateId, const char* UserName, char*& ServerName, char*& ServerPort, bool& ServerTLS, bool& BadCert)
+{
+	//Set AccountID
+	char *accountKey = NULL;
+	const char* ServiceType = getMojoFriendlyServiceName (templateId);
+	const char* mojUserName = getMojoFriendlyUsername (UserName,ServiceType);
+	asprintf(&accountKey, "%s_%s", mojUserName, ServiceType);
+	
+	//Get Server Name
+	ServerName = (char*)g_hash_table_lookup(s_ServerName, accountKey);
+	if (ServerName == NULL)
+	{
+		ServerName = (char*)"";
+	}
+	
+	//Get Server Port
+	ServerPort = (char*)g_hash_table_lookup(s_ServerPort, accountKey);
+	if (ServerPort == NULL)
+	{
+		ServerPort = (char*)"0";
+	}
+	
+	//Get Server TLS
+	ServerTLS = StringToBool((char*)g_hash_table_lookup(s_ServerTLS, accountKey));
+	
+	//Get Server Bad Cert Setting
+	BadCert = StringToBool((char*)g_hash_table_lookup(s_AccountBadCert, accountKey));
+	
+	return MojErrNone;
+}
+
+char* LibpurpleAdapterPrefs::GetStringPreference(const char* Preference, const char* templateId, const char* UserName)
+{MojLogError(IMServiceApp::s_log, _T("In GetStringPrefs: %s"),Preference);
+	// Set AccountID
+	char *accountKey = NULL;
+	const char* ServiceType = getMojoFriendlyServiceName (templateId);
+	const char* mojUserName = getMojoFriendlyUsername (UserName,ServiceType);
+	asprintf(&accountKey, "%s_%s", mojUserName, ServiceType);
+
+	char* Setting = NULL;
+	
+	if (strcmp(Preference, "SIPEUserAgent") == 0)
+	{
+		//Get SIPEUserAgent Setting
+		Setting = (char*)g_hash_table_lookup(s_SIPEUserAgent, accountKey);
+	}
+	if (strcmp(Preference, "XFireVersion") == 0)
+	{
+		//Get XFireVersion Setting
+		Setting = (char*)g_hash_table_lookup(s_XFireVersion, accountKey);
+		
+		//If Xfire version is blank default to 132
+		if (Setting == NULL)
+		{
+			Setting = (char*)"132";
+		}
+	}
+	if (strcmp(Preference, "SIPEServerLogin") == 0)
+	{
+		//Get SIPEServerLogin Setting
+		Setting = (char*)g_hash_table_lookup(s_SIPEServerLogin, accountKey);
+	}
+	if (strcmp(Preference, "JabberResource") == 0)
+	{
+		//Get JabberResource Setting
+		Setting = (char*)g_hash_table_lookup(s_JabberResource, accountKey);
+	}
+	
+	if (strcmp(Preference, "LoginTimeOut") == 0)
+	{
+		//Get Server Timeout
+		Setting = (char*)g_hash_table_lookup(s_LoginTimeOut, accountKey);
+		if (Setting == NULL)
+		{
+			Setting = (char*)"45";
+		}
+	}
+	
+	if (strcmp(Preference, "BuddyListTimeOut") == 0)
+	{
+		//Get BuddyList Timeout
+		Setting = (char*)g_hash_table_lookup(s_BuddyListTimeOut, accountKey);
+		if (Setting == NULL)
+		{
+			Setting = (char*)"10";
+		}
+	}
+	
+	if (Setting == NULL)
+	{
+		return (char*)"";
+	}
+	else
+	{
+		return Setting;
+	}
+}
+
+bool LibpurpleAdapterPrefs::GetBoolPreference(const char* Preference, const char* templateId, const char* UserName)
+{
+	//Set AccountID
+	char *accountKey = NULL;
+	const char* ServiceType = getMojoFriendlyServiceName (templateId);
+	const char* mojUserName = getMojoFriendlyUsername (UserName,ServiceType);
+	asprintf(&accountKey, "%s_%s", mojUserName, ServiceType);
+	
+	bool Setting = false;
+	
+	if (strcmp(Preference, "Avatar") == 0)
+	{
+		//Get Avatar Setting
+		Setting = StringToBool((char*)g_hash_table_lookup(s_AccountAvatars, accountKey));
+		return Setting;
+	}
+	if (strcmp(Preference, "Alias") == 0)
+	{
+		//Get Alias Setting
+		Setting = StringToBool((char*)g_hash_table_lookup(s_AccountAliases, accountKey));
+		return Setting;
+	}
+	if (strcmp(Preference, "SametimeHideID") == 0)
+	{
+		//Get SametimeHideID Setting
+		Setting = StringToBool((char*)g_hash_table_lookup(s_SametimeHideID, accountKey));
+		return Setting;
+	}
+	if (strcmp(Preference, "SIPEServerProxy") == 0)
+	{
+		//Get SIPEServerProxy Setting
+		Setting = StringToBool((char*)g_hash_table_lookup(s_SIPEServerProxy, accountKey));
+		return Setting;
+	}
+	return false;
+}
+
+/*
+ * Given the prpl-specific protocol_id, it will return mojo-friendly serviceName (e.g. given "prpl-aim", it will return "type_aim")
+ * Free the returned string when you're done with it 
+ */
+static char* getServiceNameFromPrplProtocolId(char* prplProtocolId)
+{
+	if (!prplProtocolId)
+	{
+		MojLogError(IMServiceApp::s_log, _T("getServiceNameFromPrplProtocolId called with empty protocolId"));
+		return strdup("type_default");
+	}
+	char* stringChopper = prplProtocolId;
+	stringChopper += strlen("prpl-");
+	GString* serviceName = g_string_new(stringChopper);
+
+	if (strcmp(serviceName->str, "jabber") == 0)
+	{
+		// Special case for gtalk where the mojo serviceName is "type_gtalk" and the prpl protocol_id is "prpl-jabber"
+		g_string_free(serviceName, true);
+		serviceName = g_string_new("gtalk");
+	}
+	if (strcmp(serviceName->str, "msn") == 0)
+	{
+		// Special case for live where the mojo serviceName is "type_live" and the prpl protocol_id is "prpl-msn"
+		g_string_free(serviceName, true);
+		serviceName = g_string_new("live");
+	}
+	if (strcmp(serviceName->str, "bigbrownchunx-facebookim") == 0)
+	{
+		// Special case for facebook where the mojo serviceName is "type_facebook" and the prpl protocol_id is "prpl-bigbrownchunx-facebookim"
+		g_string_free(serviceName, true);
+		serviceName = g_string_new("facebook");
+	}
+	if (strcmp(serviceName->str, "meanwhile") == 0)
+	{
+		// Special case for sametime where the mojo serviceName is "type_sametime" and the prpl protocol_id is "prpl-meanwhile"
+		g_string_free(serviceName, true);
+		serviceName = g_string_new("sametime");
+	}
+	if (strcmp(serviceName->str, "novell") == 0)
+	{
+		// Special case for groupwise where the mojo serviceName is "type_groupwise" and the prpl protocol_id is "prpl-novell"
+		g_string_free(serviceName, true);
+		serviceName = g_string_new("groupwise");
+	}
+	if (strcmp(serviceName->str, "gg") == 0)
+	{
+		// Special case for gadu where the mojo serviceName is "type_gadu" and the prpl protocol_id is "prpl-gg"
+		g_string_free(serviceName, true);
+		serviceName = g_string_new("gadu");
+	}
+	char* serviceNameToReturn = NULL;
+	// asprintf allocates appropriate-sized buffer
+	asprintf(&serviceNameToReturn, "type_%s", serviceName->str);
+	g_string_free(serviceName, true);
+	return serviceNameToReturn;
+}
+
+void LibpurpleAdapterPrefs::setaccountprefs(MojString templateId, PurpleAccount* account)
+{
+	//Load the preferences
+	char* ServerName;
+	char* ServerPort;
+	bool ServerTLS = false;
+	bool BadCert = false;
+	char* SIPEUserAgent;
+	char* XFireversion;
+	bool SIPEServerProxy = false;
+	bool SametimehideID = false;
+	
+	//Load account preferences
+	char* serviceName = getServiceNameFromPrplProtocolId(account->protocol_id);
+	char* username = getMojoFriendlyUsername(account->username, serviceName);
+	GetServerPreferences((const char*)templateId.data(), (const char*)username, ServerName, ServerPort, ServerTLS, BadCert);
+	
+	//If no server blank
+	if (strcmp(ServerName, "") == 0)
+	{
+		ServerName = (char*)"";
+	}
+	//If no port quit
+	if (strcmp(ServerPort, "") == 0)
+	{
+		return;
+	}
+	
+	//Bad Cert Accept?
+	purple_prefs_remove("/purple/acceptbadcert");
+	if (BadCert)
+	{
+		MojLogError(IMServiceApp::s_log, "Accepting Bad Certificates");
+		purple_prefs_add_string("/purple/acceptbadcert", "true");
+	}
+	
+	//Set account preferences
+	purple_account_set_string(account, "server", ServerName);
+	purple_account_set_string(account, "connect_server", ServerName);
+	if (0 == templateId.compare(CAPABILITY_GADU))
+	{
+		//Set connect server
+		purple_account_set_string(account, "gg_server", ServerName);
+		purple_account_set_int(account, "server_port", atoi(ServerPort));
+	}
+	purple_account_set_int(account, "port", atoi(ServerPort));
+	purple_account_set_bool(account, "require_tls", ServerTLS);
+	
+	if (ServerTLS)
+	{
+		purple_account_set_string(account, "transport", "tls");
+	}
+	else
+	{
+		purple_account_set_string(account, "transport", "auto");
+	}
+	if (0 == templateId.compare(CAPABILITY_QQ))
+	{
+		purple_account_set_string(account, "client_version", "qq2008");
+		
+		//Set server in servername:port format for QQ
+		char *qqServer = NULL;
+		qqServer = (char *)calloc(strlen(ServerName) + strlen(ServerPort) + 1, sizeof(char));
+		strcat(qqServer, ServerName);
+		strcat(qqServer, ":");
+		strcat(qqServer, ServerPort);
+		purple_account_set_string(account, "server", qqServer);
+	}
+	if (0 == templateId.compare(CAPABILITY_FACEBOOK))
+	{
+		//Don't load chat history
+		purple_account_set_bool(account, "facebook_show_history", false);
+	}
+	if (0 == templateId.compare(CAPABILITY_XFIRE))
+	{
+		XFireversion = GetStringPreference("XFireVersion", templateId, username);
+		purple_account_set_int(account, "version", atoi(XFireversion));
+	}
+		
+	if (0 == templateId.compare(CAPABILITY_SIPE))
+	{
+		SIPEUserAgent = GetStringPreference("SIPEUserAgent", templateId, username);
+		SIPEServerProxy = GetBoolPreference("SIPEServerProxy", templateId, username);
+		
+		//Set ServerName
+		if(strcmp(ServerName, "") != 0) 
+		{
+			char *SIPEFullServerName = NULL;
+			SIPEFullServerName = (char *)calloc(strlen(ServerName) + strlen(ServerPort) + 1, sizeof(char));
+			strcat(SIPEFullServerName, ServerName);
+			strcat(SIPEFullServerName, ":");
+			strcat(SIPEFullServerName, ServerPort);
+			purple_account_set_string(account, "server", SIPEFullServerName);
+
+			if (SIPEFullServerName)
+			{
+				free(SIPEFullServerName);
+			}
+		}
+
+		//Proxy?
+		if (!SIPEServerProxy)
+		{
+			//Disable Proxy
+			PurpleProxyInfo *info = purple_proxy_info_new();
+			purple_proxy_info_set_type(info, PURPLE_PROXY_NONE);
+		}
+
+		//User Agent
+		if(strcmp(SIPEUserAgent, "") != 0) 
+		{
+			purple_account_set_string(account, "useragent", SIPEUserAgent);
+		}
+	}
+	if (0 == templateId.compare(CAPABILITY_SAMETIME))
+	{
+		SametimehideID = GetBoolPreference("SametimeHideID", templateId, username);
+		purple_account_set_bool(account, "fake_client_id", SametimehideID);
+	}
+}
+
+void LibpurpleAdapterPrefs::init()
+{
+	//Initialise hash tables
+	s_AccountAliases = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_AccountAvatars = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_AccountBadCert = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_ServerName = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_ServerPort = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_ServerTLS = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_LoginTimeOut = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_BuddyListTimeOut = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	
+	s_SametimeHideID = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_SIPEServerProxy = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_SIPEUserAgent = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_XFireVersion = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_SIPEServerLogin = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	s_JabberResource = g_hash_table_new_full(g_str_hash, g_str_equal, NULL, NULL);
+	
+	LibpurpleAdapter::assignPrefsHandler(this);
+}
diff -rupN imlibpurpleservice-1.0/src/OnEnabledHandler.cpp imlibpurpleservice-1.0-new//src/OnEnabledHandler.cpp
--- imlibpurpleservice-1.0/src/OnEnabledHandler.cpp	2011-03-25 10:45:40.704552999 -0600
+++ imlibpurpleservice-1.0-new//src/OnEnabledHandler.cpp	2011-03-27 09:10:06.136552999 -0600
@@ -162,6 +162,8 @@ MojErr OnEnabledHandler::getDefaultServi
 			serviceName.assign(SERVICENAME_JABBER);
 		else if (templateId == "org.webosinternals.messaging.live")
 			serviceName.assign(SERVICENAME_LIVE);
+		else if (templateId == "org.webosinternals.messaging.wlm")
+			serviceName.assign(SERVICENAME_WLM);
 		else if (templateId == "org.webosinternals.messaging.myspace")
 			serviceName.assign(SERVICENAME_MYSPACE);
 		else if (templateId == "org.webosinternals.messaging.qq")
@@ -198,6 +200,8 @@ void OnEnabledHandler::getServiceNameFro
 		serviceName.assign(SERVICENAME_JABBER);
 	else if (m_capabilityProviderId == CAPABILITY_LIVE)
 		serviceName.assign(SERVICENAME_LIVE);
+	else if (m_capabilityProviderId == CAPABILITY_WLM)
+		serviceName.assign(SERVICENAME_WLM);	
 	else if (m_capabilityProviderId == CAPABILITY_MYSPACE)
 		serviceName.assign(SERVICENAME_MYSPACE);
 	else if (m_capabilityProviderId == CAPABILITY_QQ)
diff -rupN imlibpurpleservice-1.0/src/OnEnabledHandler.cpp~ imlibpurpleservice-1.0-new//src/OnEnabledHandler.cpp~
--- imlibpurpleservice-1.0/src/OnEnabledHandler.cpp~	1969-12-31 18:00:00.000000000 -0600
+++ imlibpurpleservice-1.0-new//src/OnEnabledHandler.cpp~	2011-03-27 09:10:06.148553000 -0600
@@ -0,0 +1,434 @@
+/*
+ * OnEnabledHandler.cpp
+ *
+ * Copyright 2010 Palm, Inc. All rights reserved.
+ *
+ * This program is free software and licensed under the terms of the GNU
+ * General Public License Version 2 as published by the Free
+ * Software Foundation;
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License,
+ * Version 2 along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-
+ * 1301, USA
+ *
+ * IMLibpurpleservice uses libpurple.so to implement a fully functional IM
+ * Transport service for use on a mobile device.
+ *
+ * OnEnabledHandler class handles enabling and disabling the IM account
+ */
+
+#include "OnEnabledHandler.h"
+#include "db/MojDbQuery.h"
+#include "IMServiceApp.h"
+#include "IMDefines.h"
+
+OnEnabledHandler::OnEnabledHandler(MojService* service)
+: m_getAccountInfoSlot(this, &OnEnabledHandler::getAccountInfoResult),
+  m_addImLoginStateSlot(this, &OnEnabledHandler::addImLoginStateResult),
+  m_deleteImLoginStateSlot(this, &OnEnabledHandler::deleteImLoginStateResult),
+  m_deleteImMessagesSlot(this, &OnEnabledHandler::deleteImMessagesResult),
+  m_deleteImCommandsSlot(this, &OnEnabledHandler::deleteImCommandsResult),
+  m_deleteContactsSlot(this, &OnEnabledHandler::deleteContactsResult),
+  m_deleteImBuddyStatusSlot(this, &OnEnabledHandler::deleteImBuddyStatusResult),
+  m_service(service),
+  m_dbClient(service, MojDbServiceDefs::ServiceName),
+  m_tempdbClient(service, MojDbServiceDefs::TempServiceName),
+  m_enable(false)
+{
+}
+
+OnEnabledHandler::~OnEnabledHandler()
+{
+}
+
+/*
+ * 1. get account details from accountservices or db?
+ */
+MojErr OnEnabledHandler::start(const MojObject& payload)
+{
+
+	IMServiceHandler::logMojObjectJsonString(_T("OnEnabledHandler payload: %s"), payload);
+
+	MojString accountId;
+	MojErr err = payload.getRequired(_T("accountId"), accountId);
+	if (err != MojErrNone) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler accountId missing so bailing. error %d"), err);
+		return err;
+	}
+
+	err = payload.getRequired(_T("enabled"), m_enable);
+	if (err != MojErrNone) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler enabled missing, assuming 'false'"));
+		m_enable = false;
+	}
+	
+	err = payload.getRequired(_T("capabilityProviderId"), m_capabilityProviderId);
+	if (err != MojErrNone) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler capabilityProviderId missing so bailing. error %d"), err);
+		return err;
+	}
+
+	MojRefCountedPtr<MojServiceRequest> req;
+	err = m_service->createRequest(req);
+	if (err != MojErrNone) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler::start createRequest failed. error %d"), err);
+	} else {
+		MojObject params;
+		params.put(_T("accountId"), accountId);
+		err = req->send(m_getAccountInfoSlot, "com.palm.service.accounts", "getAccountInfo", params, 1);
+		if (err) {
+			MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler::start: getAccountInfo id %s failed. error %d"), accountId.data(), err);
+		}
+	}
+
+	return MojErrNone;
+}
+
+/*
+ */
+MojErr  OnEnabledHandler::getAccountInfoResult(MojObject& payload, MojErr resultErr)
+{
+	MojLogTrace(IMServiceApp::s_log);
+	IMServiceHandler::logMojObjectJsonString(_T("OnEnabledHandler::getAccountInfoResult payload: %s"), payload);
+
+	if (resultErr != MojErrNone) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler getAccountInfo result error %d"), resultErr);
+		return resultErr;
+	}
+
+	MojObject result;
+	MojErr err = payload.getRequired("result", result);
+	if (err != MojErrNone || result.empty()) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler::getAccountInfoResult result empty or error %d"), err);
+		return err;
+	}
+
+	MojString accountId;
+	err = result.getRequired("_id", accountId);
+	if (err != MojErrNone || accountId.empty()) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler::getAccountInfoResult accountId empty or error %d"), err);
+		return err;
+	}
+
+	MojString username;
+	err = result.getRequired("username", username);
+	if (err != MojErrNone || username.empty()) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler::getAccountInfoResult username empty or error %d"), err);
+		return err;
+	}
+
+	MojString serviceName;
+	getServiceNameFromCapabilityId(serviceName);
+	if (serviceName.empty()) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler::getAccountInfoResult serviceName empty"));
+		return err;
+	}
+
+	if (m_enable) {
+		err = accountEnabled(accountId, serviceName, username);
+	} else {
+		err = accountDisabled(accountId, serviceName, username);
+	}
+
+	return err;
+}
+
+MojErr OnEnabledHandler::getDefaultServiceName(const MojObject& accountResult, MojString& serviceName)
+{
+	MojString templateId;
+	MojErr err = accountResult.getRequired("templateId", templateId);
+	if (err != MojErrNone) {
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler templateId empty or error %d"), err);
+	} else {
+		if (templateId == "org.webosinternals.messaging.aol.aim")
+			serviceName.assign(SERVICENAME_AIM);
+		else if (templateId == "org.webosinternals.messaging.facebook")
+			serviceName.assign(SERVICENAME_FACEBOOK);
+		else if (templateId == "org.webosinternals.messaging.google.talk")
+			serviceName.assign(SERVICENAME_GTALK);
+		else if (templateId == "org.webosinternals.messaging.gadu")
+			serviceName.assign(SERVICENAME_GADU);
+		else if (templateId == "org.webosinternals.messaging.groupwise")
+			serviceName.assign(SERVICENAME_GROUPWISE);
+		else if (templateId == "org.webosinternals.messaging.icq")
+			serviceName.assign(SERVICENAME_ICQ);
+		else if (templateId == "org.webosinternals.messaging.jabber")
+			serviceName.assign(SERVICENAME_JABBER);
+		else if (templateId == "org.webosinternals.messaging.live")
+			serviceName.assign(SERVICENAME_LIVE);
+		else if (templateId == "org.webosinternals.messaging.myspace")
+			serviceName.assign(SERVICENAME_MYSPACE);
+		else if (templateId == "org.webosinternals.messaging.qq")
+			serviceName.assign(SERVICENAME_QQ);
+		else if (templateId == "org.webosinternals.messaging.sametime")
+			serviceName.assign(SERVICENAME_SAMETIME);
+		else if (templateId == "org.webosinternals.messaging.sipe")
+			serviceName.assign(SERVICENAME_SIPE);
+		else if (templateId == "org.webosinternals.messaging.xfire")
+			serviceName.assign(SERVICENAME_XFIRE);
+		else if (templateId == "org.webosinternals.messaging.yahoo")
+			serviceName.assign(SERVICENAME_YAHOO);
+		else
+			err = MojErrNotImpl;
+	}
+	return err;
+}
+
+void OnEnabledHandler::getServiceNameFromCapabilityId(MojString& serviceName) 
+{
+	if (m_capabilityProviderId == CAPABILITY_AIM)
+		serviceName.assign(SERVICENAME_AIM);	
+	else if (m_capabilityProviderId == CAPABILITY_FACEBOOK)
+		serviceName.assign(SERVICENAME_FACEBOOK);
+	else if (m_capabilityProviderId == CAPABILITY_GTALK)
+		serviceName.assign(SERVICENAME_GTALK);
+	else if (m_capabilityProviderId == CAPABILITY_GADU)
+		serviceName.assign(SERVICENAME_GADU);
+	else if (m_capabilityProviderId == CAPABILITY_GROUPWISE)
+		serviceName.assign(SERVICENAME_GROUPWISE);
+	else if (m_capabilityProviderId == CAPABILITY_ICQ)
+		serviceName.assign(SERVICENAME_ICQ);
+	else if (m_capabilityProviderId == CAPABILITY_JABBER)
+		serviceName.assign(SERVICENAME_JABBER);
+	else if (m_capabilityProviderId == CAPABILITY_LIVE)
+		serviceName.assign(SERVICENAME_LIVE);
+	else if (m_capabilityProviderId == CAPABILITY_MYSPACE)
+		serviceName.assign(SERVICENAME_MYSPACE);
+	else if (m_capabilityProviderId == CAPABILITY_QQ)
+		serviceName.assign(SERVICENAME_QQ);
+	else if (m_capabilityProviderId == CAPABILITY_SAMETIME)
+		serviceName.assign(SERVICENAME_SAMETIME);
+	else if (m_capabilityProviderId == CAPABILITY_SIPE)
+		serviceName.assign(SERVICENAME_SIPE);
+	else if (m_capabilityProviderId == CAPABILITY_XFIRE)
+		serviceName.assign(SERVICENAME_XFIRE);
+	else if (m_capabilityProviderId == CAPABILITY_YAHOO)
+		serviceName.assign(SERVICENAME_YAHOO);
+}
+
+/*
+ * Example messaging capability provider
+ *  "capabilityProviders": [{
+            "_id": "2+MR",
+            "capability": "MESSAGING",
+            "id": "com.palm.google.talk",
+            "capabilitySubtype": "IM",
+            "loc_name": "Google Talk",
+            "icon": {
+                "loc_32x32": "/usr/palm/public/accounts/com.palm.google/images/gtalk32x32.png",
+                "loc_48x48": "/usr/palm/public/accounts/com.palm.google/images/gtalk48x48.png",
+                "splitter": "/usr/palm/public/accounts/com.palm.google/images/gtalk_transport_splitter.png"
+            },
+            "implementation": "palm://com.palm.imlibpurple/",
+            "onEnabled": "palm://com.palm.imlibpurple/onEnabled"
+            "serviceName":"type_aim",
+            "dbkinds": {
+                "immessage":"com.palm.immessage.libpurple:1",
+                "imcommand":"com.palm.imcommand.libpurple:1"
+            }
+    }],
+ */
+MojErr OnEnabledHandler::getMessagingCapabilityObject(const MojObject& capabilityProviders, MojObject& messagingObj)
+{
+	// iterate thru the capabilities array
+	MojErr err = MojErrRequiredPropNotFound;
+	MojString capability;
+	MojObject::ConstArrayIterator itr = capabilityProviders.arrayBegin();
+	// This shouldn't happen, but check if there's nothing to do.
+	while (itr != capabilityProviders.arrayEnd()) {
+		messagingObj = *itr;
+		err = messagingObj.getRequired("capability", capability);
+		if (capability == "MESSAGING") {
+			err = MojErrNone;
+			break;
+		}
+		++itr;
+	}
+
+	return err;
+}
+
+/*
+ * Enabling an IM account requires the following
+ *     add com.palm.imloginstate.libpurple record
+ */
+MojErr OnEnabledHandler::accountEnabled(const MojString& accountId, const MojString& serviceName, const MojString& username)
+{
+	//TODO: first issue a merge in case the account already exists?
+	MojLogTrace(IMServiceApp::s_log);
+	MojLogInfo(IMServiceApp::s_log, _T("accountEnabled id=%s, serviceName=%s"), accountId.data(), serviceName.data());
+
+	MojObject imLoginState;
+	imLoginState.putString(_T("_kind"), IM_LOGINSTATE_KIND);
+	imLoginState.put(_T("accountId"), accountId);
+	imLoginState.put(_T("serviceName"), serviceName);
+	imLoginState.put(_T("username"), username);
+	imLoginState.putString(_T("state"), LOGIN_STATE_OFFLINE);
+	imLoginState.putInt(_T("availability"), PalmAvailability::ONLINE); //default to online so we automatically login at first
+	MojErr err = m_dbClient.put(m_addImLoginStateSlot, imLoginState);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler db.put() failed: error %d - %s"), err, error.data());
+	}
+
+	return err;
+}
+
+/*
+ * Disabling an account means doing the following
+ *     delete com.palm.imloginstate.libpurple record
+ *     delete com.palm.immessage.libpurple records
+ *     delete com.palm.imcommand.libpurple records
+ *     delete com.palm.contact.libpurple records
+ *     delete com.palm.imbuddystatus.libpurple records
+ *     delete com.palm.imgroupchat.libpurple records -- groupchats not currently supported
+ * Note: the ChatThreader service takes care of removing empty chats
+ */
+MojErr OnEnabledHandler::accountDisabled(const MojString& accountId, const MojString& serviceName, const MojString& username)
+{
+	MojLogTrace(IMServiceApp::s_log);
+	MojLogInfo(IMServiceApp::s_log, _T("accountDisabled id=%s, serviceName=%s"), accountId.data(), serviceName.data());
+
+	// delete com.palm.imloginstate.libpurple record
+	MojDbQuery queryLoginState;
+	queryLoginState.from(IM_LOGINSTATE_KIND);
+	queryLoginState.where(_T("serviceName"), MojDbQuery::OpEq, serviceName);
+	queryLoginState.where(_T("username"), MojDbQuery::OpEq, username);
+	MojErr err = m_dbClient.del(m_deleteImLoginStateSlot, queryLoginState);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler db.del(imloginstate) failed: error %d - %s"), err, error.data());
+	}
+
+	// delete com.palm.immessage.libpurple records
+	//TODO: need to query both from & recipient addresses. Simplify this???
+	MojDbQuery queryMessage;
+	queryMessage.from(IM_IMMESSAGE_KIND);
+	queryLoginState.where(_T("serviceName"), MojDbQuery::OpEq, serviceName);
+	queryLoginState.where(_T("username"), MojDbQuery::OpEq, username);
+	err = m_dbClient.del(m_deleteImMessagesSlot, queryMessage);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler db.del(immessage) failed: error %d - %s"), err, error.data());
+	}
+
+	// delete com.palm.imcommand.libpurple records
+	MojDbQuery queryCommand;
+	queryCommand.from(IM_IMCOMMAND_KIND);
+	queryLoginState.where(_T("serviceName"), MojDbQuery::OpEq, serviceName);
+	queryLoginState.where(_T("username"), MojDbQuery::OpEq, username);
+	err = m_dbClient.del(m_deleteImMessagesSlot, queryCommand);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler db.del(imcommand) failed: error %d - %s"), err, error.data());
+	}
+
+	// delete com.palm.contact.libpurple record
+	MojDbQuery queryContact;
+	queryContact.from(IM_CONTACT_KIND);
+	queryContact.where(_T("accountId"), MojDbQuery::OpEq, accountId);
+	err = m_dbClient.del(m_deleteContactsSlot, queryContact);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler db.del(contact) failed: error %d - %s"), err, error.data());
+	}
+
+	// delete com.palm.imbuddystatus.libpurple record
+	MojDbQuery queryBuddyStatus;
+	queryBuddyStatus.from(IM_BUDDYSTATUS_KIND);
+	queryBuddyStatus.where(_T("accountId"), MojDbQuery::OpEq, accountId);
+	err = m_tempdbClient.del(m_deleteImBuddyStatusSlot, queryBuddyStatus);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogError(IMServiceApp::s_log, _T("OnEnabledHandler db.del(imbuddystatus) failed: error %d - %s"), err, error.data());
+	}
+
+	// now we need to tell libpurple to disconnect the account so we don't get more messages for it
+	// LoginCallbackInterface is null because we don't need to do any processing on the callback - all the DB kinds are already gone.
+	LibpurpleAdapter::logout(serviceName, username, NULL);
+
+	return MojErrNone;
+}
+
+MojErr OnEnabledHandler::addImLoginStateResult(MojObject& payload, MojErr err)
+{
+	MojLogTrace(IMServiceApp::s_log);
+
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogCritical(IMServiceApp::s_log, _T("addLoginStateResult failed: error %d - %s"), err, error.data());
+		//TODO retry adding the record. Not worrying about this for now because the add would only fail in
+		// extreme conditions.
+	}
+	return err;
+}
+
+
+MojErr OnEnabledHandler::deleteImLoginStateResult(MojObject& payload, MojErr err)
+{
+	MojLogTrace(IMServiceApp::s_log);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogCritical(IMServiceApp::s_log, _T("deleteImLoginStateResult failed: error %d - %s"), err, error.data());
+	}
+	return err;
+}
+
+MojErr OnEnabledHandler::deleteImMessagesResult(MojObject& payload, MojErr err)
+{
+	MojLogTrace(IMServiceApp::s_log);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogCritical(IMServiceApp::s_log, _T("deleteImMessagesResult failed: error %d - %s"), err, error.data());
+	}
+	return err;
+}
+
+MojErr OnEnabledHandler::deleteImCommandsResult(MojObject& payload, MojErr err)
+{
+	MojLogTrace(IMServiceApp::s_log);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogCritical(IMServiceApp::s_log, _T("deleteImCommandsResult failed: error %d - %s"), err, error.data());
+	}
+	return err;
+}
+
+MojErr OnEnabledHandler::deleteContactsResult(MojObject& payload, MojErr err)
+{
+	MojLogTrace(IMServiceApp::s_log);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogCritical(IMServiceApp::s_log, _T("deleteContactsResult failed: error %d - %s"), err, error.data());
+	}
+	return err;
+}
+
+MojErr OnEnabledHandler::deleteImBuddyStatusResult(MojObject& payload, MojErr err)
+{
+	MojLogTrace(IMServiceApp::s_log);
+	if (err != MojErrNone) {
+		MojString error;
+		MojErrToString(err, error);
+		MojLogCritical(IMServiceApp::s_log, _T("deleteImBuddyStatusResult failed: error %d - %s"), err, error.data());
+	}
+	return err;
+}
+
